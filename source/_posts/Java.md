# Java

# JDK JRE JVM

JDK, java 开发工具集合；包含 JRE
JRE, java 运行环境；包含 JVM
JVM, java 虚拟机；包含解析 java 和打包 java 的程序

# Java 特性

跨平台性(可移植)
class 类

源文件 HelloWorld.java 通过 javac.exe 编译 为 HelloWorld.class 文件（字节码文件）;
通过 java.exe 将 HelloWorld.class 文件执行。

# java 语言基础

## 关键字

## 标识符

Java 名称规范：
包名：多单词组成时所有字母都小写 aaabbbccc
类名接口名：多单词组成时，所有单词的首字母大写 AaaBbbCcc
变量名和函数名： 多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写 aaaBbb
常量名：所有字母大写。多单词下划线连接。AAA_BBB_CCC

## 注释

## 常量

整数常量
小数常量
布尔型常量：true, false
字符常量： 'x'
字符串常量： "xxx"
null

负数的二进制数表示： 正数的二进制取反 + 1
正数的二进制数：最高位为 0；
负数的二进制数：最高位为 1

## 变量

java 是强类型语言，对每一种数据都定义了明确的数据类型，并且在内存中分配不同的内存空间。
数据类型：
基本数据类型：

- 数值型： 整数类型（byte（1 字节）, short（2 字节）, int（4 字节）, long（8 字节））浮点类型（float（4 字节）, double（8 字节））
- 字符型：char （2 字节）
- 布尔型：boolean（1 字节）
  引用数据类型：
- 类 class
- 接口 interface
- 数组 []
  整数默认：int ；小数默认：short
  类型转换：
- 自动类型提升，小类型提升变为大类型去做运算（jvm 自动做）；
- 强制类型转换：(int)xxx

## 运算符

算术运算符，逻辑运算符（与 & 或 | 非 ! 异或 ^ 短路运算符 && ||）
位运算符 ：与 & 或 | 非 ! 异或 ^

- << 左移
- \>> 右移（右移后，原数据最高位是什么，就补什么））
- \>>> 无符号右移（右移后最高位补 0）

三元运算符 （ xxx ？ xx ： x）

## 语句

程序流程控制：

- 判断结构
- 选择结构
- 循环结构

## 函数

函数的重载，同一个类中有多个不同参数个数和不同参数类型的同名函数。
重载和返回值的类型没有关系。

## 数组

同一种类型数据的集合。数组是一种引用的数据类型，数据存储在堆内存中。
数组名指向数组内存地址。
给数组赋值 null，会回收没有被引用的内存。
ArrayIndexOutOfBoundsException: 数组访问越界错误
NullPointerException：空指针异常，当引用没有任何指向，值为 null，还被用于操作实体会出现该错误。

## 面向对象

面向对象是一种抽象的思想。
属性：公共特性的抽取。
方法：公共的行为的抽取。
面向对象的三大特性： 封装，继承，多态。
描述现实中的事物， 事物与事物之间的关系，事物的属性，事物的行为。
找对象，建立对象，维护对象的关系。

类和对象的关系：
类是一类具有相同特性的事物的抽象。 抽取共性。
对象：就是某个具体的事物。

成员变量：保存在对内存中
局部变量：保存在栈内存中，代码块语句中声明的变量，执行完 回收。

匿名对象：当对象的方法只调用一次时，可以用匿名对象来完成，这是简化。匿名对象可以作为实参传递。

封装：隐藏对象的属性和实现细节，仅对外提供公共的访问方式。好处：将变化隔离，便于使用，提高重用性，提高安全性。
权限修饰符：public 全都可以使用, private 仅类内部使用。
私有化（private 修饰） 是封装的 一种表现形式。
在访问属性时，加入逻辑判断以提高代码的健壮性。

构造函数：
函数名与类名相同；
不用定义返回值类型；
不可以写 return；
对象一建立，就会执行一次构造函数，构造函数用于给对象初始化。
不定义该构造函数，会有一个默认的构造函数。
构造函数 不要使用 private 修饰，否则无法执行构造函数的初始化。
默认的构造函数的权限访问符同类名的权限访问符。

构造代码块：给不同对象的共性内容进行初始化，对象一建立就运行，而且优先于构造函数执行。
构造代码块是给所有对象进行统一的初始化，而构造函数是给对应的对象初始化。

this 指向当前对象。this 用于在构造函数中，接收同名变量。
this()函数用于在多个构造函数时，在构造函数内部调用，且必须在首行调用。

static 关键字，使用 static 修饰 成员（变量，函数）， 该变量的值就成为了共享的数据。节省内存空间。还可以通过类名直接调用该变量。其修饰的变量，存放在共享区。

- 随着类的加载而加载。静态会随着类的消失而消失，它的生命周期最长。
- 优先于对象存在。
- 被所有对象共享。
- 可以直接通过类名调用。

主函数 public static void main（String[] args）是一个特殊的函数，作为程序的入口，可以被 jvm 调用

- public: 代表着该函数访问权限是最大的。
- static: 代表著函数随着类的加载就已经存在。
- void: 主函数没有具体的返回值。
- main: 不是关键字，但是是一个特殊的单词，可以被 jvm 识别
- String[] args: 函数的参数，参数类型是一个数组，该数组中的元素是字符串，字符串类型的数组。
- 主函数是固定格式的，才能被 jvm 识别。
- jvm 在调用主函数时，传入的参数是 new String[0]; 如果使用 java 命令执行 编译之后的字节码文件 时， 可以将命令行的参数以 String[] 的形式传入到 main 函数。
- static 静态常应用将通用工具函数抽取，创建工具类，使用 static 修饰。
- 强制类不能创建对象，可以通过将构造函数私有化（private）完成。

java 帮助文档制作： javadoc -d myhelp -author -version XXX.java  
注意类名必须使用 public 修饰。只会提取非 private 的内容。

静态代码块， 随着类的加载而执行，只执行一次。用于给类进行初始化（不需要对象时）。优先于主函数执行。

单例设计模式：解决一个类在内存中只能创建一个对象。

继承： 抽取公共特性到一个类中，作为父类。使用关键字 extends。

- 提高了代码的复用性。
- 让类与类之间产生了关系。有了这种关系，就有了多态的特性。
- java 中只支持单继承，不支持多继承；因为多继承容易带来安全隐患：当多个父类中定义了相同功能，当功能内容不同的时候，子类对象不确定要运行哪一个。但是 java 保留了这种机制，使用了其他实现方式：多实现。
- 子类中执行 super()方法, 就是执行父类的构造函数,可以通过 super.xxx 访问父类中定义的变量和函数。
- 访问变量和函数的时候，会从子类 根据继承关系向上一层一层查找。子类的函数和父类的函数同名（参数，返回值相同）时，使用子类的函数，这称为重写（覆盖）。静态只能覆盖静态，子类的变量/函数访问权限必须大于父类的访问权限。
- this 代表本类的对象引用，super 代表父类的对象引用。在对子类对象进行初始化时，父类的构造函数也会运行，那是因为子类的构造函数默认第一行有一条隐式的语句 super()调用；super()调用会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是 super()。通过手动指定 super(xx) 的调用可以执行指定的父类构造函数。

final 作为一个修饰符：
- 可以修饰类，函数，变量。
- 被final修饰的类不可以被继承。为了避免被继承，被子类复写函数，以防打破封装性。
- 被final修饰的方法不可 以被复写。
- 被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，也可以修饰局部变量。

abstract 修饰符：只能修饰类和方法。当多个类中出现相同功能，但是功能主体不同，这时可以进行向上抽取。只能抽取功能定义，而不抽取功能主体。
- 抽象方法一定在抽象类中。
- 抽象方法和抽象类都必须被abstract关键字修饰。
- 抽象类不能用new 创建对象。因为调用抽象类没有意义。
- 抽象类中的方法要被使用，必须由子类继承抽象类，并且重写所有的抽象方法，建立子类对象调用。如果子类只覆盖了部分的抽象方法，那么该子类还是一个抽象类。
- 抽象类和一般类不同的地方：可以定义抽象方法，不能通过该类建立对象。

模版方法设计模式： 在定义功能时，功能的一部分是确定的，一部分是不确定的（使用抽象）。在确定的部分中使用不确定的部分，将不确定的部分暴露出去，由该类的子类去完成。主要是 抽象类，抽象方法的应用。

interface 关键字用于定义接口：可以认为是一个特殊的抽象类，当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。使用implements关键字来声明一个实现接口的类。
接口定义常见定义常量和抽象方法，接口成员都有固定的修饰符。接口中的成员都是public的。
- 常量：public static final
- 方法：public abstract

多实现：类可以同时实现多个接口。
接口可以继承另一个接口。接口之间可以多继承。

多态： 事物存在的多种体现形态。对象的多态性。
- 多态的表现：父类的引用指向了自己的子类对象。
- 多态的前提：类与类之间有关系，继承关系，实现关系。通常还有一个前提：存在覆盖。
- 多态的好处：多态出现大大提高程序的扩展性。
- 多态的弊端：只能使用父类的引用访问父类中的成员。
- 多态的应用：将一堆对象的公共方法抽取，通过相同的方式去调用（工具类的方法）。
- 多态的特点：成员函数在多态调用时，编译看左边，运行看右边。成员变量（静态成员函数）：无论编译还是运行都参考左边（引用型变量所属的类）。

Object类是所有对象的直接或间接父类。该类定义了所有对象都具备的功能。
Object.equals() 方法，比较的是引用地址，作用同 ==
Object.toString() 方法，返回该对象的字符串表示。

内部类：将一个类定义在另一个类的里面，将该类成为内部类。
内部类可以直接访问外部类中的成员，包括私有成员。原因：内部类中有一个外部类的引用；通过外部类名.this可以访问。
外部类要访问内部类中的成员必须建立内部类的对象。
内部类作为成员变量可以使用private修饰。
内部类可以被static修饰：修饰后只能访问外部类中的static成员。出现了访问局限。
内部类中出现静态成员，内部类必须使用static修饰。当外部类中的静态方法访问内部类时，内部类也必须是static的。
使用内部类的原则：当描述事物时，事物的内部还有事物，该事物用内部类来描述。
匿名内部类

异常：程序运行时不正常情况。也是java 对于不正常情况进行抽象后的体现，
对于严重的，java通过Error类进行描述。对于非严重通过Exception类进行描述。

异常处理： try catch
jvm 默认的异常处理机制：就是在调用e.printStackTrace方法。打印异常的堆栈的跟踪信息。
throws Exception 在功能上通过throws的关键字声明了该功能有可能会出现问题。提示使用者使用try catch捕获异常。

多异常处理：针对性的异常处理与throws Exception对应。
自定义异常：对特有的问题，进行自定义的异常封装。

throw和throws的区别： throws在函数定义上使用，throw在函数内部使用。 throws后面跟的异常类可以跟多个，用多好隔开。
对于异常分两种：
- 编译时被检测的异常。
- 编译时不被检测的异常（运行时异常。RuntimeException 及其子类）。

Exception中有一个特殊的子类异常RuntimeException（运行时异常）：在函数内抛出，在函数定义上无需声明throws。
如果在函数内容抛出该异常，函数调用者可以不用声明，编译一样通过；如果函数上声明了该异常，调用者可以不用进行处理，编译一样通过。

不需要在函数上声明是因为不需要让调用者处理。当异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况。希望停止程序后，对代码进行修正。
常见的RuntimeException：NullPointerException（空指针异常）。
自定义异常时：如果该异常发生，无法继续进行运算，就让自定义异常继承RuntimeException。

finally：存放的是一定会执行的代码。通常用于关闭资源。
异常处理的三种格式：try-catch， try-catch-finally， try-finally。

异常在子父类方法覆盖中的体现：
1. 子类在覆盖父类的方法时，如果父类的方法抛出A异常，那么子类的覆盖方法只能抛出A异常或者A异常的子类。
2. 如果父类方法抛出多个异常，子类在覆盖方法时，只能抛出父类异常的子集。
3. 如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。如果子类方法发生了异常。就必须要进行try处理。绝对不能抛。


包：关键字 package
- 对类文件进行分类管理
- 给类提供多层命名空间
- 写在程序文件的第一行
- 类名的全称是 包名.类名
- 包也是一种封装形式

包与包之间进行访问，被访问的包中的类以及类中的成员，需要public修饰，不同包中的子类还可以直接访问父类中被protected权限修饰的成员。
包与包之间可以使用的权限只有两种，public， protected。
导入：import关键字，导入的是包中的类。

jar包：将多个类文件合并到一个jar文件中。
命令行： jar -cvf classes.jar Foo.java 

# 多线程
进程： 是一个正在执行中的程序。每一个进程执行都有一个执行顺序。该执行顺序是一个执行路径，或者叫一个控制单元。
线程：就是进程中的一个独立的控制单元。
一个进程至少有一个线程。
java 虚拟机（jvm） 启动时会有一个进程java.exe
该进程至少一个线程负责java程序的执行。而且这个线程运行的代码存在于main的方法中。该线程称为主线程。
jvm启动的不止一个线程，还有负责垃圾回收的线程。

线程的创建：Thread类
Thread.currentThread(): 获取当前执行的线程对象。
getName(): 获取线程名称。
设置线程名称：setName()或构造函数。

方法1: 将类声明为Thread 的子类，子类重写run 方法。run方法存储线程要运行的代码。
- 定义类继承 Thread 类。
- 复写Thread类中的run方法。
- 调用线程的start方法。该方法的作用：启动线程；调用run方法。
多线程都在获取cpu的执行权限。cpu执行到谁，谁就运行。在某一时刻，只能有一个程序 在运行（多核除外）。cpu在快速切换，以达到看上去在同时运行的效果。

方法2: 声明实现Runnable接口的类。该类要实现run方法。然后要创建该类的实例对象作为Thread的参数。 这种方式的好处是：避免了单继承的局限性。在定义线程时，建议使用实现方式。

两种方式的区别： 
继承Thread：线程代码存放在Thread子类方法中。
实现Runnable：线程代码存在接口的子类的run方法中。

多线程运行的安全问题：
当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来。导致共享数据的错误。
解决办法：对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。
java 对于多线程的安全问题提供了专业的解决方式。就是同步代码块。synchronized(对象){}

持有锁的线程可以在同步代码中执行。没有持有锁的线程即使获取cpu的执行权限，也进不去，因为没有获取锁。

同步的前提：
1. 必须有两个或两个以上的线程。
2. 必须是多个线程使用同一个锁。
3. 只有处理共享数据时才需要锁。

好处：解决了多线程的安全问题。坏处：多个线程需要判断锁，较为消耗资源。

同步函数：使用synchronized 修饰符 修饰函数，让函数具有同步性。
函数需要被对象调用，那么函数都有一个所属对象的引用，就是this。因此同步函数使用的锁是this。

静态函数进入内存时，内存还没有本类对象，但是一定有该类对应的字节码文件对象。类名.class 该对象的类型是class。
静态同步函数的锁是该方法所在类的字节码文件对象。类名.class。

死锁：同步中嵌套同步，而且两个同步的锁还不一样。

线程间通信：多个线程在操作同一个资源，但是操作的动作不同。
解决线程间安全问题：使用资源的生产者和消费者都是用同步函数或同步代码块包裹，并要使用相同的对象（可以是唯一的资源对象）作为锁。
等待唤醒机制：使用wait 和 notify方法。wait将线程放入线程池中等待，notify将线程唤醒。notifyAll方法唤醒线程中的所有。

wait，notify和notifyAll方法
- 这些方法都定义在Object类中，因为这些方法在操作同步中线程时，都必须要标识它们所操作只有的锁，等待和唤醒必须是同一个锁。锁可以是任意对象，所以可以被任意对象调用的方法定义在Object中。
- 都是用在同步中是因为因为要对持有锁的线程操作。所以要在同步中使用，只有同步才有锁。
- wait应该总是使用在while循环中，以防止虚假唤醒。

生产者消费者模式：多个线程生产资源，多个线程消费资源时；
```java
while(flag) {
  this.wait();
}

this.notifyAll();
```

java.util.concurrent.locks包提供了锁的相关api，将synchronized替换成显式的Lock操作（lock， unlock）。
将Object中的wait,notify,notifyAll,替换成了Condition对象。实现了本方只唤醒对象操作。

线程结束：stop已弃用，只有一种，run结束可以结束线程。开启多线程运行，运行代码通常是循环结构。只要控制住循环，就可以 让run方法结束，也就是线程结束。
特殊情况：当线程处于了冻结状态。就不会读取到标记，那么线程就不会结束。当没有指定的方式让冻结的线程恢复到运行状态时，这是需要对冻结状态进行清除。强制让线程恢复到运行状态中来。Thread类提供了 interrupt 方法强制清除线程的中断状态，让线程恢复到运行状态中，来操作标记让线程结束。

守护线程（后台线程）：Thread类提供的setDaemon方法。将该线程标记为守护线程，当正在运行的线程都是守护进程时，java虚拟机退出。

Thread类join方法，抢夺执行权。当A线程执行到了B线程的join（）方法时，A就会等待。等B线程执行完，A才会执行。
join可以用来临时加入线程执行。

Thread类toString方法，返回线程的名称，优先级和线程组。
Thread类yield方法，让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权。

String类，字符串一旦被初始化就不可以被改变。
String类复写了Object类中equals方法。 该方法用于判断字符串是否相等。

字符串常见操作：
- 获取字符串长度 string.length();
- 获取某个位置上的字符：string.charAt(index); index超出长度，会出现StringIndexOutOfBoundsException错误。
- 获取字符第一次出现的位置，从头开始遍历查找：string.indexOf('x'); 没有找到返回-1
- 获取字符在此字符串中最后一次出现处的索引，从尾部开始遍历查找： string.lastIndexOf('x') 
- 判断字符串是否包含某个字符：
- 判断字符串中是否有内容：
- 判断字符串是否以指定内容开头：
- 判断字符串是否以指定内容结尾：

13-03 start
