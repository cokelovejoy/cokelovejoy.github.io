---
title: 短链接
date: 2020-05-19 17:21:47
tags:
---

# 短链接的实现原理
短链接主要是通过域名重定向技术，将长网址通过一定的算法转换成一个短链接。当用户访问这个短链接时就可以直接跳转到较长的URL的地址上。域名重定向技术也可以称为URL转发技术，它是通过网站服务器或者各种应用程序的设置，将访问当前域名的用户引导至另一个URL地址。

## 短链接好处
1. 链接变短，在对内容长度有限制的平台发文，可编辑的文字就变多了
2. 将链接转为二维码的形式分享给他人时，如果是长链，二维码就会变得密集难以识别
3. 链接太长在有些平台上无法识别为超链接

## 短链接跳转的基本原理
访问短网址后重定向访问长网址

## 状态码
### 301
301代表永久重定向，也就是第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，缺点就是在server层就无法获取短网址的点击数， 如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。因此一般不采用301。

### 302
302代表临时重定向，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用Cache-Control或Expired暗示浏览器缓存），这样就便于server统计点击数，缺点就是增加了服务器的压力。但在数据异常重要的今天，这是值得的，所以推荐使用302。

## 使用哈希生成短链接
1. 哈希算法
短链组成： 固定短链域名 + 长链 映射成的一串字母
通过hash函数计算长链生成 一串字母，然后拼接短链域名形成短链接。
这里是使用的hash算法不需要考虑反向解密的难度，只需要考虑hash的运算速度和冲突概率。

推荐使用： GOOGLE 的 MurmurHash算法

2. MurmurHash
MurmurHash 是一种非加密型的哈希函数，适合用于一般的哈希检索操作。与其他流行的哈希函数相比，对于规律性较强的key,MurmurHash 的随机分布特征表现更良好。非加密意味着相比MD5,SHA这些函数它的性能肯定更高（实际性能是MD5等加密算法的十倍），现在正被广泛应用。

MurmurHash 提供了两种长度的哈希值，32bit，128bit，为了让网址尽可能的短，我们选择32bit的哈希值，32bit所能表示的最大值近43亿，对于中小型的公司的业务而言绰绰有余。

3. 缩短域名
将10 进制的数转换成 62进制的数，62进制的数去表示568亿的数，应付长链转换绰绰有余。

4. 解决哈希冲突
哈希函数不可避免地会产生哈希冲突（尽管概率很低）。
选择数据库保存 短链和长链之间的映射关系。

* 设计思路
1. 将长链经过MurmurHash后得到短链。
2. 在根据短链去short_url_map 表中查找看是否存在相关记录，如果不存在，将长链与短链对应关系插入数据库中，存储。
3. 如果存在，说明已经有相关记录，此时在长串上拼接一个自定义好的字段如[DUPLICATE]，然后再对[lurl + DUPLICATE]再做hash运算。如果最后还是重复，再拼一个字段串，只要根据短链取出长链的时候把这些自定义好的字符串把这些自定义好的字符串移除即是原来的长链。

以上步骤，插入一条数据会经过两次sql查询（经过短链查记录，将短链对应关系插入到数据库中），如果在高并发下，显然会成为瓶颈。
一般数据库和服务应用（只做计算不做存储）会部署在两台不同的server上，执行两条sql语句，就需要两次网络通信，这两次网络通信和两次sql执行 将是整个短链系统的性能瓶颈所在。
5. 优化性能
* 首先需要给短链字段surl加上唯一索引
* 当长链经过MurmurHash得到短链后，直接将长短链对应的关系存入到db中，如果db里不包含有此短链的记录，则插入，如果包含了，说明违反了唯一性检索，此时只要给长链在加上我们自定义字段[DUPLICATE]，重新hash在插入即可，看起来在违反唯一性索引的情况下是多执行了步骤，但MurmurHash发生冲突的概率是非常低的。当然在数据量很大的情况下，冲突的概率会加大，此时我们可以使用布隆过滤器进行优化。

用所有生成的短网址构建布隆过滤器，当一个新的长链生成短链之后，先将此短链在布隆过滤器中查找，如果不存在，说明db里不存在此网址，可以插入。

6. 布隆过滤器

## 使用自增序列算法
做一个ID自增生成器，比如1,2,3 这样的整数递增ID，当收到一个长链转短链的请求时，ID生成器为其分配一个ID，再将其转化成62进制，拼接到短域名后面就得到了最终的短网址。
如何设计ID自增生成器。
1. 类uuid
用UUID（Universally Unique Identifier）全局唯一标识符，是指在一台机器上生成的数字，它保证对同一时空中的所有机器都是唯一的，但这种方式生成的id比较长，且无序，在插入db时可能会频繁导致页分裂，影响性能。

2. Redis
3. Snowflake
4. Mysql 自增主键
设计一个专门的发号表，每插入一条记录，为短链id预留从主键id* 1000 - 999 到主键id * 1000 的号段

当长链转短链时，先看这个机器的是否分配了短链的号段，没有分配就往发号表中插入一条记录，则这台机器将为短链分配范围在start 到end 之间的id，从start一直开始分配，一直到end，如果发号达到了end，说明这个范围内的id 已经分配完了，则再往发号表插入一条记录就又获取了一个发号id区间。