<!--
 * @Author: your name
 * @Date: 2020-10-12 09:07:34
 * @LastEditTime: 2020-10-15 17:14:02
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \cokelovejoy.github.io\source\_posts\设计模式.md
-->
# 开篇
程序员应该提升的能力。
1. 能用健壮的代码去解决具体的问题。
2. 能用抽象的思维去应对复杂的系统。
3. 能用工程化的思想去规划更大规模的业务。

# 设计模式
设计模式就是软件设计过程中一系列问题经典的解决办法的总结，形象的说法就是数学的解题模板。

# 设计原则
SOLID设计原则是设计模式的指导理论，它可以帮助我们规避不良的软件设计。SOLID分别指: 
1. 单一功能原则
2. 开放封闭原则
3. 里氏替换原则
4. 接口隔离原则
5. 依赖反转原则

# 设计模式的核心思想-封装变化
需求变化，业务功能变化都是导致软件设计复杂的原因，设计模式的出现就是为了解决变化，将变与不变分离，保证变化的部分灵活，不变的部分稳定。这个过程就叫封装变化，这样写出来的代码才是健壮的代码。
# 经典的23种设计模式
经典的23种设计模式按照"创建型"，"行为型"， "结构型"划分。
无论是创建型，行为型，结构性都是用自己的方式去封装不同类型的变化。
创建型模式封装了创建对象过程中的变化。
结构性模式封装的是对象之间组合方式的变化，目的是在于灵活的表达对象间的配合与依赖关系。
行为型模式是将对象的行为进行抽离，确保更安全，更方便地对行为进行更改。

封装变化，封装的是软件中的不稳定的因素，提前抽离变化，方便后续扩展。
## 创建型
1. 单例模式
2. 原型模式
3. 构造器模式
4. 工厂模式
5. 抽象工厂模式

## 结构型
1. 桥接模式
2. 外观模式
3. 组合模式
4. 装饰器模式
5. 适配器模式
6. 代理模式
7. 享元模式

## 行为型
1. 迭代器模式
2. 解释器模式
3. 观察者模式
4. 中介者模式
5. 访问者模式
6. 状态模式
7. 备忘录模式
8. 策略模式
9. 模板方法模式
10. 职责链模式
11. 命令模式

# JavaScript中的设计模式的原理与应用
## 构造函数
在 JavaScript 中，使用构造函数去初始化对象，就是应用了构造器模式。本质上是去抽象了每个对象实例的变与不变。构造器模式解决多个实例的问题。

如下 User 就是一个构造器，由 User 构造器初始化新创建的对象的过程就是构造器模式。
```js
function User(name, age) {
    this.name = name;
    this.age =age;
}

let user1 = new User('coke', 18);
```
## 工厂模式
工厂模式就是将创建对象的过程单独封装。在写了大量构造函数、调用了大量的 new时，就需要使用工厂模式来简化代码。
工厂模式解决多个类的问题。工厂模式的目的，就是为了实现无脑传参。
```js
function User(name, age, career, work) {
    this.name = name;
    this.age = age;
    this.career = career;
    this.work = work;
}
function Factory(name, age, career) {
    let work
    switch(career) {
        case 'coder':
            work = ['写代码'， '修bug'];
            break;
        case 'test':
            work = ['找开发'];
            break;
        case 'product manager':
            work = ['写文档'];
            break;
        case 'boss':
            work = ['喝喝茶'];
            break;
    }
    return new User(name, age, career, work);
}
```
## 抽象工厂模式
抽象工厂模式针对多个工厂时，要遵循开放封闭原则，即可以扩展，不可以修改。
抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂。其中有四个关键的角色:抽象工厂(抽象类，不能用于生成具体实例)，具体工厂(用于还说呢工程产品族里的一个具体的产品)，抽象产品(抽象类，不能用于生成具体实例)，具体产品(用于生成产品族里的一个具体的产品所依赖的更细粒度的的产品)。
```js
// 抽象工厂不干活
class MobilePhoneFactory {
    // 提供操作系统的接口
    ceateOs() {
        throw new Error("抽象工厂方法不允许直接调用， 需要将我重写！");
    }
    // 提供硬件的接口
    createHardWare() {
        throw new Error("抽象工厂方法不允许直接调用， 许哟啊将我重写！");
    }
}
// 具体工厂干活
class FakeStarFactory extends MobilePhoneFactory {
    createOS() {
        // 提供安卓系统实例
        return new AndroidOS();
    }
    createHardWare() {
        // 提供高通硬件实例
        return new QualcommHardWare();
    }
}

//  抽象产品类
class OS {
    controlHardWare() {
        throw new Error("抽象产品方法不允许直接调用，需要重写！");
    }
}
// 具体产品类
class AndroidOS extends OS {
    controlHardWare() {
        console.log("使用安卓的方式操作硬件");
    }
}
class AppleOS extend OS {
    controlHardWare() {
        console.log("使用苹果的方式操作硬件");
    }
}
// 手机
const myPhone = new FakeStarFactory();
// 操作系统
const myOS = myPhone.createOS();
```

## 单例模式
单例模式的特点，必须保证一个类只有一个实例，并提供一个可访问它的接口，这样的模式就是单例模式。
### 单例模式实现原理
单例模式实现的关键是一个类只有一个实例。不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。因此就需要构造函数能自己判断是否已经创建一个实例了。
```js
class SingleDog {
    show() {
        console.log("我是一个单例对象")
    }
    static getInstance() {
        // 判断是否已经new过1个实例
        if (!SingleDog.instance) {
            // 如果这个唯一的实例不存在，那么先创建它
            SingleDog.instance = new SingleDog();
        }
        // 唯一的实例已经存在
        return SingleDog.instance
    }
}
const s1 = SingleDog.getInstance();
const s2 = SingleDog.getInstance();
console.log(s1 === s2);
// 闭包实现，利用闭包保存了私有变量的特性
// instance 作为私有变量一直存在内存中，用于记录唯一的实例。
SingleDog.getInstance = (function() {
    // 定义自由变量instance，模拟私有变量。
    let instance = null;
    return function() {
        // instance是否为null;
        if (!instance) {
            // 为空，新创建一个实例
            instance = new SingleDog();
        }
        // 不为空，直接返回
        return instance;
    }
})();
const s1 = SingleDog.getInstance();
const s2 = SingleDog.getInstance();
console.log(s1 === s2);
```
### 单例模式的应用实践-Vuex
Vuex中所有的状态信息都保存在了一个唯一的数据源store对象中。
Vuex以插件的形式注入Vue中,Vuex内部实现了判断实例唯一性的install方法，如果不判断唯一性，每次注入Vuex，都会生成新的实例，也就无法实现记录状态信息的功能。
```js
// 安装vuex插件
Vue.use(Vuex)
// 将store注入到Vue实例中
new Vue({
    el: '#app',
    store
})

// Vuex 内部实现install方法，install方法在引入Vuex时会被执行
let Vue // 这个Vue的作用和楼上的instance作用一样
export function install (_Vue) {
  // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 若没有，则为这个Vue实例对象install一个唯一的Vuex
  Vue = _Vue
  // 将Vuex的初始化逻辑写进Vue的钩子函数里
  applyMixin(Vue)
}
```
### 使用单例模式实现一个Storage
实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。
### 使用单例模式实现一个状态弹框
## 原型模式