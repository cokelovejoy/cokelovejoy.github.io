<!--
 * @Author: your name
 * @Date: 2020-10-12 09:07:34
 * @LastEditTime: 2020-10-12 13:56:23
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \cokelovejoy.github.io\source\_posts\设计模式.md
-->
# 开篇
程序员应该提升的能力。
1. 能用健壮的代码去解决具体的问题。
2. 能用抽象的思维去应对复杂的系统。
3. 能用工程化的思想去规划更大规模的业务。

# 设计模式
设计模式就是软件设计过程中一系列问题经典的解决办法的总结，形象的说法就是数学的解题模板。

# 设计原则
SOLID设计原则是设计模式的指导理论，它可以帮助我们规避不良的软件设计。SOLID分别指: 
1. 单一功能原则
2. 开放封闭原则
3. 里氏替换原则
4. 接口隔离原则
5. 依赖反转原则

# 设计模式的核心思想-封装变化
需求变化，业务功能变化都是导致软件设计复杂的原因，设计模式的出现就是为了解决变化，将变与不变分离，保证变化的部分灵活，不变的部分稳定。这个过程就叫封装变化，这样写出来的代码才是健壮的代码。
# 经典的23种设计模式
经典的23种设计模式按照"创建型"，"行为型"， "结构型"划分。
无论是创建型，行为型，结构性都是用自己的方式去封装不同类型的变化。
创建型模式封装了创建对象过程中的变化。
结构性模式封装的是对象之间组合方式的变化，目的是在于灵活的表达对象间的配合与依赖关系。
行为型模式是将对象的行为进行抽离，确保更安全，更方便地对行为进行更改。

封装变化，封装的是软件中的不稳定的因素，提前抽离变化，方便后续扩展。
## 创建型
1. 单例模式
2. 原型模式
3. 构造器模式
4. 工厂模式
5. 抽象工厂模式

## 结构型
1. 桥接模式
2. 外观模式
3. 组合模式
4. 装饰器模式
5. 适配器模式
6. 代理模式
7. 享元模式

## 行为型
1. 迭代器模式
2. 解释器模式
3. 观察者模式
4. 中介者模式
5. 访问者模式
6. 状态模式
7. 备忘录模式
8. 策略模式
9. 模板方法模式
10. 职责链模式
11. 命令模式

# JavaScript中的设计模式的原理与应用
## 构造函数
在 JavaScript 中，使用构造函数去初始化对象，就是应用了构造器模式。本质上是去抽象了每个对象实例的变与不变。构造器模式解决多个实例的问题。

如下 User 就是一个构造器，由 User 构造器初始化新创建的对象的过程就是构造器模式。
```js
function User(name, age) {
    this.name = name;
    this.age =age;
}

let user1 = new User('coke', 18);
```
## 工厂模式
工厂模式就是将创建对象的过程单独封装。在写了大量构造函数、调用了大量的 new时，就需要使用工厂模式来简化代码。
工厂模式解决多个类的问题。工厂模式的目的，就是为了实现无脑传参。
```js
function User(name, age, career, work) {
    this.name = name;
    this.age = age;
    this.career = career;
    this.work = work;
}
function Factory(name, age, career) {
    let work
    switch(career) {
        case 'coder':
            work = ['写代码'， '修bug'];
            break;
        case 'test':
            work = ['找开发'];
            break;
        case 'product manager':
            work = ['写文档'];
            break;
        case 'boss':
            work = ['喝喝茶'];
            break;
    }
    return new User(name, age, career, work);
}
```
## 抽象工厂模式
抽象工厂模式针对多个工厂时，要遵循开放封闭原则，即可以扩展，不可以修改。
抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂。其中有四个关键的角色:抽象工厂(抽象类，不能用于生成具体实例)，具体工厂(用于还说呢工程产品族里的一个具体的产品)，抽象产品(抽象类，不能用于生成具体实例)，具体产品(用于生成产品族里的一个具体的产品所依赖的更细粒度的的产品)。
```js
// 抽象工厂不干活
class MobilePhoneFactory {
    // 提供操作系统的接口
    ceateOs() {
        throw new Error("抽象工厂方法不允许直接调用， 需要将我重写！");
    }
    // 提供硬件的接口
    createHardWare() {
        throw new Error("抽象工厂方法不允许直接调用， 许哟啊将我重写！");
    }
}
// 具体工厂干活
class FakeStarFactory extends MobilePhoneFactory {
    createOS() {
        // 提供安卓系统实例
        return new AndroidOS();
    }
    createHardWare() {
        // 提供高通硬件实例
        return new QualcommHardWare();
    }
}

//  抽象产品类
class OS {
    controlHardWare() {
        throw new Error("抽象产品方法不允许直接调用，需要重写！");
    }
}
// 具体产品类
class AndroidOS extends OS {
    controlHardWare() {
        console.log("使用安卓的方式操作硬件");
    }
}
class AppleOS extend OS {
    controlHardWare() {
        console.log("使用苹果的方式操作硬件");
    }
}
// 手机
const myPhone = new FakeStarFactory();
// 操作系统
const myOS = myPhone.createOS();
```

## 单例模式