---
title: 网络编程
date: 2020-01-06 14:25:47
tags:
---
# OSI模型(网络七层模型)
OSI(Open System Interconnection)模型,意为开放式系统互联.简单来说就是为了使计算机之间的通信标准化,然后划分出了网络七层模型,为了更好的理解网络通信如何工作.

基本划分:
七层划分: 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层
五层划分: 物理层,数据链路层,网络层,传输层,应用层
四层划分: 网络接口层,网路层,传输层,应用层

在四层划分中,应用层包括了 应用层,表示层,会话层; 网络接口层包括了物理层,数据链路层
## 物理层
物理层主要是指硬件,包括网线,光纤,网卡,路由器,网络通信设备等硬件设备用来将计算机连接起来的物理手段.它规定了网络的一些电气特性,作用是负责传送0和1的电信号.

## 数据链路层 (以太网协议)
电信号中单纯的0和1是没有意义的,必须规定解读方式:多少个电信号为一组?每个电信号的有何意义?这就是数据链路层的功能,它在实体层的上方,确定了0和1 的分组方式.

数据链路层对电信号做分组,形成了以太网协议Ethernet.
数据链路层的工作方式--广播.

仅通过广播的方式,在数据链路层就可以完成同一局域网内通信,MAC地址之间通过广播的方式.但在不同的局域网之间实现跨网络通信,就需要在网络层了.

## 网络层 (IP协议)
网络层定义了IP协议.通过IP地址,可以知道你所在的局域网,通过MAC地址可以知道你在局域网内的地址.

在计算机通信时,会判断你所在的局域网,对方所在的局域网,如果在同一个局域网内,基于MAC地址广播发包就可以.

如果不在同一个局域网,即跨网络发包,就会先把你的包交给网关来转发.IP地址和MAC地址唯一标识了你在互联网中的位置.

数据链路层中会把网络层的数据包封装到数据链路层的数据位置，然后再添加上自己的包头，再发给物理层，物理层发给网关，网关再发给对方局域网的网关，对方局域网的网关收到后在那个局域网内做广播。

## 传输层 (TCP协议和UDP协议)
有了MAC地址和IP地址,我们还需要port端口号,表示这个数据包到底供哪个程序(进程)使用.

网络层的ip地址帮我们区分局域网,数据链路层的mac地址帮我们找到主机,传输层通过port端口标识主机上的应用程序.(端口即应用程序与网卡关联的编号).

传输层功能: 建立端口到端口的通信

端口范围: 0-65535,0-1023为系统占用端口.

传输层的两个重要协议:TCP协议和UDP协议
* TCP协议
面向连接的,占用资源多,速度相对较慢,提供可靠的数据传输服务

* UDP协议
无连接,占用资源较小,速度非常快不可靠的数据传输,这在一些对数据可靠性较低的场景中是非常有用的，比如音视频服务，物联网数据上报服务等.
## 会话层
负责建立和断开通信连接,以及数据的分割等数据传输相关的管理.(何时建立连接?何时断开连接?以及保持多久的连接)
## 表示层
设备固有的数据格式与网络标准数据格式之间的转换(接受不同的信息,如文字流,图像,声音)
## 应用层 (HTTP,SSH,FTP)
针对特定应用的协议,电子邮件协议E-mail,远程登陆协议SSH,文件传输协议FTP,网络请求协议HTTP.

# TCP协议-实现即时通讯IM
## Socket实现
原理: Net模块提供一个异步API能够创建基于流的TCP服务器,客户端与服务器建立连接后,服务器可以获得一个全双工Socket对象,服务器可以保存Socket对象列表,在接受某客户端消息时,推送给其他客户端.
```js
const net = require('net')
const chatServer = net.createServer()
const clientList = []
chatServer.on('connection', client => {
    client.write('Hi\n')
    clientList.push(client)
    client.on('data', data => {
        console.log('receive: ', data.toString())
        clientList.forEach(v => {
            v.write(data)
        })
    })
})
chatServer.listen(9000)
```
通过telnet连接服务器,命令行输出如下命令
```
telnet localhost 9000
```
## Http实现
原理:客户端通过ajax方式发送数据给http服务器,服务器缓存消息,其他客户端通过轮询的方式查询最新的数据并更新列表.
* 创建index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>
    <div id="app">
        <input v-model="message">
        <button @click="send">发送</button>
        <button @click="clear">清空</button>
        <div v-for="item in list">{{ item }}</div>
    </div>

    <script>
        const host = 'http://localhost:3000'
        var app = new Vue({
            el: '#app',
            data: {
                list: [],
                message: 'hello world'
            },
            methods: {
                send: async function () {
                    let res = await axios.post(host + '/send', {message: this.message})
                    this.list = res.data
                },
                clear: async function () {
                    let res = await axios.post(host + '/clear')
                    this.list = res.data
                }
            },
            mounted() {
                setInterval(async () => {
                    const res = await axios.get(host + '/list')
                    this.list = res.data
                }, 1000)
            },
        })
    </script>
</body>
</html>
```
* 创建index.js
```js
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const path = require('path')

app.use(bodyParser.json())

const list = ['ccc', 'ddd']
app.get('/', (req, res) => {
    res.sendFile(path.resolve('./index.html'))
})
app.get('/list', (req, res) => {
    res.end(JSON.stringify(list))
})
app.post('/send',(req, res) => {
    list.push(req.body.message)
    res.end(JSON.stringify(list))
})
app.post('/clear', (req, res) => {
    list.length = 0
    res.end(JSON.stringify(list))
})
app.listen(3000)
```
## socket.io 实现
* 安装socket.io
```bash
npm install socket.io -S
```
socket.io模块: https://github.com/socketio/socket.io
客户端socket.io-client: https://github.com/socketio/socket.io-client
* 服务端 index.js
```js
var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res){
  res.sendFile(__dirname + '/index.html');
});

io.on('connection', function(socket){
  console.log('a user connected');
  
  //响应某用户发送消息
  socket.on('chat message', function(msg){
      console.log('chat message:' + msg);
      
    // 广播给所有人
    io.emit('chat message', msg);
    // 广播给除了发送者外所有人
    // socket.broadcast.emit('chat message', msg)
  });  

  socket.on('disconnect', function(){
    console.log('user disconnected');
  });
});

http.listen(3000, function(){
  console.log('listening on *:3000');
});
```
* 客户端 index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Socket.io chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js"></script>
    <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
    <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font: 13px Helvetica, Arial;
        }
        form {
          background: #000;
          padding: 3px;
          position: fixed;
          bottom: 0;
          width: 100%;
        }
        form input {
          border: 0;
          padding: 10px;
          width: 90%;
          margin-right: 0.5%;
        }
        form button {
          width: 9%;
          background: rgb(130, 224, 255);
          border: none;
          padding: 10px;
        }
        #messages {
          list-style-type: none;
          margin: 0;
          padding: 0;
        }
        #messages li {
          padding: 5px 10px;
        }
        #messages li:nth-child(odd) {
          background: #eee;
        }
      </style>
</head>
<body>
    <ul id="messages"></ul>
    <form action="">
        <input id="m" autocomplete="off">
        <button>Send</button>
    </form>
    <script>
        $(function () {
            var socket = io();
            $("form").submit(function (e) {
                e.preventDefault(); // 禁止表单提交的默认行为
                socket.emit("chat message", $("#m").val())
                $("#m").val("")
                return false
            })
            socket.on("chat message", function (msg) {
                $("#messages").append($("<li>").text(msg))
            })
        })
    </script>
</body>
</html>
```

# 跨域:浏览器同源策略引起的接口调用问题
跨域产生的原因:
1. 浏览器同源策略
2. 页面发送ajax请求

## 同源策略
浏览器规定两个资源之间进行交互,这两个资源必须处于相同的协议(http,https),相同的主机(host),相同的端口(port),这就称两个资源同源.

## 跨源网络访问
当一个页面使用了ajax请求另一不同源的网站数据,浏览器就会提示以下错误:
```
XMLHttpRequest cannot load http://你请求的域名. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://当前页的域名' is therefore not allowed access.
```
## 解决跨域问题
### JSONP(JSON with Padding),前端+后端方案,绕过跨域
JSONP(JSON with Padding) 是json的一种使用方式,目的是让网页从别的域名(网站)获取数据,即跨域获取数据.

原理: 因为script标签的src属性不受同源策略的影响,所以通过动态的创建script标签,将想要请求数据的服务器url写入src属性,并传递一个callback参数, 然后服务端返回数据时会将这个callback参数作为函数名来包裹数据,这样客户端就可以定制自己的函数来处理返回的数据.

缺点: script标签只能发送get请求.(与XMLHttpRequest对象实现的Ajax请求无关)
实现:
客户端:
```html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>JSONP 实例</title>
</head>
<body>
<div id="divCustomers"></div>
<script type="text/javascript">
function callbackFunction(result, methodName)
{
    var html = '<ul>';
    for(var i = 0; i < result.length; i++)
    {
        html += '<li>' + result[i] + '</li>';
    }
    html += '</ul>';
    document.getElementById('divCustomers').innerHTML = html;
}
</script>
<script type="text/javascript" src="https://www.xxxx.com/test/jsonp.php?jsoncallback=callbackFunction"></script>
</body>
</html>
```
服务器端:
```php
<?php
header('Content-type: application/json');
//获取回调函数名
$jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);
//json数据
$json_data = '["customername1","customername2"]';
//输出jsonp格式的数据, 这个函数最后会在客户端调用,将json数据传入函数,做定制化处理
echo $jsoncallback . "(" . $json_data . ")";
?>
```
### 代理服务器
请求同源服务器,通过该服务器转发请求至目标服务器,得到结果再转发给前端.

使用proxy middleware: http-proxy-middleware
```bash
npm i http-proxy-middleware
```
```js
let express = require('express')
// http-proxy-middleware 用于将请求转发给其它服务器。
let proxy = require('http-proxy-middleware')
const app = express()
app.use(express.static(__dirname + '/'))
app.use('/api', proxy({ target: 'http://localhost:4000', changeOrigin: false}))
 module.exports = app
```

前端开发中测试服务器的代理功能就是采用的该解决方案,但是最终发布上线时如果web应用和接口服务器不在一起仍然会跨域.
对比nginx与webpack devserver
* webpack devServer
```js
// vue.config.js
modele.exports = {
    devServer: {
        disableHostCheck: true,
        compress: true,
        port: 5000,
        proxy: {
            '/api/': {
                target: 'http://localhost:4000',
                changeOrigin: true
            }
        }
    }
}
```
* nginx
```js
server {
    listen 80;
    # server_name www.xxx.com;
    location / {
        root /var/www/html;
        index index.html index.htm;
        try_files $uri $uri/ /index.html;
    }
    location /api {
        proxy_pass http://127.0.0.1:3000;
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```


### CORS(Cross Origin Resource Share) 跨域资源共享,后端方案,解决跨域
浏览器的同源策略出于安全考虑,浏览器会限制从脚本发起的跨域HTTP请求,像XMLHttpRequest和Fetch都遵循同源策略.

浏览器限制发起跨域请求的两种方式:
1. 浏览器限制发起跨域请求
2. 跨域请求可以正常发起,但是返回的结果被浏览器拦截了

一般浏览器都是第二种方式限制跨域请求,那就是说请求已到达服务器,并有可能对数据库里的数据进行了操作,但是返回的结果被浏览器拦截了,那么我们就获取不到返回结果,这是一次失败的请求,但是可能对数据库里的数据产生了影响。

为了防止这种情况的发生,规范要求,对这种可能对服务器数据产生副作用的HTTP请求方法,浏览器必须先使用OPTIONS方法发起一个预检请求,从而获知服务器是否允许该跨域请求.如果允许,就发送带数据的真实请求;如果不允许,则阻止发送带数据的真实请求.

cors是W3C规范,真正意义上解决跨域问题.它需要服务器对请求进行检查并对响应头做相应处理,从
而允许跨域请求.

#### 预检请求(preflight request): 浏览器发出的接口请求会发两次
一个 CORS 预检请求是用于检查服务器是否支持 CORS 即跨域资源共享.
1. 简单请求
* 请求方式为:GET, POST, HEAD(HEAD请求和GET本质一样,但是HEAD请求不含数据,只有HTTP头部信息)之一.
* HTTP请求Header信息没有自定义的头部字段,Content-Type (只有三个值application/x-www-form-urlencoded, multipart/form-data, text/plain).

符合以上两个条件就可以认为是一个简单请求.
2. 非简单请求
* 请求方式为: PUT, DELETE
* 自定义头部字段
* 发送json格式数据
* 正式通信之前,浏览器会先发送OPTION请求,进行预检,这一次的请求称为"预检请求",状态响应码204 No Content
```
//Request Headers 包含以下字段
Access-Control-Request-Headers: authorization
Access-Control-Request-Method: GET
Origin: http://www.test.com
```
* 服务器成功响应预检请求之后才会发送真正的请求,并返回真实数据.

#### CORS 具体设置
* 响应简单请求: method为GET / POST / HEAD, 没有自定义请求头, Content-Type是application/x-www-form-urlencoded, multipart/form-data, text/plain之一,通过在服务器端添加以下响应头解决.
```js
// 通配符* 代表任何
res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000')
res.setHeader('Access-Control-Allow-Origin', '*')
```
* 响应非简单请求,需要响应浏览器发出的OPTIONS请求(预检请求),并根据情况设置响应头,则服务器需要允许X-Token
若请求为post,还传递了参数,服务器还需要允许content-type请求头
```js
if (method == "OPTIONS" && url == "/api/users") {
    res.writeHead(200, {
        "Access-Control-Allow-Origin": "http://localhost:3000",
        "Access-Control-Allow-Headers": "X-Token,Content-Type",
        "Access-Control-Allow-Methods": "PUT"
    })
    res.end()
}
```
* 如果要携带cookie信息,则请求变为credential请求
```js
// 预检请求和/api/users接口中均需要添加
res.setHeader('Access-Control-Allow-Credentials', 'true')
// 设置cookie
res.setHeader('Set-Cookie', 'cookie1=va222;')
// 跨域访问需要发送cookie时一定要加axios.defaults.withCredentials = true
axios.defaults.withCredentials = true
```

## Body-parser
Body-parser中间件的作用是给req添加属性body,属性值为对象,以键值对的形式存储请求体中的参数.
Body-parser只处理POST请求.

### Body-parser 的四个处理方法
```js
bodyParser.json(options)        // 处理json数据
bodyParse.raw(options)          // 处理Buffer流数据
bodyParse.text(options)         // 处理文本数据
bodyParse.urlencoded(options)   // 处理UTF-8编码的数据
```
### Body-parser 的使用
* 安装
```bash
npm install express body-parser
```
* 使用
```js
let express = require('express')
let bodyParser = require('body-parser')

const app = express()

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

app.use(function(req, res) {
    res.setHeader('Content-Type', 'text/plain')
    res.write('hello')
    res.end(JSON.stringify(req.body, null, 2))
})
```
express 的use方法调用body-parser实例,在use方法中没有设置路由路径时,body-parse实例会对该app所有的请求进行拦截和解析.

* 设置Content-Type 属性:用于修改和设定中间件解析的body内容类型。
Content-Type内容类型,用于定义网络文件的类型和网页的编码,决定浏览器将以什么形似,什么编码读取这个文件
```js
// parse various different custom JSON types as JSON
app.use(bodyParser.json({ type: 'application/*+json'}))

// parse some custom thing to a Buffer
app.use(bodyParser.raw({ type: 'application/vnd.custom-type'}))

// parse an html body into string
app.use(bodyParser.text({ type: 'text/html' }))
```
* 发送请求body的类型:application/x-www-form-urlencoded 
```html
<form action="/api/save" method="post">
 <input type="text" name="abc" value="123">
 <input type="submit" value="save">
</form>
```
```js
// api.js
else if (method === "POST" && url === "/api/save") {
 let reqData = [];
 let size = 0;
 req.on('data', data => {
   console.log('>>>req on', data);
   reqData.push(data);
   size += data.length;
 });
 req.on('end', function () {
   console.log('end')
   const data = Buffer.concat(reqData, size);
   console.log('data:', size, data.toString())
   res.end(`formdata:${data.toString()}`)
 });
}
```
```js
// 模拟application/x-www-form-urlencoded
await axios.post("/api/save", 'a=1&b=3', {headers: {'Content-Type': 'application/x-www-form-urlencoded'}})
```
* 发送请求的body的类型: application/json
```js
await axios.post("/api/save", {a:1, b:2})
```

# 文件上传
## 创建index.html
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>file upload</title>
</head>

<body>
    <input id='file1' type="file" />
</body>
<script>
    window.onload = function () {
        var files = document.getElementsByTagName('input')
        console.log('files', files)
        var length = files.length
        var file
        for (var i = 0; i < length; i++) {
            file = files[i]
            // 判断文件类型, type不是file的input元素跳过
            if (file.type !== 'file') continue
            // 触发input的onchange事件时,执行如下回调函数 
            file.onchange = function () {
                // this.files 是选择文件之后的文件集合 fileList
                var _files = this.files
                // 没有选择文件退出
                if (!_files.length) return
                // 选择单个文件
                if (_files.length === 1) {
                    var xhr = new XMLHttpRequest()
                    // 前端发送POST请求 到接口 http://localhost:3000/upload 下
                    xhr.open('POST', 'http://localhost:3000/upload')
                    // 获取文件的路径
                    // 在触发onchange事件,已经选定文件后,files这个DOM元素集中的这个DOM元素的value就有值了
                    var filePath = files[0].value
                    // 设置请求头 "file-nmae": "xxxx.yy"
                    xhr.setRequestHeader('file-name', filePath.substring(filePath.lastIndexOf('\\') + 1))
                    // 发送文件
                    xhr.send(_files[0])
                }
            }
        }
    }
</script>
</html>
```
## 创建index.js
```js
const http = require('http')
const fs = require('fs')
const path = require('path')
// 创建http server
const server = http.createServer((request, response) => {
    const { pathname } = require('url').parse(request.url)
    if (pathname === '/upload') {
        console.log('upload...')
        // 获取文件名 来自request headers
        const fileName = request.headers['file-name'] ? request.headers['file-name'] : 'abc.png'
        // 设置文件保存在服务器的某路径下
        const outputFile = path.resolve(__dirname, fileName)
        // 创建一个可写的文件流
        const writeFileStream = fs.createWriteStream(outputFile)
        // 管道拼接
        request.pipe(writeFileStream)
        response.end()
    } else {
        const filename = pathname === '/' ? 'index.html' : pathname.substring(1)
        var type = (function (_type) {
            switch (_type) {
                case 'html':
                case 'htm': return 'text/html charset=UTF-8'
                case 'js': return 'application/javascript charset=UTF-8'
                case 'css': return 'text/css charset=UTF-8'
                case 'txt': return 'text/plain charset=UTF-8'
                case 'manifest': return 'text/cache-manifest charset=UTF-8'
                default: return 'application/octet-stream'
            }
        })(filename.substring(filename.lastIndexOf('.') + 1))
        // 异步读取文件,并将内容作为单独的数据块传回给回调函数
        // 对于确实很大的文件,使用API fs.createReadStream()更好
        fs.readFile(filename, function (err, content) {
            if (err) {
                // 报错 无法读取文件时
                response.writeHead(404, { 'Content-type': 'text/plain charset=UTF-8' })
                response.write(err, message)
            } else {
                // 读取文件成功, 把文件内容作为响应主体
                response.writeHead(200, { 'Content-type': type })
                response.write(content)
            }
            response.end()
        })
    }
})
server.listen(3000)
```
## Buffer connect
```js
let size = 0
let chunk = []
// 监听data事件,执行回调函数
request.on('data', data => {
    // data是数据块
    chunk.push(data)
    size += data.length
    console.log('data:', data, size)
})
// 监听end事件,执行回调函数
request.on('end', () => {
    console.log('end...')
    const buffer = Buffer.concat(chunk, size)
    size = 0
    // 同步写入文件
    fs.writeFileSync(outputfile, buffer)
    response.end()
})
```
## 流事件写入
```js
request.on('data', data => {
    console.log('data:', data)
    writeFileStream.write(data)
})

request.on('end', () => {
    writeFileStream.end()
    response.end()
})
```

# 实现简单爬虫
原理:模拟浏览器发送请求到目标服务器获取页面的内容并解析,获取其中的数据

```bash
# request库 发送请求
npm install request -S

# cheerio库 操作dom
npm install cheerio -S

# iconv-lite库 用于字符编码转换
npm install iconv-lite -S
```
```js
const originRequest = require("request")
const cheerio = require("cheerio")
const iconv = require("iconv-lite")

function request(url, callback) {
    const options = {
        url: url,
        encoding: null
    }
    originRequest(url, options, callback)
}
for (let i = 100553; i < 100563; i++) {
    const url = `https://www.dy2018.com/i/${i}.html`
    request(url, function (err, res, body) {
        const html = iconv.decode(body, "gb2312")
        const $ = cheerio.load(html)
        console.log($(".title_all h1").text())
    })
}
```

# Https
创建证书
```bash
# 创建私钥
openssl genrsa -out privatekey.pem 1024
# 创建证书签名请求
openssl req -new -key privatekey.pem -out certrequest.csr
# 获取证书,线上证书需要经过证书授证中心签名的文件;下面只创建一个学习使用证书
openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out
certificate.pem
# 创建pfx文件
openssl pkcs12 -export -in certificate.pem -inkey privatekey.pem -out
certificate.pfx
```
# Http2
多路复用- 雪碧图,多域名CDN,接口合并
* 多路复用允许同时通过单一的HTTP/2连接发起多重的请求-响应消息;而HTTP/1.1协议中,浏览器客户端在同一时间,针对同一域名下的请求有一定数量限制.超过限制数目的请求会被阻塞.
* 首部压缩
http/1.x的header由于cookie和user agent很容易膨胀,而且每次都要重复发送.
http/2使用的encoder来减少需要传输的header大小,通讯双方各自cache一份 header fields表,既避免了重复header传输,又减小了需要传输的大小.高效的压缩算法可以很大的压缩header,减少发送包的数量从而降低延迟
* 服务端推送
在HTTP/2中,服务器可以对客户端的一个请求发送多个响应.举个例子,如果一个请
求请求的是index.html,服务器很可能会同时响应index.html、logo.jpg 以及 css 和 js文件.因为它知道客户端会用到这些东西.相当于在一个HTML文档内集合了所有的资源.