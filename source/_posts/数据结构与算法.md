---
title: 数据结构与算法
date: 2020-06-08 20:09:26
tags:
---
# 什么是数据结构
数据结构是数据之间存在的一种或多种关系的数据元素的集合。
数据结构这门学科是研究程序设计问题中的操作对象，以及它们之间的关系和操作等的学科。
# 基本概念
## 数据，数据对象，数据元素，数据项
数据：是描述客观事物的符号是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如：声音，图像，视频等。
数据对象：是性质相同的数据元素的集合，是数据的子集。
数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。
数据项：一个数据元素可以由若干个数据项组成。数据项是不可分割的最小单位。
## 逻辑结构
逻辑结构是指数据对象中数据元素之间的相互关系。
1. 集合结构
2. 线性结构
3. 树形结构
4. 图形结构
## 物理结构
物理结构也叫存储结构，，指数据的逻辑结构在计算机中的存储形式。数据的存储结构应正确反映数据元素之间的逻辑关系。
数据元素的存储结构形式有两种：顺序存储和链式存储。
### 顺序存储结构
把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系一致。比如数组。
### 链式存储结构
把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系不能反应其逻辑关系，需要一个指针存放数据元素的地址，通过地址找到相关联的数据元素的位置。
## 抽象数据类型(ADT)
抽象数据类型(Abstract Data Type)：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型定义了一个数据对象，数据对象中各数据元素之间的关系及对数据元素的操作。
抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。

# 栈结构
特点：后入先出，所有操作都是针对栈顶元素进行。
实现：用数组实现栈
应用：撤回操作。
# 队列结构
特点：先进先出，只允许在队列的头部删除元素，在队列的尾部添加元素。
实现：用数组实现队列
应用：消息队列，socket服务器将请求放入队列，先来的先处理，后来的后处理，队列满时，新来的请求直接抛弃。
# 链表结构
链表是物理存储单元上非连续的，非顺序的存储结构，由一系列节点组成，一个节点连接到下一个节点。
## 单链表
### 节点
节点包含两部分，一部分是存储数据元素的数据域，一部分是存储指向下一个节点的指针域，它们一起共同构成一个节点。
### 首尾节点
链表中的第一个节点是首节点，最后一个节点是尾节点。
### 有头链表和无头链表
无头链表是指第一个节点既有数据域，又有指针域，第一个节点既是首节点又是头节点。
有头链表是指第一个节点只有指针域，而没有数据域。
# BitMap
用bit位来表示数字是否存在，0表示不存在，1表示存在。
BitMap在处理大数据时，才具有优势。
应用：大数据排序，使用BitMap排序必须要数据量很大，而且集合中不能有重复数据，只能处理整数。
# 布隆过滤器
布隆过滤器是一种数据结构，比较巧妙的概率型数据结构，特点是高效地插入和查询。
原理： 处理字符串，把字符串变成多个整数。
可以把布隆过滤器看作是BitMap的扩展，布隆过滤器要求使用k个hash函数，把字符串散列成k个整数，这k个整数的数值就作为二进制数组的下标，然后将数组对应下标的值设置为1。判断某个字符串是否存在时，还是使用k个hash函数对key进行散列，得到k个整数，如果这k个整数所对应的二进制位都是1,就说明这个字符串存在。否则，这个字符串不存在。

对于布隆过滤器，有两个参数需要设置，一个是预估的最多存放的数据的数量，一个是可以接受的冲突率。
## hash函数
哈希函数将不定长的对象映射成一个定长的对象。
murmurhash函数。
# 树结构
## 概念
树是一种非线性的数据结构，由n个节点组成的有限集合。
* n = 0,是空树
* 根节点是唯一的，根节点没有父节点
* 叶节点，没有子节点
* 子树，除根节点的其他元素组成的互不相交的集合
## 结点
结点包含一个数据元素和一些指向子树的分支。
### 结点的度
结点拥有的子树的个数(分支数目)称为结点的度。
### 结点分类
#### 根结点
一个非空树，有且只有一个根结点。
#### 分支结点
度不为0的结点称为分支结点(除根结点外，分结节点也称为内部结点)。
#### 叶结点
度为0的结点称为叶结点(即拥有的子树的个数为0)。
### 结点关系
* 双亲结点。
* 孩子结点：结点的子树的根称为该结点的孩子。
* 兄弟结点：同一个双亲结点的孩子之间互称兄弟。
* 祖先结点：结点的祖先是从根到该结点所经分支上的所有结点。
* 子孙结点: 以某一结点为根的的子树中的任一结点都称为该结点的子孙。
### 层次
结点的层次从根结点开始定义起，根结点为第一层，根的孩子结点为第二层。
### 结点的深度
对于任意结点n,n的深度为从根到n的唯一路径长，根的深度为0
### 结点的高度
对于任意结点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0
## 树的度
树的度是树内各结点的度的最大值。
## 树的深度和高度
树中结点的最大层次称为树的深度或高度。
## 有序树
树中结点的各棵树是有次序的，位置不能交换。
## 无序树
树中结点的各棵子树之间的次序不重要，可以相互交换位置。
## 森林
森林是m(m>0)棵不相交的树的集合，增加一个根节点，让其他树成为根节点的子树，那么森林就变成了一颗树。
## 树的存储结构
存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适，是否方便，时间复杂度好不好。
### 双亲表示法
除了根结点外，每个结点不一定有孩子结点，但一定有双亲结点。因此用一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。
每个结点包含数据域和指针域，指针域存储该节点的双亲在数组的下标。还可以设置左子域保存左孩子结点的位置，或者是右兄弟域保存右兄弟的位置，没有都用-1表示。
### 孩子表示法
由于树的每个结点有多棵子树，可以用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，这种表示方法称为多重链表表示法。
* 方式一： 指针域的个数等于树的度。缺点：可能造成空间浪费。
* 方式二： 每个结点指针域的个数等于该结点的度，专门设置一个域来存储该结点的子结点的个数。克服了浪费空间的问题，但是每个结点的链表结构不同，加上要维护结点的度的数值，在运算上就增加了时间上的损耗。
为了减少空指针的浪费，又使结点结构相同，使用孩子表示法。

孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。
n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

结构：表头数组和孩子链表
两种结点结构：
1. 一个是孩子链表的孩子结点，有孩子结点的数据域保存孩子结点n在表头数组中的下标。有指针域存储指向下一个孩子结点的指针。
2. 一个是表头数组的表头结点，有数据域存储结点的数据信息，有头指针域，存储该结点的孩子链表的头指针。

孩子表示法的缺陷是无法知道某个结点的双亲。解决办法是结合双亲表示法，设置一个数据域存储双亲结点的下标。
### 孩子兄弟表示法
任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。
## 二叉树
二叉树是树的一种特殊情况，每个结点最多有两个孩子结点，分别称为该结点的左孩子结点和右孩子结点。在二叉树中，不存在度大于2的节点。二叉树的子树有左右之分，次序不能颠倒。
### 二叉树的性质
* 在二叉树的第i层，最多有2的i-1次方个结点。
* 深度为k的二叉树，最少有k个节点，最多有2的k次方-1个结点。
* 对于一棵非空二叉树，叶结点的数量等于度为2的节点数量加1。
* 二叉树的结点总数为叶子结点数和度为1的结点数和度为2的结点数之和。
* 树的分支总数为结点总数-1。
* 具有n个结点的完全二叉树的深度为log2为底n为真数的向下取整 + 1。
* 对一棵有n个结点的完全二叉树的结点按层序编号，从第一层到最后一层，每层从左到右依次编号。对任一结点i，如果i=1，则结点i为根节点，如果i>1，则其双亲结点为i/2向下取整。如果2i>n，则结点无左孩子，且i结点为叶子结点。如果2i < n，则i结点的左孩子结点为2i。如果2i+1 > n，则i结点无右孩子，如果2i+1 < n, 则i结点的右孩子结点为2i+1。
### 特殊的二叉树
#### 斜树
所有结点都是只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树。斜树的每一层都只有一个结点，因此斜树的结点的个数等于树的层数。
#### 满二叉树
深度为k的满二叉树，是有2的k次方-1个节点的二叉树，每一层都达到了可以容纳的最大数量的节点。
特点：
1. 叶子结点只能出现在最底下的那层。
2. 非叶子结点的度一定是2.
3. 同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。
#### 完全二叉树
深度为k的完全二叉树，从第1层到第k-1层都是满的，第k层的节点必须从左向右依次排列，第k层也可以是满的。
满二叉树一定是一棵完全二叉树，完全二叉树不一定是满二叉树。
特点：
1. 叶子结点只能出现在最底下两层。
2. 最底下的叶子结点一定集中在左部连续位置。
3. 倒数第二层，若有叶子结点，一定集中在右部连续位置。
4. 结点的度为1,则该结点只有左孩子，不存在只有右孩子的情况。
5. 同样结点数的二叉树，完全二叉树的深度最小。
### 二叉树的存储结构
#### 二叉树的顺序存储结构
顺序存储对于树这种一对多的关系结构实现比较困难。但是二叉树是一种特殊的树，因此也可以使用顺序存储实现二叉树。
二叉树的顺序存储结构就是用以为数组存储二叉树中的结点。并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。
对于一般二叉树，使用顺序存储结构，按照完全二叉树的方式，按层序去存放到数组，没有的结点可以设置为空，因此存在浪费存储空间的问题。顺序存储结构一般只用于完全二叉树。
#### 二叉树的链式存储结构
二叉树每个结点最多有两个孩子，因此设置一个数据域和两个指针域，一个左指针和一个右指针分别指向左孩子和右孩子。
如果有需要还可以增加一个指向其双亲的指针域，那样的称之为三叉链表。
### 二叉树的遍历
#### 前序遍历
先访问根节点，然后前序遍历左子树，再前序遍历右子树。前序遍历的第一个结点一定是根结点。
#### 中序遍历
先中序遍历左子树，然后访问根节点，再中序遍历右子树。
#### 后序遍历
先后序遍历左子树，然后后序遍历右子树，再访问根节点。
就是从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。后序遍历的最后一个结点一定是根结点。
#### 层序遍历
从根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。
#### 遍历的性质
* 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
* 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
* 树的遍历中，使用递归大大提高效率，简化代码。
### 线索二叉树
对二叉树遍历之后，得出序列之后，让结点的空指针域存放指向结点在某种遍历次序下的前驱和后继结点的地址。
这种指向前驱和后继的指针称为线索，加上线索的二叉树链表称为线索链表，相对的二叉树就称为线索二叉树。所以对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。
线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。

给每个结点增加两个标志域，ltag存放0表示指向该结点的左孩子，存放1表示指向该结点的前驱。rtag存放0表示指向该结点的右孩子，存放1表示指向该结点的后继。
在实际问题中，如果所用的二叉树需经常遍历或查找结点时，需要某种遍历序列中的前驱和后继，那么就采用线索二叉链表的存储结构。
### 树,森林和二叉树的转换
#### 树转换为二叉树
将树转换为二叉树的步骤：
1. 加线：在所有兄弟结点之间加一条连线。
2. 去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。
3. 层次调整：以根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。 
#### 森林转换为二叉树
森林由若干棵树组成，所以森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。
1. 把每个树转换为二叉树。
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后，就得到了由森林转换来的二叉树。
#### 二叉树转换为树
二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。
1. 加线：若某结点k的左孩子结点存在，则将这个左孩子结点的n个右孩子结点都作为此结点k的孩子结点。将该结点k与右孩子结点用线连接。
2. 去线：删除原二叉树中所有结点与右孩子结点的连线。
3. 层次调整：使结构层次分明。
#### 二叉树转换为森林
首先判断一个二叉树能否转换为森林还是一棵树，看这个二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。
二叉树转换成森林的步骤：
1. 从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再看分离后的二叉树，若右孩子存在，则连线删除，直到所有右孩子连线都删除为止，得到分离的二叉树。
2. 再将每个分离后的二叉树转换为树即可。
### 树和森林的遍历
#### 树的遍历
树的遍历分为两种方式。
1. 先根遍历树，即先访问树的根结点，然后依次先根遍历根的每个子树。
2. 后根遍历树，即先依次后根遍历每个子树，然后再访问根节点。
#### 森林的遍历
森林的遍历也分为两种方式。
1. 前序遍历。
2. 后序遍历。
森林的前序遍历和二叉树的前序遍历结果是一样的，森林的后序遍历和二叉树的中序遍历结果相同。也就是当二叉链表作为树的存储结构时，树和森林的先序遍历和后序遍历可以借用二叉树的前序遍历和中序遍历的算法来实现。先把树和森林转化成二叉树，在使用二叉树的前序遍历或中序遍历。
### 哈夫曼树
带权路径长度(WPL)最小的二叉树称作哈夫曼树。也称为最优二叉树。
#### 权
树结点之间边相关的数叫做权。
#### 树的路径长度
从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。
树的路径长度就是从树的根结点到每一个结点的路径长度之和。
#### 结点的带权路径长度
从某结点到根结点之间的路径长度与该结点上权的乘积。
#### 树的带权路径长度
树的带权路径长度为树中所有叶子结点的带权路径长度之和。
#### 构造哈夫曼树的算法描述
1. 根据给定的n个权值{W1,W2,W3,W4...,Wn}构成n棵二叉树的集合F={T1,T2,T3,T4...,Tn}，其中每个二叉树Ti中只有一个带权为Wi的根结点，其左右子树均为空。
2. 在F中选取两个根结点的权值最小的树作为左右子树构造一个新的二叉树，且让新的二叉树的根结点的权值为其左右子树上根结点权值之和。
3. 在F中删除上述的两个树，将新的二叉树加入到F中。
4. 重复上述2，3步骤直到F中只含有一个树为止，这个树就是哈夫曼树。
#### 哈夫曼编码
哈夫曼树对于高频率出现的数据，遍历效率非常的高。哈夫曼编码主要的目的是节省数据存储空间和传输成本，哈夫曼编码原理就是数据压缩的基本原理。

设需要编码的字符集为{d1,d2,d3,...,dn}，各个字符在电文中出现的次数或频率集合为{W1,W2,...Wn}，以d1,d2为叶子结点，以W1，W2作为相应的叶子结点的权值来构造一个哈夫曼树。规定哈夫曼的左分支代表0,右分支代表1,则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是哈夫曼编码。

编码中非0即1,长短不等的话非常容易混淆，要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码。
在发送和接受双方都必须要按约定好的相同的哈夫曼编码规则。

# 图
图是由顶点的集合和顶点之间的边的集合组成。通常表示为：G(V,E)，V是顶点的集合，E是边的集合。
图中的数据元素称之为顶点，顶点集合一定是有穷且非空的。在图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。
## 概念
### 无向边
顶点之间的边没有方向，则称这条边为无向边。
无向边用(A, D)表示，可以交换顶点。
### 无向图
图中任意两个顶点之间的边都是无向边，则称该图为无向图。
在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。
含有n个顶点的无向完全图有n*(n-1)/2条边。
### 有向边 
顶点之间有方向，则称这条边为有向边，也称为弧。
有向边用<A, D>表示，不可以交换顶点，它们出现的次序表示的边的方向。
### 有向图
图中任意两个顶点之间的边都是有向边，则称该图为有向图。
在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。
含有n个顶点的有向完全图有n*(n-1)条弧。
### 权
在图上的边或弧相关的数叫做权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。
### 网
带权的图通常称为网。
### 顶点的度
对于无向图，顶点的度是和顶点相关联的边的数目，记为TD(v)。边数其实就是各顶点度数和的一半。
对于有向图，进入顶点v的弧的数目称为v的入度，记为ID(v)。从顶点v出发的弧的数目称为v的出度，记为OD(v)。顶点的度为TD(v) = ID(v) + OD(v)
### 路径长度
从一个顶点到另一个顶点上的某一路径上边或弧的数目。
### 回路
第一个顶点到最后一个顶点相同的路径称为回路或者环。
序列中顶点不重复出现的路径称为简单路径。
除了第一个和最后一个顶点相同之外，其余顶点不重复出现的回路，称为简单回路或简单环。

### 连通图
对于无向图中任意两个顶点都是连通的，则称此图是连通图。
### 连通分量
无向图中的极大连通子图称为连通分量。
* 连通分量必须是子图
* 子图必须是连通的
* 连通子图含有极大顶点数
* 具有极大顶点数的连通子图包含依附于这些顶点的所有边

### 强连通图
在有向图中，每一对结点之间都存在路径。从v1到v2,也能从v2到v1。则称该图是强连通图。

### 强连通分量
有向图中的极大强连通子图称为有向图的强连通分量。

### 生成树
无向图中连通且n个顶点n-1条边叫做生成树。不过有n-1条边并不一定是生成树。

### 有向树
有向图中一顶点的入度为0,其余顶点入度为1的叫有向树。
### 生成森林
一个有向图由若干棵有向树构成生成森林。
## 图的存储结构
图的结构比较复杂，任意两个顶点之间都可能有关系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而使用多重链表，尽管可以实现图结构，但是会造成存储单元的浪费。
### 领接矩阵
将图的顶点和边分成两个结构来分别存储。使用一个一维数组来存顶点，一个二维数组(领接矩阵)来存边，用0表示两点之间没有边，1表示两点之间有边。

无向图的边数组是一个对称矩阵，通过这个矩阵能得到以下信息：
* 任意两顶点是否有边无边。
* 某个顶点vi的度，就是这个顶点所在i行或i列的元素数值之和。
* 某个顶点vi的所有领接点，就是将第i行的元素扫描一遍，arr[i][j]为1就是领接点。

有向图的边数组并不一定是一个对称矩阵，有向图的矩阵有如下特点：
* 顶点vi的入度的数目是矩阵中第i列各数之和，顶点vi的出度是第i行的各数之和。
* 判断顶点之间的边是否存在，只要查找矩阵中arc[i][j]是否为1。
* 求vi的所有邻接点，就是将矩阵第i行元素扫描一遍，找到arc[i][j]为1的点。

缺点：邻接矩阵对于边数相对顶点较少的图，这种结构是对存储空间的极大浪费。
### 有向网图的矩阵
带有权的有向图，称为有向网图，它的邻接矩阵用权值表示两个邻接点的边的存在，用0表示顶点自己指向自己，用无穷大表示两个顶点之间的边不存在。
### 邻接表
类似于树的孩子表示法，用数组存储每一个结点，对结点的孩子进行链式存储。这种数组和链表相结合的存储方式称为邻接表。
邻接表的处理方法：
1. 图中的所有顶点用一个一维数组存储，每个数据元素要设置一个指针域指向第一个邻接点的指针。
2. 使用单链表存储每个顶点的邻接点。无向图中称为这个顶点的边表，有向图中称为这个顶点的出边表。单链表中每个结点设置两个域，一个数据域保存邻接点在数组中的下标，另一个指针域保存顶点指向的下一个邻接点的指针。

获取图的信息：
1. 某个顶点的度 = 这个顶点的边表中结点的个数。
2. 判断两个顶点之间是否有边，只要看某一个顶点的边表中是否有结点存在另一个顶点在数组中的下标即可。
3. 求所有的顶点的邻接点，就是对此顶点的边表进行遍历，数据域上的值就是邻接点在数组中的下标，再通过下标去找到每一个邻接点。

对于有向图有出度和入度之分，因此可以分别根据出度和入度做邻接表。根据入度做的邻接表，叫逆邻接表。这样可以算出每个顶点的入度和出度，判断的两顶点是否存在弧。
对于带有权值的网图，只要在边表结点定义中设置一个weigth的数据域来存储权值即可。
### 十字链表
针对有向图，结合邻接表和逆邻接表。
表示方法：
1. 一维数组保存所有的顶点，每个数据元素有数据域data保存值，指针域firstin保存入边表的头指针，指向该顶点的入边表中的第一个结点，指针域firstout保存出边表的头指针，指向该顶点的出边表中的第一个顶点。
2. 边表结构有数据域startIndx表示弧的起始顶点在数组中的下标，数据域endIndex表示弧的终止顶点在数组中的下标，指针域endPoint表示入边表的指针，指向终点相同的下一条边，指针域startPoint表示出边表的指针，指向起点相同的下一条边。
3. 网图，可以增加一个数据域weight表示权值。

虽然十字链表结构复杂，但是在有向图的应用中，十字链表是非常好的数据结构。
### 邻接多重表
对于无向图的邻接表，也可以仿照十字链表的方式，只不过对边表的结构进行一些改造。
表示方法：
1. 设置一个一维数组保存所有的顶点，每个数据元素有数据域data保存值，一个firstEdge指针域来保存顶点的第一条边。
2. 设置一个边表，边表的结点设置有iIndex和jIndex数据域来保存这条边左右的两个顶点在数组中的下标。iNext和jNext两个指针域分别指向依附于下标为iIndex和jNext的顶点的下一条边。
邻接多重表和邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。要删除边，只需要设置依附于顶点的指针域为空即可。
### 边集数组
边集数组是由两个一维数组构成。一个存储顶点的信息；另一个存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)，终点下标(end)和权(weight)组成。

边集数组是边的集合，在边集数组中要查找一个顶点的度需要扫描整个便数组，效率不高，因此它适合对边依次进行处理的操作，不适合对顶点的相关操作。

## 图的遍历
从图中某一点出发访问图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫图的遍历。
在遍历过程中把访问过的顶点打上标记，以免访问多次。具体办法是设置一个访问数组visited[n]，n是图中顶点的个数，初始值为0，访问过就变为1.
### 深度优先遍历
深度优先遍历(Depth first search)，也称为深度优先搜索，简称DFS。深度优先遍历类似树的先序遍历。
方法： 先按约定好的一个访问策略去访问顶点，如在没有碰到重复点的情况下，始终是向右手边走，发现某顶点下没有未访问过的顶点，就返回到上一个顶点，每次访问一个点，就将它放入已经访问的数组中，并且在每次遍历的路径中，将顶点压入栈中，在返回时，如果当前栈顶元素没有其它邻接点没有访问，就弹出栈中，有的话就访问下一个顶点，压入栈中，重复这个过程。这是一个递归的过程，直到访问完所有的顶点。
### 广度优先遍历
广度优先遍历(Breadth first search)， 也称为广度优先搜索，简称BFS。
方法：在顶点和边的关系不变的情况下，将图稍微变形，将顶点分层放置，形状类似于树结构，然后一层一层访问所有的顶点。广度优先遍历类似树的层序遍历。

## 构造连通网的最小生成树
一个带权值的图，即网结构。一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。那么我们称构造连通网的最小代价生成树称为最小生成树。
找连通网的最小生成树，有两种经典算法，普里姆算法和克鲁斯卡尔算法。
## 普里姆算法（Prim）
# 堆结构
无序的数据集合。在优先级队列的各种实现中，堆是最高效的一种数据结构。
## 概念
### 关键码
数据记录中存在一个能够标识数据记录的数据项，并可依据该数据项对数据进行组织，则称此数据项为关键码key。
把一个关键码集合的所有元素按照完全二叉树的顺序存储方式存在一个一维数组中。
在最小堆中，父节点的关键码小于等于它的左右子女的关键码。
在最大堆中，父节点的关键码大于等于它的左右子女的关键码。
### 数组存储
最小堆存储在数组中。