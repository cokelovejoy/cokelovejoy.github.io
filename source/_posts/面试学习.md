---
title: 面试学习
date: 2020-06-05 13:24:20
tags:
---

# VS Code 使用
## 调试
F5启动调试，默认支持Node调试。

## 网页调试
安装Debugger for Chrome扩展，基本配置如下。
```js
//  launch.js启动调试的配置文件
{ 
    "version": "0.2.0",
    "configurations": [
        { 
            "name": "Launch localhost",
            "type": "chrome",
            "request": "launch",            
            "url": "http://localhost:8080/",
            "webRoot": "${workspaceFolder}/wwwroot" //默认index.html的文件夹位置, workspaceFolder 是当前.vscode所在的文件夹
        }
    ]
}

```
安装http-server, 并启动
```bash
npm i http-server -g
http-server
```
然后按F5，选择使用Chrome，就可以使用Chrome进行调试html中的js文件。

## VS Code集成Git
### 下载 git
```bash
sudo apt-get install git
```
### 使用git
1. 命令行使用git命令
2. 命令面板：ctrl+shift+P 
3. 克隆 git:clone  --> enter url
4. 将本地工作区文件夹 变为 git 本地仓库
5. 添加远程仓库 git:add remote --> enter remote name --> enter remote url
6. git add
7. git commit
8. git push
9. git pull

## 安装Node

## 安装扩展
### vue-vscode-snippets
生成代码片段的快捷方式
### vetur
语法高亮，代码片段，错误检查

# Vue学习
## Vue 核心思想简介
Vue 核心思想：1.数据驱动应用 2.MVVM模式(Model, View, VirtualModel)

MVVM框架的三要素： 数据响应式， 模板引擎(模板 -> VNode)， 渲染(VNode -> DOM)

响应式： Vue如何监听数据变化？数据变化更新视图， 视图变化更新数据。
模板： Vue模板如何编写和解析。
渲染： Vue如何将模板转换为html。

## Vue 核心知识点
### 插值文本 
```js
{{}}
```
### 数据绑定指令 
v-bind:attr，缩写 :attr
### 列表渲染指令 
v-for=(item of array) 注意要绑定key属性(:key='item.id')。
### 数据双向绑定指令
v-model 指令使用在表单元素 input, select, option等。
### 事件处理指令
v-on 指令监听DOM事件或传递自定义事件到子组件，触发时调用回调函数。
v-on:click="clickFunc", 缩写：:click="clickFunc"。
事件修饰符，按键修饰符。
### class和style绑定
```js
:class="{active: condition === true}"
:style="{backgroundColor: isBlue ? 'blue' : 'purple'}"
```
active为class，后面的属性值是表达式的计算结果，表示是否添加active这个class。
还可以是一个数组，里面就要设置的一个个样式的className。
### 条件渲染
v-if="isExists" 控制元素是否真实的渲染
v-if=""
v-else-if=""
v-else
注意v-if不能和v-for在同一个标签上，v-for的优先级比v-if高。

v-show="" 通过控制css属性display控制元素显示，但是元素总是存在的。
v-if惰性渲染元素，如果一开始条件就是falsy，那么元素就是不存在的，并不会渲染。

### Vue对模板的处理
Vue将模板编译成 虚拟DOM渲染函数，然后渲染函数会将VNode渲染成DOM。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。
实际上Vue内部，实际上是将模板转换成了render函数。
```js
console.log(app.$options.render)

// 这就是生成的模板渲染函数(render函数)
(function anonymous() {with(this){return _c('div',{attrs:{"id":"app"}},[_c('h2',{attrs:{"title":title}},[_v("\n            "+_s(title)+"\n        ")]),_v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(course),expression:"course"}],attrs:{"type":"text"},domProps:{"value":(course)},on:{"keydown":function($event){if(!$event.type.indexOf('key')&&_k($event.keyCode,"enter",13,$event.key,"Enter"))return null;return addCourse($event)},"input":function($event){if($event.target.composing)return;course=$event.target.value}}}),_v(" "),_c('button',{on:{"click":addCourse}},[_v("新增课程")]),_v(" "),(courses.length == 0)?_c('p',[_v("没有任何课程信息")]):_e(),_v(" "),_c('ul',_l((courses),function(c){return _c('li',{class:{active: (selectedCourse === c)},on:{"click":function($event){selectedCourse = c}}},[_v(_s(c))])}),0)])}})
```
### 计算属性和监听器
computed属性,计算属性有缓存性，只有依赖的数据变化了，才会去重新计算，重新渲染页面。
watch属性,默认情况下watch初始化时，不会执行，只有数据变化了，才会执行到watch里面的函数，但是通过配置immediate属性可以让watch立即执行。

watch和computed的差异
watch适用于一个值变化了，影响多个值的情形。一个值的变化引起很多事件的处理。当在数据变化时需要执行异步操作或者较大开销的操作情况更适合使用watch。
computed适用于多个值变化了，影响一个值的情形。
```js
const vm = new Vue({
    el: '#app',
    data: function () {return {
        title: 'hello',
        name: 'Vue'
    }},
    computed: {
        getName: function () {
            return this.title === 'hello' ? 'world' : 'vue'
        }
    }，
    watch: {
        title: function (newV, oldV) {
            // block
        },
        name: {
            immediate: true, // 立即执行
            // deep: true, 深层的监听
            handler: function (newV, oldV) {
                // block
            }
        }
    }
})
```

### 生命周期
每一个Vue实例创建时都要经过一系列的初始化过程： 设置数据监听， 编译模板， 将实例挂载到DOM，并在数据变化的时候更新DOM等，称为Vue实例的生命周期。
#### 使用生命周期钩子函数
在Vue实例的生命周期的过程中会运行一些叫做生命周期的钩子函数，可以在不同的阶段添加自己代码。
```js
beforeCreate() {}
created() {} //在生命周期钩子函数中使用data中的数据时，最早只能在created中，此时能使用data中的数据，但此时还没有挂载，还没有DOM，还不能操作DOM
beforeMount() {}
mounted() {} // 这mounted中，DOM已经生成，可以操作DOM。
```

生命周期四个阶段及使用场景
初始化数据： beforeCreate(组件实例还未创建，数据还没有准备好，通常用于插件开发中执行一些初始化任务), created(组件初始化完毕，各种数据可以使用，常用于异步数据获取) 
挂载组件:   beforeMount(未执行渲染，dom没有创建), mounted(dom创建完毕，可以用于获取访问数据和dom元素)
更新组件： beforeUpdate(更新前，可用于获取更新前的各种状态), updated(更新后，所有状态已是最新)
销毁组件： beforeDestroy(销毁前，组件实例还在，可用于定时器或订阅器的取消), destroyed(组件已销毁，可用于定时器或订阅器的取消)

### 组件化基础

#### 使用Vue.component()创建子组件
```js
// 创建组件时，建议使用-命名
Vue.component('my-component', {
    props: {
        courses: {
            type: Array,
            default: []
        }
    },
    data: function () {
        return {
            selectedCourse: ''
        }
    }
    template: `<div>{{ selectedCourse }}</div>`
})
// 使用子组件
// <my-component></my-component>
```
第一个参数是组件名，第二个参数是创建Vue实例时的属性选项(option)

#### 自定义事件及监听
子组件和父组件进行通信，可以派发并监听自定义事件。
使用this.$emit('my-event', params)

#### 在组件上使用v-model
自定义组件支持v-model需要组件内部实现input的:value和@input
```js
// <my-component v-model="mydata"></mycomponent>
// v-model其实是语法糖，它等价于如下写法
// <my-component :value="mydata" @input="mydata=$event"></my-component>
// 子组件内部传入value，并派发input事件
Vue.component('my-component', {
    props: ['value'],
    template: 
        `<div>
            <input type="text" :value="value" @input="inputEvent">
        </div>`,
    methods: {
        inputEvent(e) {
            this.$emit('input', e.target.value)
        }
    }
})
```
#### slot通过插槽进行内容分发
通过slot元素可以给子组件传递内容
默认插槽
具名插槽
作用域插槽 (插槽props)
```js
    Vue.component('message', {
        props: ['show'],
        template: 
            `<div v-if="show">
                <slot></slot>
                <slot name="title" title="来自于子组件的title">默认标题</slot>
                <span @click="$emit('update:show', false)">X</span>
            </div>`
    })

    // 使用message组件,使用事件修饰符.sync
    /*
        <message :show.sync="show">
            <template v-slot:default> hello world</template>
            <template v-slot:title="slotProps">
                haha {{slotProps.title}}
            </template>
        </message>
    */
```
#### 组件化总结
组件化是Vue的精髓，Vue应用由一个个组件构成。
定义：组件就是可复用的Vue实例，准确的说他们是Vue.component的实例，继承自Vue。
优点：组件化增加代码的可复用性，可维护性和可测试性
使用场景： 什么时候使用场景
* 通用组件： 实现最基本的功能，具有通用性，复用性，例如按钮组件，输入组件，布局组件 等。
* 业务组件： 他们完成具体业务，具有一定的复用性，例如登录组件，注册组件。
* 页面组件： 组织应用各部分独立内容，需要时在不同的页面间切换，例如列表页，详情页组件。
如何使用组件
* 定义： Vue.component(), components选项
* 分类： 有状态组件，functional(函数式组件), abstract
* 通信： props, $emit/$on, provide/inject, $children/$parent/$root/$attrs/$listeners（耦合性强，使用的不多）
* 内容分发： slot元素，template， v-slot
* 优化： is(动态组件)， keep-alive, 异步组件
组件的本质
Vue组件的本质是产生虚拟DOM

### Vue API
#### 数据相关
1. 给对象增加属性。如果对象是响应式的，确保新增属性能触发视图更新
```js
Vue.set(obj, 'attrName', value)
this.$set(obj, 'attrName', value)
```
2. 删除对象的属性。如果对象是响应式的，确保删除能触发视图更新
```js
Vue.delete(obj, 'attrName')
this.$delete(obj, 'attrName')
```

#### 事件相关
事件的监听和派发都是在同一个实例上。虽然写法上是父组件中绑定事件，但是底层Vue处理之后，仍然是同一个实例上做的监听。
1. 监听当前实例上的自定义事件。
```js
// 模板中 @test="func" 
vm.$on('test', function (params) {
    // callback function
})
```
2. 触发当前实例上的事件。附加参数都会传给监听器的回调函数。
```js
vm.$emit('test', 'hello')
```
3. 监听一个自定义事件，但只触发一次，触发之后，监听器就会被移除。
```js
vm.$once('test', function (msg) {
    // callback
})
```
4. 移除自定义事件监听器
```js
vm.$off() // 移除所有事件监听器
vm.$off('test') // 移除该事件所有的监听器
vm.$off('test', callback) // 只移除这个回调的监听器
```
#### 事件总线
通过在Vue原型上添加一个Vue实例作为事件总线，实现组件间相互通信，而且不受组件间层级关系的影响。
```js
// 这样做可以在任意组件中使用this.$bus访问到该Vue实例。
Vue.prototype.$bus = new Vue()

this.$bus.$on('xxx', callback)
this.$bus.$emit('xxx', value)
```
5. 组件或元素的引用
ref属性被用来给元素或者子组件注册引用信息，引用信息将会注册在父组件的vm.$refs对象上。
如果在普通的DOM元素上使用，引用指向的就是DOM元素，如果是子组件上使用，引用就指向组件。 

注意 ref是作为渲染结果被创建的，在初始渲染时不能访问它们，最早只能在mounted里面。
$refs 不是响应式的，不要试图用它在模板中做数据绑定。
当v-for用于元素或组件时，引用信息将是包含DOM节点或组件实例的数组。
```js
// <span ref="xxx"></span>
this.$refs.xxx
```
### Vue扩展知识
#### 过度和动画
Vue 在插入，更新或移除DOM时，提供了多种不同方式的应用过度效果。
包括以下工具： 
* 在CSS过度和动画中自动应用class
* 配合第三方CSS动画库，如Animate.css
* 在过度钩子函数中使用JavsScript直接操作DOM
* 配合使用第三方JS动画库，如Velocity.js

1. CSS过度动画
transition组件为嵌套元素
```js
/* 
1. v-enter ：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移 除。
2. v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移 除。
3. v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。
4. v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
5. v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。
6. v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。
    fade-enter 入场前的动画
    fade-enter-active 入场动画
    fade-leave-to 离场的最后
    fade-leave-active 进入离场

    <transition name="fade">
        <div class="fade-enter">
        </div>
    </transition>
*/
```
* v-enter
v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。
```
.fade-enter {
    opacity: 0;
}
```
* v-enter-active
v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移除。
```
.fade-enter-active { transition: opacity .5s; }
```
* v-enter-to
v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。
```
.fade-enter-to { opacity: 1; }
```
* v-leave
 v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
 ```
.fade-leave { opacity: 1; }
 ```
 * v-leave-active
 v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。
 ```
.fade-leave-active { transition: opacity .5s; }
 ```
 * v-leave-to
 v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。
 ```
 .fade-leave-to { opacity: 0; }
 ```

 2. 使用CSS动画库
 通过自定义过度类名可以有效结合Animate.css这类动画库制作更精美的动画效果。
 引入animate.css
 ```
 <link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">
 ```
 在transition中使用animate中的class
 ```
<transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut"></transition>
 ```
 3. JavaScript 钩子
 可以在transition中生命JavaScript钩子，使用JS实现动画。

 ```
 <transition 
    @before-enter="beforeEnter"
    @enter="enter"
    @before-leave="beforeLeave"
    @leave="leave"
 >
 </transition>

// JS钩子
methods: {
    beforeEnter(el) {
        // 动画初始化状态
        el.style.opacity = 0
    },
    enter(el, done) {
        // 触发回流激活动画
        document.body.offsetHeight
        // 动画结束状态
        el.style.opacity = 1
        // 监听动画结束事件，并执行done
        el.addEventListener('transitionend', done)
    },
    beforeLeave(el) {
        // 动画初始状态
        el.style.opacity = 1
    },
    leave(el, done) {
        // 触发回流激活动画
        document.body.offsetHeight
        // 动画结束状态
        el.style.opacity = 0
        // 监听动画结束事件，并执行done
        el.addEventListener('transitionend', done)
    }
}
 ```

 3. 纯JS方案
 引入velocity.js
 ```
<script src="https://cdnjs.cloundflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
 ```
 使用velocity
 ```
 // JS钩子
methods: {
    beforeEnter(el) {
        // 动画初始化状态
        el.style.opacity = 0
    },
    enter(el, done) {
        Velocity(el, { opacity:1 }, { duration: 1500, complete: done })
    },
    beforeLeave(el) {
        // 动画初始状态
        el.style.opacity = 1
    },
    leave(el, done) {
        Velocity(el, { opacity: 0 }, { duration: 1500, complete: done})
    }
}
 ```

 4. 列表过度
 利用transition-group元素可以对v-for渲染的每个元素应用过度
 ```
<transition-group name="fade">
    <div v-for="c in courses" :key="c.name">
        {{ c.name }} - ￥{{c.price}}<button @click="addToCart(c)">加购</button>
    </div>
</transition-group>
 ```

#### 过滤器
Vue允许自定义过滤器，可以被用于一些常见的文本格式化。过滤器可以用在双大括号 和v-bind表达式。
注意管道符左边的值作为过滤器的第一个参数， ()中的第一个参数是过滤器的第二个参数。
```
<!-- 全局定义过滤器 -->
Vue.filter('currency', function (val, symbol = '$') {
    return symbol + val
})
<!-- 局部定义过滤器 -->
filters: {
    currency(val, symbol = '$') {
        return symbol + val
    }
}
<!-- 在插值中使用 -->
{{ money | capitalize(symbol) }}
<!-- 在 v-bind 中使用 -->
<div v-bind:id="rawId | formatId"></div>
```
#### 自定义指令
当我们仍然需要对DOM元素进行多次相同的底层操作时，就会用到自定义指令。(提高复用性)
```
<!-- 全局定义自定义指令 -->
Vue.directive('focus', {
    inserted(el, binding) {
        el.focus()
    }
})
<!-- 使用自定义指令 -->
<input v-focus>
```
自定义指令有如下几个钩子函数可以使用：
bind
inserted
update
componentUpdated
unbind
参数：el触发事件的元素, binding对象

#### 渲染函数
Vue推荐使用模板来创建html，但在一些特殊场景下，必须使用js，来用程序的方式控制。这时可以使用渲染函数。
```
render: function (createElement) {
    // createElement函数返回结果是VNode
    return createElement(
        tag, // 标签名称
        data, // 传递数据
        children //子节点数组
    )
}
```
使用render实现heading组件
```
Vue.component('heading', {
    props: ['level', 'title'],
    render(h) {
        return h('h'+this.level, children)
    }
})
```
#### 虚拟DOM
虚拟DOM的底层实现使用的是snabbdom， 在snabbdom中就是用的h作为createElement函数的名字，所以这里也用h。
Vue通过建立一个虚拟DOM来追踪自己要如何改变真实DOM。
createElement函数中的参数。
```
render: function (createElement) {
    // createElement函数返回结果是VNode
    return createElement(
        tag, // 标签名称，一个 HTML 标签名、组件选项对象。
        data, // 传递数据，一个与模板中属性对应的数据对象。
        children // 子节点数组，子级虚拟节点 (VNodes)，由 `createElement()` 构建而成
    )
}
```
#### 函数式组件
组件没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法时，可以将组件标记为functional，这意味着它无状态(没有响应式数据)，也没有实例(没有this上下文)。
```
Vue.component('heading', {
    functional: true, // 函数式组件
    props: ['level', 'title],
    render(h, context) { // 组件需要的一切都是通过context获取的
        return h()
    }
})
```
#### 混入
混入(mixin)提供了一种非常灵活的方式，来分发Vue组件中的可复用的功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项。
```
// 定义一个混入对象
var myMixin = {
    created: function () {
        this.hello() // this 表示组件实例
    },
    // 公用方法
    methods: {
        hello: function () {
            console.log('hello')
        }
    }
}
// 使用混入对象的组件
Vue.component('comp', {
    mixins: [myMixin]
})
```
选项合并的规则
数据对象(data选项)在内部会进行递归合并，并在发生冲突时以组件数据优先，组件的数据覆盖混入对象中的数据。
同名钩子函数将合并成一个数组，先调用混入对象中的钩子函数，再调用组件中的钩子函数。
值为对象的选项，如methods,components, directives,将被合并为同一个对象，两个对象中键名冲突时，取组件对象的键值对。

#### 插件
插件通常用来为Vue添加全局功能。插件的功能范围有以下几种：
1. 添加全局方法或者属性。如vue-custom-element
2. 添加全局资源：指令/过滤器/过渡等。如vue-touch
3. 通过全局混入来添加一些组件选项。如vue-router
4. 添加Vue实例方法，通过把他们添加到Vue.prototype上实现。
5. 一个库，提供自己的API，同时提供上面提到的一个或多个功能。如vue-router

插件声明
Vue的插件生命应该暴露一个install方法。这个方法的第一个参数是Vue构造函数，第二个参数是一个可选的选项对象。
```
myPlugin.install = function (Vue, options) {
    // 1. 添加全局方法或属性
    Vue.myGlobalMethod = function () {}
    // 2. 添加全局资源
    Vue.directive('my-directive', {})
    // 3. 注入组件选项
    Vue.mixin({})
    // 4. 添加实例方法
    Vue.prototype.$myMethod = function (methodOptios) {}
}
```
插件使用
使用Vue.use()引入插件
修改heading组件为插件，通过插件的方式去分发,更加便捷。
```
const MyPlugin = {    
    install (Vue, options) {
        Vue.component('heading', {...})
    }
}
if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(MyPlugin)
}
```

### 工程化
使用Vue-cli脚手架
```
npm install -g @vue/cli
vue --version
```
#### 快速原型开发
vue serve 和 vue build命令对单个.vue文件进行快速原型开发。不过这需要先额外安装一个全局的扩展：@vue/cli-service-global.
vue serve 的缺点就是它需要安装全局依赖，这使得它在不同机器上的一致性不能得到保证。因此这只适用于快速原型开发。
```
// 安装@vue/cli-service-global扩展
npm install -g @vue/cli-service-global
```
#### vue serve
启动一个服务并运行一个原型
```
vue serve hello.vue
```
#### 创建项目
创建一个vue项目
```
vue create my-vue-project
```
#### 安装插件
Vue Cli使用了一套基于插件的架构。插件可以修改webpack的内部配置，也可以向vue-cli-service诸如命令。在项目创建的过程中，绝大部分列出的特性都是通过插件来实现。
```
// 在项目中安装插件
vue add router
```
安装插件完成后，会对项目目录以及内容有一些破坏性的更改，因此要提前备份之前的代码。
#### 处理资源路径
当在js，css，vue文件中使用相对路径(必须以.开头)引用一个静态资源时，将来该资源将会被webpack处理。
##### 转换规则
* URL 是一个绝对路径(如/images/foo.png),就是永远到当前服务器存放静态文件的路径下查找(一般是public)。
```
<img src="/assets/logo.png">
<img src="http://image.xx.com/logo.png">
```
* URL 以.开头会作为一个相对模块请求被解释并基于文件系统相对路径。
```
<img src="./assets/logo.png">
```
* URL 以~开头会作为一个模块请求被解释。因此可以引用Node模块中的资源。
```
<img src="~npm-package/foo.png">
```
* URL 以@开头会作为一个模块请求被解释。Vue Cli默认会设置一个指向src的别名@。
```
import Hello from '@/components/hello.vue'
```
##### 何时使用public文件夹(处理静态文件)
通过webpack的处理可以获得如下好处:
* 脚本和样式表会被压缩且打包在一起，从而避免而外的网络请求。
* 文件丢失会直接在编译时报错，而不是到了客户端才产生404错误。
* 最终生成的文件名包含了内容哈希，因此不必担心浏览器会缓存它们的老版本。

如下情况考虑使用public文件夹
* 需要在构建输出中指定一个固定的文件名字。
* 有上千个图片，需要动态引用它们的路径。
* 有些库可能和webpack不兼容，除了将其用一个独立的script标签引入没有别的选择。

使用public文件夹的注意事项
* 如果你的应用没有部署在域名的根部，那么你需要为你的URL配置publicPath前缀
```
// 新建vue.config.js
module.exports = {
    publicPath: process.env.NODE_ENV === 'production' ? '/cart/' : '/'
}
```
* 在public/index.html等通过html-webpack-plugin用作模板的HTML文件中，你需要通过<%= BASE_URL %>设置链接前缀
```
<link rel="icon" href="<%= BASE_URL %>favicon.ico">
```
* 在模板中，先向组件传入BASE_URL
```
data() {
    return {
        publicPath: process.env.BASE_URL
    }
}
// 动态文件路径拼接
<img :src="`${publicPath}my-img.png`">
```
一般不推荐使用public文件夹

#### CSS相关
##### 使用预处理器
如果创建项目的时候没有选择需要的预处理器(Sass/Less/Stylus)， 则需要手动安装相应的loader。
```
# Sass
npm install -D sass-loader node-sass

# Less
npm install -D less-loader less

# Stylus
npm install -D stylus-loader stylus
```

##### 自动化导入样式
自动化导入样式文件(用于颜色，变量，mixin等)，可以使用style-resources-loader。
```
npm i -D style-resources-loader
```
配置vue.config.js，就是与webpack在交互，这里面的配置都会设置到webpack的配置中。
```
const path = require('path')
function addStyleResource(rule) {
    rule.use('style-resource')
        .loader('style-resources-loader')
        .options({
            patterns: [
                path.resolve(__dirname, './src/styles/imports.scss')
            ]
        })
}

module.exports = {
    chainWebpack: config => {
        const types = ['vue-modules', 'vue', 'normal-modules', 'normal']
        types.forEach(type => addStyleResource(config.module.rule('scss').oneof(type)))
    }
}
```

##### Scoped CSS
当标签style有scoped属性时，它的CSS只作用于当前组件中的元素。
```
<style scoped>
    .red {
        color: red;
    }
</style>
```
其原理就是通过使用postCSS来转换成如下，实际上就是增加了一个属性用来标记。
```
<template>
    <div class="red" data-v-f3f3eg9>hi</div>
</template>
<style>
    .red[data-v-f3f3eg9] {
        color: red;
    }
</style>
```
混用全局和本地样式

```
<style>
<!-- 全局样式 -->
</style>
<style scoped>
<!-- 本地样式 -->
<!-- 注意在scoped中，样式只能设置到组件的第一层标签上，样式的设置不会穿透到组件内部元素。 -->
#app p {
    color: red;
}
</style>
```
深度作用选择器：使用>>>操作符可以使用scoped样式中的一个选择器能够作用得更深。
```
<style scoped>
#app >>> a {
    color: red;
}
</style>
```
Sass之类的预处理器无法正确解析>>>这中情况下可以使用/deep/或者::v-deep操作符取而代之
```
<style scoped lang="scss">
    #app {
        /deep/ a {
            color: rgb(196, 50, 140)
        }
        ::v-deep a {
            color: rgb(196, 50, 140)
        }
    }
</style>
```

##### CSS Module
CSS Modules 是一个流行的,用于模块化和组合CSS的系统。vue-loader 提供了与CSS Modules 的一流集成，可以作为模拟scoped CSS的替代方案。
原理：对类名做修改。

```
// 使用module 替代 scoped
<style module lang="scss">
    .red {
        color: #f00;
    }
    .bold {
        font-weight: bold;
    }
</style>
```
模板中通过$style.xx访问
```
<a :class="$style.red">awesome-vue</a>
<a :class="{[$style.red]:isRed}">awesome-vue</a>
<a :class="[$style.red, $style.bold]">awesome-vue</a>
```
js中访问
```
<script>
    export default {
        created () {
            // red类名变成了red_1VyoJ-uz 附加在标签上，这是一个基于文件名和类名生成的标识符。
            console.log(this.$style.red)
        }
    }
</script>
```

#### 数据访问相关
##### 数据模拟
使用开发服务器配置before选项，可以编写接口，提供模拟数据。
在vue.config.js 中进行配置。
参考：https://cli.vuejs.org/zh/config/#devserver
```
module.exports = {
    devServer: {
        before(app) {
            // app是一个express实例, 模拟接口
            app.get('/api/courses', (req, res) => {
                setTimeout(() => {
                    res.json([{name: 'web', price: 9999}, {name: 'java', price: 10000}])
                }, 1000)
            })
        }
    }
}
```
安装axios
```
npm i -S axios
```
使用axios请求数据
```
export function getCourses() {
    return axios.get('/api/courses').then(res => res.data)
}
```
##### 代理proxy
当前端应用和后端API服务器没有运行在同一个主机上，需要在开发环境下将API请求代理到API服务器。可以通过vue.config.js中的devServer.proxy选项来配置。
设置开发服务器代理选项可以有效避免调用接口时出现的跨域问题。

```
// vue.config.js
module.exports = {
    devServer: {
        // 对于没有找到的url(静态资源)，转发到下面的地址。
        proxy: 'http://localhost:3000' 
    }
}
```
设置代理服务器
当没有请求到资源的时候，会转发到下面这个服务器。
```
// api.js
// 需要安装express: npm i express
const express = require('express')
const app = express()
app.get('/api/courses', (req, res) => {
    res.json([{name: 'web', price: 9999}, {name: 'java', price: 10000}])
})

app.listen(3000)
```
启动代理服务器
```
node api.js
```

### 路由Vue-router
Vue Router 是Vue 的官方的路由管理器。
参考： https://router.vuejs.org/zh/

#### 安装
```
vue add router
```
#### 路由规划
根据业务功能，做相应的路由规划，合理划分不同的路由对应不同的页面来实现相应的功能。
##### 路由配置
以插件形式安装之后，就会有router文件夹，路由配置在index.js内，页面组件在views文件夹下。
```
import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '../viewsHome.vue'

Vue.use(VueRouter)

const routes = [
    {
        path: '/',
        name: 'home',
        component: Home
    }
]
const router = new VueRouter({
    mode: 'history',
    base: process.env.BASE_URL,
    routes
})
```
##### 路由导航
```
<nav>
    <router-link to="/">首页</router-link>
    <router-link to="/admin">管理</router-link>
</nav>
```
##### 路由出口
这个标签相当于是一个占位符，组件将来会展示在这里，并把这个标签替换掉。
```
<router-view></router-view>
```
#### 动态路由
在Vue-router的路由路径中使用"动态路径参数"，实现动态路由匹配。
```
// id 是可以变化的
{
    path: '/user/:id',
    name: 'user'
    component: User
}
// 获取参数id的值
$route.params.id
```
##### 通配符 *
```
// 会匹配所有的路径
{ 
    path: '*',
    component: () => import('../views/404.vue')
}
```
#### 嵌套路由
应用界面通常由多层嵌套的组件组合而成。同样URL中各段动态路径也按某种结构对应嵌套的各层组件。
```
{
    path: '/about',
    name: 'about',
    component: () => import('../views/About.vue'),
    children: [
        {
            path: '/courses/:name', // 相对路径
            name: 'detail'
            component: () => import('../views/Detail.vue')
        }
    ]
}

```
嵌套内容的出口
```
// 动态变化的子组件会显示在这里
<router-view></router-view>
```

#### 编程导航
借助$router的实例方法，可编写代码来实现路由导航。
```
// 字符串
$router.push('/')
// 对象
$router.push({path: 'home'})
// 命名路由
$router.push({name: 'detail', params: {id: 'xxx'}})
// 带查询参数 /detail?id=123
$router.push({path: 'detail', query: { id: '123'}})
```

#### 命名路由
给路由一个名称，使用会更加方便
```
const router = new VueRouter({
    routes: [
        {
            path: '/user/:userId',
            name: 'user',
            component: User
        }
    ]
})
```
链接到一个命名路由
```
<router-link :to="{name: 'user, params: { userId: 123}'}">User</router-link>
```
在$router.push()中使用命名路由：
```
$router.push({ name: 'user', params: {userId: 123}})
```
注意 组件复用时，路由切换引起的子组件切换不会重新创建父组件，包含有ajax请求数据的生命周期函数，不会被再次调用。可以通过监听路由参数变化，去请求数据。
```
// 响应路由参数变化
export default {
    watch: {
        $route: {
            handler: () => {console.log("route changed")},
            immediate: true
        }
    }
}
```

#### 路由守卫
vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的，单个路由独享的，或者组件级的。
应用场景：权限控制，登陆以后才可以查看。
* 全局守卫
全局守卫，进入每一个路由前，都会先进入下面的钩子函数。
```
router.beforeEach((to, from, next) => {
    // to: Route (即将要进入的目标 路由对象)
    // from: Route (当前导航正要离开的路由)
    // next: Function(一定要调用该方法来resolve这个钩子)
})
```
例子
```
router.beforeEach((to, from, next) => {
    // 判断路由是否需要守卫 先给该路由设置meta数据
    if (to.meta.auth) {
        // 判断是否登陆
        if (window.isLogin) {
            next()
        } else {
            next('/login?redirect=' + to.fullPath)
        }
    } else {
        next()
    }
})
// routes
{
    path: '/about',
    meta: {
        auth: true
    },
    component: () => import('../view/about.vue')
}
```
* 路由独享的守卫
为某一个路由设置守卫，只有在进入这个路由的时候才会执行钩子函数。
在路由配置上直接定义beforeEnter守卫。
```
{
    path: '/about',
    name: 'about',
    component: () => import('../views/Login.vue'),
    beforeEnter: (to, from, next) => {
        // ...
    }
}
```
* 组件级的守卫
在路由组件内直接定义以下路由导航守卫：
beforeRouterEnter, beforeRouterUpdate, beforeRouterLeave
```
beforeRouterEnter(to, from, next) {
    if (window.isLogin) {
        next()
    } else {
        next('/login?redirect=' + to.fullPath)
    }
}
```
* 数据获取
路由激活时，如果需要获取服务器数据，有两个时机。
路由导航前：
```
// 此时组件未渲染，通过给next传递回调访问组件实例
beforeRouterEnter(to, from, next) {
    getPost(to.params.id, post => {
        next(vm => vm.setData(post))
    })
}
// 此时组件已经渲染，可以访问this直接赋值
beforeRouterUpdate(to, from, next) {
    this.post = null
    getPost(to.params.id, post => {
        this.setData(post)
        next()
    })
}
```
路由导航后：
```
created() {
    this.fetchData()
},
// 监听路由的方式出发异步获取数据的方法。
watch: {
    '$route': 'fetchData'
}
```

* 编程方式动态添加路由
通过router.addRoutes(routes)方式动态添加路由列表。
应用场景：只有登陆之后，才能访问某些路由。这里在登陆之后，才添加一些路由。
```
login() {
    window.login = true
    this.$router.addRoutes([
        {
            path: '/about',
        }
    ])
}
```