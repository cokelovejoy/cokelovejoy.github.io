---
title: 面试学习
date: 2020-06-05 13:24:20
tags:
---

# VS Code 使用
## 调试
F5启动调试，默认支持Node调试。

## 网页调试
安装Debugger for Chrome扩展，基本配置如下。
```js
//  launch.js启动调试的配置文件
{ 
    "version": "0.2.0",
    "configurations": [
        { 
            "name": "Launch localhost",
            "type": "chrome",
            "request": "launch",            
            "url": "http://localhost:8080/",
            "webRoot": "${workspaceFolder}/wwwroot" //默认index.html的文件夹位置, workspaceFolder 是当前.vscode所在的文件夹
        }
    ]
}

```
安装http-server, 并启动
```bash
npm i http-server -g
http-server
```
然后按F5，选择使用Chrome，就可以使用Chrome进行调试html中的js文件。

## VS Code集成Git
### 下载 git
```bash
sudo apt-get install git
```
### 使用git
1. 命令行使用git命令
2. 命令面板：ctrl+shift+P 
3. 克隆 git:clone  --> enter url
4. 将本地工作区文件夹 变为 git 本地仓库
5. 添加远程仓库 git:add remote --> enter remote name --> enter remote url
6. git add
7. git commit
8. git push
9. git pull

## 安装扩展
### vue-vscode-snippets
生成代码片段的快捷方式
### vetur
语法高亮，代码片段，错误检查

# Vue学习
## Vue 核心思想简介
Vue 核心思想：1.数据驱动应用 2.MVVM模式(Model, View, VirtualModel)

MVVM框架的三要素： 数据响应式， 模板引擎(模板 -> VNode)， 渲染(VNode -> DOM)

响应式： Vue如何监听数据变化？数据变化更新视图， 视图变化更新数据。
模板： Vue模板如何编写和解析。
渲染： Vue如何将模板转换为html。

## Vue 核心知识点
### 插值文本 
```js
{{}}
```
### 数据绑定指令 
v-bind:attr，缩写 :attr
### 列表渲染指令 
v-for=(item of array) 注意要绑定key属性(:key='item.id')。
### 数据双向绑定指令
v-model 指令使用在表单元素 <input>, <select>, <option>等。
### 事件处理指令
v-on 指令监听DOM事件或传递自定义事件到子组件，触发时调用回调函数。
v-on:click="clickFunc", 缩写：:click="clickFunc"。
事件修饰符，按键修饰符。
### class和style绑定
```js
:class="{active: condition === true}"
:style="{backgroundColor: isBlue ? 'blue' : 'purple'}"
```
active为class，后面的属性值是表达式的计算结果，表示是否添加active这个class。
还可以是一个数组，里面就要设置的一个个样式的className。
### 条件渲染
v-if="isExists" 控制元素是否真实的渲染
v-if=""
v-else-if=""
v-else
注意v-if不能和v-for在同一个标签上，v-for的优先级比v-if高。

v-show="" 通过控制css属性display控制元素显示，但是元素总是存在的。
v-if惰性渲染元素，如果一开始条件就是falsy，那么元素就是不存在的，并不会渲染。

### Vue对模板的处理
Vue将模板编译成 虚拟DOM渲染函数，然后渲染函数会将VNode渲染成DOM。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。
实际上Vue内部，实际上是将模板转换成了render函数。
```js
console.log(app.$options.render)

// 这就是生成的模板渲染函数(render函数)
(function anonymous() {with(this){return _c('div',{attrs:{"id":"app"}},[_c('h2',{attrs:{"title":title}},[_v("\n            "+_s(title)+"\n        ")]),_v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(course),expression:"course"}],attrs:{"type":"text"},domProps:{"value":(course)},on:{"keydown":function($event){if(!$event.type.indexOf('key')&&_k($event.keyCode,"enter",13,$event.key,"Enter"))return null;return addCourse($event)},"input":function($event){if($event.target.composing)return;course=$event.target.value}}}),_v(" "),_c('button',{on:{"click":addCourse}},[_v("新增课程")]),_v(" "),(courses.length == 0)?_c('p',[_v("没有任何课程信息")]):_e(),_v(" "),_c('ul',_l((courses),function(c){return _c('li',{class:{active: (selectedCourse === c)},on:{"click":function($event){selectedCourse = c}}},[_v(_s(c))])}),0)])}})
```
### 计算属性和监听器
computed属性,计算属性有缓存性，只有依赖的数据变化了，才会去重新计算，重新渲染页面。
watch属性,默认情况下watch初始化时，不会执行，只有数据变化了，才会执行到watch里面的函数，但是通过配置immediate属性可以让watch立即执行。

watch和computed的差异
watch适用于一个值变化了，影响多个值的情形。一个值的变化引起很多事件的处理。当在数据变化时需要执行异步操作或者较大开销的操作情况更适合使用watch。
computed适用于多个值变化了，影响一个值的情形。
```js
const vm = new Vue({
    el: '#app',
    data: function () {return {
        title: 'hello',
        name: 'Vue'
    }},
    computed: {
        getName: function () {
            return this.title === 'hello' ? 'world' : 'vue'
        }
    }，
    watch: {
        title: function (newV, oldV) {
            // block
        },
        name: {
            immediate: true, // 立即执行
            // deep: true, 深层的监听
            handler: function (newV, oldV) {
                // block
            }
        }
    }
})
```

### 生命周期
每一个Vue实例创建时都要经过一系列的初始化过程： 设置数据监听， 编译模板， 将实例挂载到DOM，并在数据变化的时候更新DOM等，称为Vue实例的生命周期。
#### 使用生命周期钩子函数
在Vue实例的生命周期的过程中会运行一些叫做生命周期的钩子函数，可以在不同的阶段添加自己代码。
```js
beforeCreate() {}
created() {} //在生命周期钩子函数中使用data中的数据时，最早只能在created中，此时能使用data中的数据，但此时还没有挂载，还没有DOM，还不能操作DOM
beforeMount() {}
mounted() {} // 这mounted中，DOM已经生成，可以操作DOM。
```

生命周期四个阶段及使用场景
初始化数据： beforeCreate(组件实例还未创建，数据还没有准备好，通常用于插件开发中执行一些初始化任务), created(组件初始化完毕，各种数据可以使用，常用于异步数据获取) 
挂载组件:   beforeMount(未执行渲染，dom没有创建), mounted(dom创建完毕，可以用于获取访问数据和dom元素)
更新组件： beforeUpdate(更新前，可用于获取更新前的各种状态), updated(更新后，所有状态已是最新)
销毁组件： beforeDestroy(销毁前，组件实例还在，可用于定时器或订阅器的取消), destroyed(组件已销毁，可用于定时器或订阅器的取消)

