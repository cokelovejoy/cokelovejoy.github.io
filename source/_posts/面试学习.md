---
title: 面试学习
date: 2020-06-05 13:24:20
tags:
---

# VS Code 使用
## 调试
F5启动调试，默认支持Node调试。

## 网页调试
安装Debugger for Chrome扩展，基本配置如下。
```js
//  launch.js启动调试的配置文件
{ 
    "version": "0.2.0",
    "configurations": [
        { 
            "name": "Launch localhost",
            "type": "chrome",
            "request": "launch",            
            "url": "http://localhost:8080/",
            "webRoot": "${workspaceFolder}/wwwroot" //默认index.html的文件夹位置, workspaceFolder 是当前.vscode所在的文件夹
        }
    ]
}

```
安装http-server, 并启动
```bash
npm i http-server -g
http-server
```
然后按F5，选择使用Chrome，就可以使用Chrome进行调试html中的js文件。

## VS Code集成Git
### 下载 git
```bash
sudo apt-get install git
```
### 使用git
1. 命令行使用git命令
2. 命令面板：ctrl+shift+P 
3. 克隆 git:clone  --> enter url
4. 将本地工作区文件夹 变为 git 本地仓库
5. 添加远程仓库 git:add remote --> enter remote name --> enter remote url
6. git add
7. git commit
8. git push
9. git pull

## 安装Node

## 安装扩展
### vue-vscode-snippets
生成代码片段的快捷方式
### vetur
语法高亮，代码片段，错误检查

# Vue学习
## Vue 核心思想简介
Vue 核心思想：1.数据驱动应用 2.MVVM模式(Model, View, VirtualModel)

MVVM框架的三要素： 数据响应式， 模板引擎(模板 -> VNode)， 渲染(VNode -> DOM)

响应式： Vue如何监听数据变化？数据变化更新视图， 视图变化更新数据。
模板： Vue模板如何编写和解析。
渲染： Vue如何将模板转换为html。

## Vue 核心知识点
### 插值文本 
```js
{{}}
```
### 数据绑定指令 
v-bind:attr，缩写 :attr
### 列表渲染指令 
v-for=(item of array) 注意要绑定key属性(:key='item.id')。
### 数据双向绑定指令
v-model 指令使用在表单元素 input, select, option等。
### 事件处理指令
v-on 指令监听DOM事件或传递自定义事件到子组件，触发时调用回调函数。
v-on:click="clickFunc", 缩写：:click="clickFunc"。
事件修饰符，按键修饰符。
### class和style绑定
```js
:class="{active: condition === true}"
:style="{backgroundColor: isBlue ? 'blue' : 'purple'}"
```
active为class，后面的属性值是表达式的计算结果，表示是否添加active这个class。
还可以是一个数组，里面就要设置的一个个样式的className。
### 条件渲染
v-if="isExists" 控制元素是否真实的渲染
v-if=""
v-else-if=""
v-else
注意v-if不能和v-for在同一个标签上，v-for的优先级比v-if高。

v-show="" 通过控制css属性display控制元素显示，但是元素总是存在的。
v-if惰性渲染元素，如果一开始条件就是falsy，那么元素就是不存在的，并不会渲染。

### Vue对模板的处理
Vue将模板编译成 虚拟DOM渲染函数，然后渲染函数会将VNode渲染成DOM。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。
实际上Vue内部，实际上是将模板转换成了render函数。
```js
console.log(app.$options.render)

// 这就是生成的模板渲染函数(render函数)
(function anonymous() {with(this){return _c('div',{attrs:{"id":"app"}},[_c('h2',{attrs:{"title":title}},[_v("\n            "+_s(title)+"\n        ")]),_v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(course),expression:"course"}],attrs:{"type":"text"},domProps:{"value":(course)},on:{"keydown":function($event){if(!$event.type.indexOf('key')&&_k($event.keyCode,"enter",13,$event.key,"Enter"))return null;return addCourse($event)},"input":function($event){if($event.target.composing)return;course=$event.target.value}}}),_v(" "),_c('button',{on:{"click":addCourse}},[_v("新增课程")]),_v(" "),(courses.length == 0)?_c('p',[_v("没有任何课程信息")]):_e(),_v(" "),_c('ul',_l((courses),function(c){return _c('li',{class:{active: (selectedCourse === c)},on:{"click":function($event){selectedCourse = c}}},[_v(_s(c))])}),0)])}})
```
### 计算属性和监听器
computed属性,计算属性有缓存性，只有依赖的数据变化了，才会去重新计算，重新渲染页面。
watch属性,默认情况下watch初始化时，不会执行，只有数据变化了，才会执行到watch里面的函数，但是通过配置immediate属性可以让watch立即执行。

watch和computed的差异
watch适用于一个值变化了，影响多个值的情形。一个值的变化引起很多事件的处理。当在数据变化时需要执行异步操作或者较大开销的操作情况更适合使用watch。
computed适用于多个值变化了，影响一个值的情形。
```js
const vm = new Vue({
    el: '#app',
    data: function () {return {
        title: 'hello',
        name: 'Vue'
    }},
    computed: {
        getName: function () {
            return this.title === 'hello' ? 'world' : 'vue'
        }
    }，
    watch: {
        title: function (newV, oldV) {
            // block
        },
        name: {
            immediate: true, // 立即执行
            // deep: true, 深层的监听
            handler: function (newV, oldV) {
                // block
            }
        }
    }
})
```

### 生命周期
每一个Vue实例创建时都要经过一系列的初始化过程： 设置数据监听， 编译模板， 将实例挂载到DOM，并在数据变化的时候更新DOM等，称为Vue实例的生命周期。
#### 使用生命周期钩子函数
在Vue实例的生命周期的过程中会运行一些叫做生命周期的钩子函数，可以在不同的阶段添加自己代码。
```js
beforeCreate() {}
created() {} //在生命周期钩子函数中使用data中的数据时，最早只能在created中，此时能使用data中的数据，但此时还没有挂载，还没有DOM，还不能操作DOM
beforeMount() {}
mounted() {} // 这mounted中，DOM已经生成，可以操作DOM。
```

生命周期四个阶段及使用场景
初始化数据： beforeCreate(组件实例还未创建，数据还没有准备好，通常用于插件开发中执行一些初始化任务), created(组件初始化完毕，各种数据可以使用，常用于异步数据获取) 
挂载组件:   beforeMount(未执行渲染，dom没有创建), mounted(dom创建完毕，可以用于获取访问数据和dom元素)
更新组件： beforeUpdate(更新前，可用于获取更新前的各种状态), updated(更新后，所有状态已是最新)
销毁组件： beforeDestroy(销毁前，组件实例还在，可用于定时器或订阅器的取消), destroyed(组件已销毁，可用于定时器或订阅器的取消)

### 组件化基础

#### 使用Vue.component()创建子组件
```js
// 创建组件时，建议使用-命名
Vue.component('my-component', {
    props: {
        courses: {
            type: Array,
            default: []
        }
    },
    data: function () {
        return {
            selectedCourse: ''
        }
    }
    template: `<div>{{ selectedCourse }}</div>`
})
// 使用子组件
// <my-component></my-component>
```
第一个参数是组件名，第二个参数是创建Vue实例时的属性选项(option)

#### 自定义事件及监听
子组件和父组件进行通信，可以派发并监听自定义事件。
使用this.$emit('my-event', params)

#### 在组件上使用v-model
自定义组件支持v-model需要组件内部实现input的:value和@input
```js
// <my-component v-model="mydata"></mycomponent>
// v-model其实是语法糖，它等价于如下写法
// <my-component :value="mydata" @input="mydata=$event"></my-component>
// 子组件内部传入value，并派发input事件
Vue.component('my-component', {
    props: ['value'],
    template: 
        `<div>
            <input type="text" :value="value" @input="inputEvent">
        </div>`,
    methods: {
        inputEvent(e) {
            this.$emit('input', e.target.value)
        }
    }
})
```
#### slot通过插槽进行内容分发
通过slot元素可以给子组件传递内容
默认插槽
具名插槽
作用域插槽 (插槽props)
```js
    Vue.component('message', {
        props: ['show'],
        template: 
            `<div v-if="show">
                <slot></slot>
                <slot name="title" title="来自于子组件的title">默认标题</slot>
                <span @click="$emit('update:show', false)">X</span>
            </div>`
    })

    // 使用message组件,使用事件修饰符.sync
    /*
        <message :show.sync="show">
            <template v-slot:default> hello world</template>
            <template v-slot:title="slotProps">
                haha {{slotProps.title}}
            </template>
        </message>
    */
```
#### 组件化总结
组件化是Vue的精髓，Vue应用由一个个组件构成。
定义：组件就是可复用的Vue实例，准确的说他们是Vue.component的实例，继承自Vue。
优点：组件化增加代码的可复用性，可维护性和可测试性
使用场景： 什么时候使用场景
* 通用组件： 实现最基本的功能，具有通用性，复用性，例如按钮组件，输入组件，布局组件 等。
* 业务组件： 他们完成具体业务，具有一定的复用性，例如登录组件，注册组件。
* 页面组件： 组织应用各部分独立内容，需要时在不同的页面间切换，例如列表页，详情页组件。
如何使用组件
* 定义： Vue.component(), components选项
* 分类： 有状态组件，functional(函数式组件), abstract
* 通信： props, $emit/$on, provide/inject, $children/$parent/$root/$attrs/$listeners（耦合性强，使用的不多）
* 内容分发： slot元素，template， v-slot
* 优化： is(动态组件)， keep-alive, 异步组件
组件的本质
Vue组件的本质是产生虚拟DOM

### Vue API
#### 数据相关
1. 给对象增加属性。如果对象是响应式的，确保新增属性能触发视图更新
```js
Vue.set(obj, 'attrName', value)
this.$set(obj, 'attrName', value)
```
2. 删除对象的属性。如果对象是响应式的，确保删除能触发视图更新
```js
Vue.delete(obj, 'attrName')
this.$delete(obj, 'attrName')
```

#### 事件相关
事件的监听和派发都是在同一个实例上。虽然写法上是父组件中绑定事件，但是底层Vue处理之后，仍然是同一个实例上做的监听。
1. 监听当前实例上的自定义事件。
```js
// 模板中 @test="func" 
vm.$on('test', function (params) {
    // callback function
})
```
2. 触发当前实例上的事件。附加参数都会传给监听器的回调函数。
```js
vm.$emit('test', 'hello')
```
3. 监听一个自定义事件，但只触发一次，触发之后，监听器就会被移除。
```js
vm.$once('test', function (msg) {
    // callback
})
```
4. 移除自定义事件监听器
```js
vm.$off() // 移除所有事件监听器
vm.$off('test') // 移除该事件所有的监听器
vm.$off('test', callback) // 只移除这个回调的监听器
```
#### 事件总线
通过在Vue原型上添加一个Vue实例作为事件总线，实现组件间相互通信，而且不受组件间层级关系的影响。
```js
// 这样做可以在任意组件中使用this.$bus访问到该Vue实例。
Vue.prototype.$bus = new Vue()

this.$bus.$on('xxx', callback)
this.$bus.$emit('xxx', value)
```
5. 组件或元素的引用
ref属性被用来给元素或者子组件注册引用信息，引用信息将会注册在父组件的vm.$refs对象上。
如果在普通的DOM元素上使用，引用指向的就是DOM元素，如果是子组件上使用，引用就指向组件。 

注意 ref是作为渲染结果被创建的，在初始渲染时不能访问它们，最早只能在mounted里面。
$refs 不是响应式的，不要试图用它在模板中做数据绑定。
当v-for用于元素或组件时，引用信息将是包含DOM节点或组件实例的数组。
```js
// <span ref="xxx"></span>
this.$refs.xxx
```
### Vue扩展知识
#### 过度和动画
Vue 在插入，更新或移除DOM时，提供了多种不同方式的应用过度效果。
包括以下工具： 
* 在CSS过度和动画中自动应用class
* 配合第三方CSS动画库，如Animate.css
* 在过度钩子函数中使用JavsScript直接操作DOM
* 配合使用第三方JS动画库，如Velocity.js

1. CSS过度动画
transition组件为嵌套元素
```js
/* 
1. v-enter ：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移 除。
2. v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移 除。
3. v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。
4. v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
5. v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。
6. v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。
    fade-enter 入场前的动画
    fade-enter-active 入场动画
    fade-leave-to 离场的最后
    fade-leave-active 进入离场

    <transition name="fade">
        <div class="fade-enter">
        </div>
    </transition>
*/
```
* v-enter
v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。
```
.fade-enter {
    opacity: 0;
}
```
* v-enter-active
v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移除。
```
.fade-enter-active { transition: opacity .5s; }
```
* v-enter-to
v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。
```
.fade-enter-to { opacity: 1; }
```
* v-leave
 v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
 ```
.fade-leave { opacity: 1; }
 ```
 * v-leave-active
 v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。
 ```
.fade-leave-active { transition: opacity .5s; }
 ```
 * v-leave-to
 v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。
 ```
 .fade-leave-to { opacity: 0; }
 ```

 2. 使用CSS动画库
 通过自定义过度类名可以有效结合Animate.css这类动画库制作更精美的动画效果。
 引入animate.css
 ```
 <link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">
 ```
 在transition中使用animate中的class
 ```
<transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut"></transition>
 ```
 3. JavaScript 钩子
 可以在transition中生命JavaScript钩子，使用JS实现动画。

 ```
 <transition 
    @before-enter="beforeEnter"
    @enter="enter"
    @before-leave="beforeLeave"
    @leave="leave"
 >
 </transition>

// JS钩子
methods: {
    beforeEnter(el) {
        // 动画初始化状态
        el.style.opacity = 0
    },
    enter(el, done) {
        // 触发回流激活动画
        document.body.offsetHeight
        // 动画结束状态
        el.style.opacity = 1
        // 监听动画结束事件，并执行done
        el.addEventListener('transitionend', done)
    },
    beforeLeave(el) {
        // 动画初始状态
        el.style.opacity = 1
    },
    leave(el, done) {
        // 触发回流激活动画
        document.body.offsetHeight
        // 动画结束状态
        el.style.opacity = 0
        // 监听动画结束事件，并执行done
        el.addEventListener('transitionend', done)
    }
}
 ```

 3. 纯JS方案
 引入velocity.js
 ```
<script src="https://cdnjs.cloundflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
 ```
 使用velocity
 ```
 // JS钩子
methods: {
    beforeEnter(el) {
        // 动画初始化状态
        el.style.opacity = 0
    },
    enter(el, done) {
        Velocity(el, { opacity:1 }, { duration: 1500, complete: done })
    },
    beforeLeave(el) {
        // 动画初始状态
        el.style.opacity = 1
    },
    leave(el, done) {
        Velocity(el, { opacity: 0 }, { duration: 1500, complete: done})
    }
}
 ```

 4. 列表过度
 利用transition-group元素可以对v-for渲染的每个元素应用过度
 ```
<transition-group name="fade">
    <div v-for="c in courses" :key="c.name">
        {{ c.name }} - ￥{{c.price}}<button @click="addToCart(c)">加购</button>
    </div>
</transition-group>
 ```

#### 过滤器
Vue允许自定义过滤器，可以被用于一些常见的文本格式化。过滤器可以用在{{}} 和v-bind表达式。
注意管道符左边的值作为过滤器的第一个参数， ()中的第一个参数是过滤器的第二个参数。
```
<!-- 全局定义过滤器 -->
Vue.filter('currency', function (val, symbol = '$') {
    return symbol + val
})
<!-- 局部定义过滤器 -->
filters: {
    currency(val, symbol = '$') {
        return symbol + val
    }
}
<!-- 在插值中使用 -->
{{ money | capitalize(symbol) }}
<!-- 在 v-bind 中使用 -->
<div v-bind:id="rawId | formatId"></div>
```
#### 自定义指令
当我们仍然需要对DOM元素进行多次相同的底层操作时，就会用到自定义指令。(提高复用性)
```
<!-- 全局定义自定义指令 -->
Vue.directive('focus', {
    inserted(el, binding) {
        el.focus()
    }
})
<!-- 使用自定义指令 -->
<input v-focus>
```
自定义指令有如下几个钩子函数可以使用：
bind
inserted
update
componentUpdated
unbind
参数：el触发事件的元素, binding对象

#### 渲染函数
Vue推荐使用模板来创建html，但在一些特殊场景下，必须使用js，来用程序的方式控制。这时可以使用渲染函数。
```
render: function (createElement) {
    // createElement函数返回结果是VNode
    return createElement(
        tag, // 标签名称
        data, // 传递数据
        children //子节点数组
    )
}
```
使用render实现heading组件
```
Vue.component('heading', {
    props: ['level', 'title'],
    render(h) {
        return h('h'+this.level, children)
    }
})
```
#### 虚拟DOM
虚拟DOM的底层实现使用的是snabbdom， 在snabbdom中就是用的h作为createElement函数的名字，所以这里也用h。
Vue通过建立一个虚拟DOM来追踪自己要如何改变真实DOM。
createElement函数中的参数。
```
render: function (createElement) {
    // createElement函数返回结果是VNode
    return createElement(
        tag, // 标签名称，一个 HTML 标签名、组件选项对象。
        data, // 传递数据，一个与模板中属性对应的数据对象。
        children // 子节点数组，子级虚拟节点 (VNodes)，由 `createElement()` 构建而成
    )
}
```
#### 函数式组件
组件没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法时，可以将组件标记为functional，这意味着它无状态(没有响应式数据)，也没有实例(没有this上下文)。
```
Vue.component('heading', {
    functional: true, // 函数式组件
    props: ['level', 'title],
    render(h, context) { // 组件需要的一切都是通过context获取的
        return h()
    }
})
```
#### 混入
混入(mixin)提供了一种非常灵活的方式，来分发Vue组件中的可复用的功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项。
```
// 定义一个混入对象
var myMixin = {
    created: function () {
        this.hello() // this 表示组件实例
    },
    // 公用方法
    methods: {
        hello: function () {
            console.log('hello')
        }
    }
}
// 使用混入对象的组件
Vue.component('comp', {
    mixins: [myMixin]
})
```
选项合并的规则
数据对象(data选项)在内部会进行递归合并，并在发生冲突时以组件数据优先，组件的数据覆盖混入对象中的数据。
同名钩子函数将合并成一个数组，先调用混入对象中的钩子函数，再调用组件中的钩子函数。
值为对象的选项，如methods,components, directives,将被合并为同一个对象，两个对象中键名冲突时，取组件对象的键值对。

#### 插件
插件通常用来为Vue添加全局功能。插件的功能范围有以下几种：
1. 添加全局方法或者属性。如vue-custom-element
2. 添加全局资源：指令/过滤器/过渡等。如vue-touch
3. 通过全局混入来添加一些组件选项。如vue-router
4. 添加Vue实例方法，通过把他们添加到Vue.prototype上实现。
5. 一个库，提供自己的API，同时提供上面提到的一个或多个功能。如vue-router

插件声明
Vue的插件生命应该暴露一个install方法。这个方法的第一个参数是Vue构造函数，第二个参数是一个可选的选项对象。
```
myPlugin.install = function (Vue, options) {
    // 1. 添加全局方法或属性
    Vue.myGlobalMethod = function () {}
    // 2. 添加全局资源
    Vue.directive('my-directive', {})
    // 3. 注入组件选项
    Vue.mixin({})
    // 4. 添加实例方法
    Vue.prototype.$myMethod = function (methodOptios) {}
}
```
插件使用
使用Vue.use()引入插件
修改heading组件为插件，通过插件的方式去分发,更加便捷。
```
const MyPlugin = {    
    install (Vue, options) {
        Vue.component('heading', {...})
    }
}
if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(MyPlugin)
}
```

### 工程化
使用Vue-cli脚手架
```
npm install -g @vue/cli
vue --version
```
#### 快速原型开发
vue serve 和 vue build命令对单个.vue文件进行快速原型开发。不过这需要先额外安装一个全局的扩展：@vue/cli-service-global.
vue serve 的缺点就是它需要安装全局依赖，这使得它在不同机器上的一致性不能得到保证。因此这只适用于快速原型开发。
```
// 安装@vue/cli-service-global扩展
npm install -g @vue/cli-service-global
```
#### vue serve
启动一个服务并运行一个原型
```
vue serve hello.vue
```
#### 创建项目
创建一个vue项目
```
vue create my-vue-project
```

vue-10-01-end