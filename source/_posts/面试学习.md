---
title: 面试学习
date: 2020-06-05 13:24:20
tags:
---

# VS Code 使用
## 调试
F5启动调试，默认支持Node调试。

## 网页调试
安装Debugger for Chrome扩展，基本配置如下。
```js
//  launch.js启动调试的配置文件
{ 
    "version": "0.2.0",
    "configurations": [
        { 
            "name": "Launch localhost",
            "type": "chrome",
            "request": "launch",            
            "url": "http://localhost:8080/",
            "webRoot": "${workspaceFolder}/wwwroot" //默认index.html的文件夹位置, workspaceFolder 是当前.vscode所在的文件夹
        }
    ]
}

```
安装http-server, 并启动
```bash
npm i http-server -g
http-server
```
然后按F5，选择使用Chrome，就可以使用Chrome进行调试html中的js文件。

## VS Code集成Git
### 下载 git
```bash
sudo apt-get install git
```
### 使用git
1. 命令行使用git命令
2. 命令面板：ctrl+shift+P 
3. 克隆 git:clone  --> enter url
4. 将本地工作区文件夹 变为 git 本地仓库
5. 添加远程仓库 git:add remote --> enter remote name --> enter remote url
6. git add
7. git commit
8. git push
9. git pull

## 安装Node

## 安装扩展
### vue-vscode-snippets
生成代码片段的快捷方式
### vetur
语法高亮，代码片段，错误检查

# Vue学习
## Vue 核心思想简介
Vue 核心思想：1.数据驱动应用 2.MVVM模式(Model, View, VirtualModel)

MVVM框架的三要素： 数据响应式， 模板引擎(模板 -> VNode)， 渲染(VNode -> DOM)

响应式： Vue如何监听数据变化？数据变化更新视图， 视图变化更新数据。
模板： Vue模板如何编写和解析。
渲染： Vue如何将模板转换为html。

## Vue 核心知识点
### 插值文本 
```js
{{}}
```
### 数据绑定指令 
v-bind:attr，缩写 :attr
### 列表渲染指令 
v-for=(item of array) 注意要绑定key属性(:key='item.id')。
### 数据双向绑定指令
v-model 指令使用在表单元素 input, select, option等。
### 事件处理指令
v-on 指令监听DOM事件或传递自定义事件到子组件，触发时调用回调函数。
v-on:click="clickFunc", 缩写：:click="clickFunc"。
事件修饰符，按键修饰符。
### class和style绑定
```js
:class="{active: condition === true}"
:style="{backgroundColor: isBlue ? 'blue' : 'purple'}"
```
active为class，后面的属性值是表达式的计算结果，表示是否添加active这个class。
还可以是一个数组，里面就要设置的一个个样式的className。
### 条件渲染
v-if="isExists" 控制元素是否真实的渲染
v-if=""
v-else-if=""
v-else
注意v-if不能和v-for在同一个标签上，v-for的优先级比v-if高。

v-show="" 通过控制css属性display控制元素显示，但是元素总是存在的。
v-if惰性渲染元素，如果一开始条件就是falsy，那么元素就是不存在的，并不会渲染。

### Vue对模板的处理
Vue将模板编译成 虚拟DOM渲染函数，然后渲染函数会将VNode渲染成DOM。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。
实际上Vue内部，实际上是将模板转换成了render函数。
```js
console.log(app.$options.render)

// 这就是生成的模板渲染函数(render函数)
(function anonymous() {with(this){return _c('div',{attrs:{"id":"app"}},[_c('h2',{attrs:{"title":title}},[_v("\n            "+_s(title)+"\n        ")]),_v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(course),expression:"course"}],attrs:{"type":"text"},domProps:{"value":(course)},on:{"keydown":function($event){if(!$event.type.indexOf('key')&&_k($event.keyCode,"enter",13,$event.key,"Enter"))return null;return addCourse($event)},"input":function($event){if($event.target.composing)return;course=$event.target.value}}}),_v(" "),_c('button',{on:{"click":addCourse}},[_v("新增课程")]),_v(" "),(courses.length == 0)?_c('p',[_v("没有任何课程信息")]):_e(),_v(" "),_c('ul',_l((courses),function(c){return _c('li',{class:{active: (selectedCourse === c)},on:{"click":function($event){selectedCourse = c}}},[_v(_s(c))])}),0)])}})
```
### 计算属性和监听器
computed属性,计算属性有缓存性，只有依赖的数据变化了，才会去重新计算，重新渲染页面。
watch属性,默认情况下watch初始化时，不会执行，只有数据变化了，才会执行到watch里面的函数，但是通过配置immediate属性可以让watch立即执行。

watch和computed的差异
watch适用于一个值变化了，影响多个值的情形。一个值的变化引起很多事件的处理。当在数据变化时需要执行异步操作或者较大开销的操作情况更适合使用watch。
computed适用于多个值变化了，影响一个值的情形。
```js
const vm = new Vue({
    el: '#app',
    data: function () {return {
        title: 'hello',
        name: 'Vue'
    }},
    computed: {
        getName: function () {
            return this.title === 'hello' ? 'world' : 'vue'
        }
    }，
    watch: {
        title: function (newV, oldV) {
            // block
        },
        name: {
            immediate: true, // 立即执行
            // deep: true, 深层的监听
            handler: function (newV, oldV) {
                // block
            }
        }
    }
})
```

### 生命周期
每一个Vue实例创建时都要经过一系列的初始化过程： 设置数据监听， 编译模板， 将实例挂载到DOM，并在数据变化的时候更新DOM等，称为Vue实例的生命周期。
#### 使用生命周期钩子函数
在Vue实例的生命周期的过程中会运行一些叫做生命周期的钩子函数，可以在不同的阶段添加自己代码。
```js
beforeCreate() {}
created() {} //在生命周期钩子函数中使用data中的数据时，最早只能在created中，此时能使用data中的数据，但此时还没有挂载，还没有DOM，还不能操作DOM
beforeMount() {}
mounted() {} // 这mounted中，DOM已经生成，可以操作DOM。
```

生命周期四个阶段及使用场景
初始化数据： beforeCreate(组件实例还未创建，数据还没有准备好，通常用于插件开发中执行一些初始化任务), created(组件初始化完毕，各种数据可以使用，常用于异步数据获取) 
挂载组件:   beforeMount(未执行渲染，dom没有创建), mounted(dom创建完毕，可以用于获取访问数据和dom元素)
更新组件： beforeUpdate(更新前，可用于获取更新前的各种状态), updated(更新后，所有状态已是最新)
销毁组件： beforeDestroy(销毁前，组件实例还在，可用于定时器或订阅器的取消), destroyed(组件已销毁，可用于定时器或订阅器的取消)

### 组件化基础

#### 使用Vue.component()创建子组件
```js
// 创建组件时，建议使用-命名
Vue.component('my-component', {
    props: {
        courses: {
            type: Array,
            default: []
        }
    },
    data: function () {
        return {
            selectedCourse: ''
        }
    }
    template: `<div>{{ selectedCourse }}</div>`
})
// 使用子组件
// <my-component></my-component>
```
第一个参数是组件名，第二个参数是创建Vue实例时的属性选项(option)

#### 自定义事件及监听
子组件和父组件进行通信，可以派发并监听自定义事件。
使用this.$emit('my-event', params)

#### 在组件上使用v-model
自定义组件支持v-model需要组件内部实现input的:value和@input
```js
// <my-component v-model="mydata"></mycomponent>
// v-model其实是语法糖，它等价于如下写法
// <my-component :value="mydata" @input="mydata=$event"></my-component>
// 子组件内部传入value，并派发input事件
Vue.component('my-component', {
    props: ['value'],
    template: 
        `<div>
            <input type="text" :value="value" @input="inputEvent">
        </div>`,
    methods: {
        inputEvent(e) {
            this.$emit('input', e.target.value)
        }
    }
})
```
#### slot通过插槽进行内容分发
通过slot元素可以给子组件传递内容
默认插槽
具名插槽
作用域插槽 (插槽props)
```js
    Vue.component('message', {
        props: ['show'],
        template: 
            `<div v-if="show">
                <slot></slot>
                <slot name="title" title="来自于子组件的title">默认标题</slot>
                <span @click="$emit('update:show', false)">X</span>
            </div>`
    })

    // 使用message组件,使用事件修饰符.sync
    /*
        <message :show.sync="show">
            <template v-slot:default> hello world</template>
            <template v-slot:title="slotProps">
                haha {{slotProps.title}}
            </template>
        </message>
    */
```
#### 组件化总结
组件化是Vue的精髓，Vue应用由一个个组件构成。
定义：组件就是可复用的Vue实例，准确的说他们是Vue.component的实例，继承自Vue。
优点：组件化增加代码的可复用性，可维护性和可测试性
使用场景： 什么时候使用场景
* 通用组件： 实现最基本的功能，具有通用性，复用性，例如按钮组件，输入组件，布局组件 等。
* 业务组件： 他们完成具体业务，具有一定的复用性，例如登录组件，注册组件。
* 页面组件： 组织应用各部分独立内容，需要时在不同的页面间切换，例如列表页，详情页组件。
如何使用组件
* 定义： Vue.component(), components选项
* 分类： 有状态组件，functional(函数式组件), abstract
* 通信： props, $emit/$on, provide/inject, $children/$parent/$root/$attrs/$listeners（耦合性强，使用的不多）
* 内容分发： slot元素，template， v-slot
* 优化： is(动态组件)， keep-alive, 异步组件
组件的本质
Vue组件的本质是产生虚拟DOM

### Vue API
#### 数据相关
1. 给对象增加属性。如果对象是响应式的，确保新增属性能触发视图更新
```js
Vue.set(obj, 'attrName', value)
this.$set(obj, 'attrName', value)
```
2. 删除对象的属性。如果对象是响应式的，确保删除能触发视图更新
```js
Vue.delete(obj, 'attrName')
this.$delete(obj, 'attrName')
```

#### 事件相关
事件的监听和派发都是在同一个实例上。虽然写法上是父组件中绑定事件，但是底层Vue处理之后，仍然是同一个实例上做的监听。
1. 监听当前实例上的自定义事件。
```js
// 模板中 @test="func" 
vm.$on('test', function (params) {
    // callback function
})
```
2. 触发当前实例上的事件。附加参数都会传给监听器的回调函数。
```js
vm.$emit('test', 'hello')
```
3. 监听一个自定义事件，但只触发一次，触发之后，监听器就会被移除。
```js
vm.$once('test', function (msg) {
    // callback
})
```
4. 移除自定义事件监听器
```js
vm.$off() // 移除所有事件监听器
vm.$off('test') // 移除该事件所有的监听器
vm.$off('test', callback) // 只移除这个回调的监听器
```
#### 事件总线
通过在Vue原型上添加一个Vue实例作为事件总线，实现组件间相互通信，而且不受组件间层级关系的影响。
```js
// 这样做可以在任意组件中使用this.$bus访问到该Vue实例。
Vue.prototype.$bus = new Vue()

this.$bus.$on('xxx', callback)
this.$bus.$emit('xxx', value)
```
5. 组件或元素的引用
ref属性被用来给元素或者子组件注册引用信息，引用信息将会注册在父组件的vm.$refs对象上。
如果在普通的DOM元素上使用，引用指向的就是DOM元素，如果是子组件上使用，引用就指向组件。 

注意 ref是作为渲染结果被创建的，在初始渲染时不能访问它们，最早只能在mounted里面。
$refs 不是响应式的，不要试图用它在模板中做数据绑定。
当v-for用于元素或组件时，引用信息将是包含DOM节点或组件实例的数组。
```js
// <span ref="xxx"></span>
this.$refs.xxx
```
### Vue扩展知识
#### 过度和动画
Vue 在插入，更新或移除DOM时，提供了多种不同方式的应用过度效果。
包括以下工具： 
* 在CSS过度和动画中自动应用class
* 配合第三方CSS动画库，如Animate.css
* 在过度钩子函数中使用JavsScript直接操作DOM
* 配合使用第三方JS动画库，如Velocity.js

1. CSS过度动画
transition组件为嵌套元素
```js
/* 
1. v-enter ：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移 除。
2. v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移 除。
3. v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。
4. v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
5. v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。
6. v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。
    fade-enter 入场前的动画
    fade-enter-active 入场动画
    fade-leave-to 离场的最后
    fade-leave-active 进入离场

    <transition name="fade">
        <div class="fade-enter">
        </div>
    </transition>
*/
```
* v-enter
v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。
```
.fade-enter {
    opacity: 0;
}
```
* v-enter-active
v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移除。
```
.fade-enter-active { transition: opacity .5s; }
```
* v-enter-to
v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。
```
.fade-enter-to { opacity: 1; }
```
* v-leave
 v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
 ```
.fade-leave { opacity: 1; }
 ```
 * v-leave-active
 v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。
 ```
.fade-leave-active { transition: opacity .5s; }
 ```
 * v-leave-to
 v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。
 ```
 .fade-leave-to { opacity: 0; }
 ```