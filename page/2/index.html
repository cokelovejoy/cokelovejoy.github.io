<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>RICHARD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Technology Blog">
<meta name="keywords" content="Python, JS, Vue, NodeJS">
<meta property="og:type" content="website">
<meta property="og:title" content="RICHARD">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="RICHARD">
<meta property="og:description" content="Technology Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RICHARD">
<meta name="twitter:description" content="Technology Blog">
  
    <link rel="alternate" href="/atom.xml" title="RICHARD" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RICHARD</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RICHARD BLOG</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-webpack4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/13/webpack4/" class="article-date">
  <time datetime="2020-08-13T15:14:35.000Z" itemprop="datePublished">2020-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/13/webpack4/">webpack4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="如何自己编写一个loader"><a href="#如何自己编写一个loader" class="headerlink" title="如何自己编写一个loader"></a>如何自己编写一个loader</h1><h1 id="如何自己编写一个Plugin"><a href="#如何自己编写一个Plugin" class="headerlink" title="如何自己编写一个Plugin"></a>如何自己编写一个Plugin</h1><h1 id="webpack原理"><a href="#webpack原理" class="headerlink" title="webpack原理"></a>webpack原理</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/13/webpack4/" data-id="ckh5zzyq1001fq4v2pyb9qyzw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/12/JS基础/" class="article-date">
  <time datetime="2020-08-11T16:55:50.000Z" itemprop="datePublished">2020-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/12/JS基础/">JS基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>现象：所有的变量的声明会被提升到代码的开头，这就叫做变量提升(hoisting)。<br>原理：JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>MDN解释：闭包是函数和声明该函数的词法环境的组合。<br>简单理解：闭包 = 函数 + 函数内可访问的变量总和</p>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>闭包最⼤的作⽤就是隐藏变量，闭包的⼀⼤特性就是内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</p>
<p>基于此特性。JS可以实现私有变量，特权变量，储存变量。</p>
<h2 id="JS的作用域链"><a href="#JS的作用域链" class="headerlink" title="JS的作用域链"></a>JS的作用域链</h2><p>JavaScript属于静态作⽤域，即声明的作⽤域是根据程序正⽂在编译时就确定的，有时也称为词法作⽤域。</p>
<p>其本质是JavaScript在执⾏过程中会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们 可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了作⽤域链。</p>
<h2 id="ES6-模块和CommonJS模块"><a href="#ES6-模块和CommonJS模块" class="headerlink" title="ES6 模块和CommonJS模块"></a>ES6 模块和CommonJS模块</h2><p>区别：</p>
<ol>
<li><p>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤,即ES6    Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const 。</p>
</li>
<li><p>import的接⼝是read-only（只读状态），不能修改其变量值。    即不能修改其变量的指针指向，但可以改变变量内部 指针指向,可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。</p>
</li>
</ol>
<p>共同点：CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</p>
<h2 id="JS有哪些数据类型？"><a href="#JS有哪些数据类型？" class="headerlink" title="JS有哪些数据类型？"></a>JS有哪些数据类型？</h2><p>原始类型，引用类型。<br>原始类型： null, undefined, boolean, number, string, symbol。<br>引用类型： Object。</p>
<h3 id="null与undefined区别"><a href="#null与undefined区别" class="headerlink" title="null与undefined区别"></a>null与undefined区别</h3><p>null表示空，代表此处没有值。typeof null 为 object。<br>undefined表示不存在，代表值为空值或者根本不存在。因为存不存在只在运行期才直到，这就是undefined的意义所在。</p>
<h2 id="0-1-0-2-为什么不等于0-3"><a href="#0-1-0-2-为什么不等于0-3" class="headerlink" title="0.1+0.2 为什么不等于0.3"></a>0.1+0.2 为什么不等于0.3</h2><p>JS number类型 使用IEEE 754标准，使用的是64位固定长度来表示。</p>
<ol>
<li>在0.1转换为二进制表示</li>
<li>再将二进制通过科学计数法表示</li>
<li>将通过科学计数法表示的二进制转换为IEEE 754标准表示时，发现值已经变了，从而导致计算精度出现问题。<br>并不只是JS有这个问题，使用IEEE 754标准表示浮点数都有这个问题。<h2 id="JS类型转换的规则有哪些？"><a href="#JS类型转换的规则有哪些？" class="headerlink" title="JS类型转换的规则有哪些？"></a>JS类型转换的规则有哪些？</h2>if语句，逻辑语句，数学逻辑运算符， == 等情况下都会出现 隐式类型转化。<br>类型只会转换为数字，布尔和字符串三种类型。<br>为false的情况：null, undefined, 0, NAN, “”, false,除此之外全为true。</li>
</ol>
<p>js内部引用类型转换成原始类型会调用ToPrimitive方法</p>
<h2 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h2><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>每一个构造函数都有一个属性prototype叫做原型对象，原型对象上的属性和方法为该构造函数创建的实例所共用。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>每个实例都有<strong>proto</strong>属性，此属性指向该对象的构造函数的原型。<br>实例对象通过<strong>proto</strong>找到上游的构造函数的原型对象，上游的原型对象也有<strong>proto</strong>属性，这样就形成了原型链。<br>原型链的顶层是Object，Object的<strong>proto</strong>属性指向null。<br>实例的constructor 属性返回该实例对象的构造函数。</p>
<h2 id="判断是否是数组"><a href="#判断是否是数组" class="headerlink" title="判断是否是数组"></a>判断是否是数组</h2><p>ES6:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(value)</span><br></pre></td></tr></table></figure>

<p>非ES6:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">    <span class="comment">// code block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>默认情况下，this指向全局对象，比如在浏览器就是指向window。<br>this的指向问题总结一句话就是谁调用指向谁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj中调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"coke"</span>，</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">// this指向obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name <span class="comment">// this指向实例对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> coke = <span class="keyword">new</span> Foo(<span class="string">'coke'</span>)</span><br></pre></td></tr></table></figure>

<p>改变this指向的常见方法：call，apply，bind。<br>call 接受一个个参数，apply接受一个参数数组，bind返回一个新函数。</p>
<h2 id="箭头函数的this指向哪里"><a href="#箭头函数的this指向哪里" class="headerlink" title="箭头函数的this指向哪里"></a>箭头函数的this指向哪里</h2><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this,它的所谓的this是捕获其所在上下⽂的    this 值，作为⾃⼰的    this值,并且由于没有属于⾃⼰的this,⽽箭头函数是不会被new调⽤的，这个所谓的this也不会被改变.</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async函数，就是    Generator函数的语法糖，它建⽴在Promise上，并且与所有现有的基于Promise的API兼容。</p>
<ol>
<li>async 声明一个异步函数</li>
<li>自动将常规函数转换成Promise，返回值也是Promise对象。</li>
<li>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>
<li>await必须在async声明的函数内部使用。</li>
<li>await强制代码等待，直到异步操作完成并返回结果。</li>
<li>await只能和Promise一起使用，不适用于回调。</li>
<li>await 不适合用于forEach,map,filter,reduce，可以在for循环中使用或者没有回调的循环。</li>
</ol>
<h2 id="async-await相比于Promise的优势"><a href="#async-await相比于Promise的优势" class="headerlink" title="async/await相比于Promise的优势"></a>async/await相比于Promise的优势</h2><ol>
<li>更像同步代码，Promise的then的调用有额外的阅读负担</li>
<li>Promise 传递中间值非常麻烦，而async/await写法类似同步代码。</li>
<li>错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余。</li>
<li>Promise不好调试，步进功能无法进入then。</li>
</ol>
<h2 id="JS参数传递方式"><a href="#JS参数传递方式" class="headerlink" title="JS参数传递方式"></a>JS参数传递方式</h2><p>基本类型数据按值传递<br>引用类型按共享传递</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x.a = <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line">test(obj) <span class="comment">// &#123;a:10,b:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;a:10,b:2&#125;</span></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line">test(obj) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;a:1,b:2&#125;</span></span><br></pre></td></tr></table></figure>

<p>出现上述代码中的情况是因为传递参数的时候，会生成一个副本obj，这个副本指向了参数x的内存地址。当给这个副本变量整个重新赋值的时候，引用的指向就改变了。当改变这个副本变量下的属性的值的时候，就会去操作引用指向的内存中的值，同时外部变量obj的值也会受到影响，因为它们属于同一的内存地址下的数据。</p>
<h2 id="JS-实现不可变对象"><a href="#JS-实现不可变对象" class="headerlink" title="JS 实现不可变对象"></a>JS 实现不可变对象</h2><ol>
<li>深克隆，但是深克隆的性能⾮常差，不适合⼤规模使⽤ </li>
<li>Immutable.js，Immutable.js是⾃成⼀体的⼀套数据结构，性能良好，但是需要学习额外的API </li>
<li>immer，利⽤Proxy特性，⽆需学习额外的api，性能良好</li>
</ol>
<h2 id="JS的基本类型和复杂类型是存储在哪里？"><a href="#JS的基本类型和复杂类型是存储在哪里？" class="headerlink" title="JS的基本类型和复杂类型是存储在哪里？"></a>JS的基本类型和复杂类型是存储在哪里？</h2><p>基本类型存储在栈中，但是一旦被闭包引用则成为常住内存，会存储在内存堆中。<br>复杂类型会存储在内存堆中。</p>
<h2 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/12/JS基础/" data-id="ckh5zzyot0008q4v2gr3uzn4n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/webpack3/" class="article-date">
  <time datetime="2020-08-10T07:55:54.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/webpack3/">webpack3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="webpack-性能优化"><a href="#webpack-性能优化" class="headerlink" title="webpack 性能优化"></a>webpack 性能优化</h1><p>webpack性能优化主要在两个方面：优化开发体验和优化输出质量</p>
<h2 id="优化开发体验"><a href="#优化开发体验" class="headerlink" title="优化开发体验"></a>优化开发体验</h2><ol>
<li>提高开发效率</li>
<li>提高构建速度</li>
</ol>
<h2 id="优化输出质量"><a href="#优化输出质量" class="headerlink" title="优化输出质量"></a>优化输出质量</h2><ol>
<li>优化要发布到线上的代码，减少用户能感知到的加载时间。</li>
<li>提升代码性能，性能好，执行就快。</li>
</ol>
<h2 id="缩小文件范围"><a href="#缩小文件范围" class="headerlink" title="缩小文件范围"></a>缩小文件范围</h2><h3 id="优化loader配置"><a href="#优化loader配置" class="headerlink" title="优化loader配置"></a>优化loader配置</h3><p>test，include，exclude三个配置项来缩小loader的处理范围。推荐include。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include： path.resolve(__dirname, <span class="string">"./src"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="优化resolve-modules配置"><a href="#优化resolve-modules配置" class="headerlink" title="优化resolve.modules配置"></a>优化resolve.modules配置</h3><p>resolve.modules用于配置webpack去哪些目录下寻找第三方模块，默认是node_modules.</p>
<p>默认是在当前项目目录下的node_modules里面去找，如果没有找到，就会去上一级目录../node_modules去找，再没有会去../../node_modules中去找，以此类推。和NodeJs的模块查找机制很类似。</p>
<p>如果我们的第三方模块都安装在了项目的根目录下，就可以直接指明这个路径,节省了查找的时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        modules: [path.resolve(__dirname, <span class="string">"./node_modules"</span>)]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化resolve-alias配置"><a href="#优化resolve-alias配置" class="headerlink" title="优化resolve.alias配置"></a>优化resolve.alias配置</h3><p>resolve.alias配置通过别名来将原导入路径映射成一个新的导入路径。<br>以react为例，引入react库，一般存在两套代码cjs，umd。默认情况下，webpack会从入口文件./node_modules/bin/react/index开始递归解析和处理依赖的文件。我们可以直接指定文件，避免查找耗时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">    <span class="string">"@"</span>: path.join(__dirname, <span class="string">"./pages"</span>),</span><br><span class="line">    react: path.resolve(__dirname, <span class="string">"./node_modules/react/umd/react.production.min.js"</span>),</span><br><span class="line">    <span class="string">"react-dom"</span>: path.resolve(__dirname, <span class="string">"./node_modules/react-dom/umd/react-dom.production.min.js"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化resolve-extensions配置"><a href="#优化resolve-extensions配置" class="headerlink" title="优化resolve.extensions配置"></a>优化resolve.extensions配置</h3><p>resolve.extensions在导入语句没带文件后缀时，webpack会自动带上后缀后，去尝试查找文件是否存在。<br>默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extensions: [<span class="string">'js'</span>, <span class="string">'json'</span>, <span class="string">'jsx'</span>, <span class="string">'ts'</span>]</span><br></pre></td></tr></table></figure>

<p>优化策略： 后缀名尝试列表尽量的小，导入语句尽量带上后缀名。</p>
<h2 id="使用静态资源路径publicPath-CDN"><a href="#使用静态资源路径publicPath-CDN" class="headerlink" title="使用静态资源路径publicPath(CDN)"></a>使用静态资源路径publicPath(CDN)</h2><p>CDN通过将资源部署到世界各地,使得用户可以就近访问资源,加快访问速度。要接入CDN,需要把网⻚的静态资源上传到CDN服务上,在访问这些<br>资源时,使用CDN服务提供的URL。<br>两个必备条件： 公司得有cdn服务器地址，确保静态资源文件的上传。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    publicPatch: <span class="string">"//cdnURL.com"</span>, <span class="comment">// 指定存放JS文件的CDN地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSS文件的处理"><a href="#CSS文件的处理" class="headerlink" title="CSS文件的处理"></a>CSS文件的处理</h2><p>使用less 或 sass当作css技术栈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader -D</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>, <span class="string">"less-loader"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用postcss为样式自动补齐浏览器前缀</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>

<p>新建postcss.config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">"autoprefixer"</span>)(&#123;<span class="attr">overrideBrowserslist</span>: [<span class="string">"last 2 versions"</span>, <span class="string">"&gt;1%"</span>]&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建index.less</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    include: path.resolve(__dirname, <span class="string">"./src"</span>),</span><br><span class="line">    use: [</span><br><span class="line">        <span class="string">"style-loader"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">"css-loader"</span>,</span><br><span class="line">            options: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"less-loader"</span>,</span><br><span class="line">        <span class="string">"postcss-loader"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="借助MiniCssExtractPlugin完成抽离css"><a href="#借助MiniCssExtractPlugin完成抽离css" class="headerlink" title="借助MiniCssExtractPlugin完成抽离css"></a>借助MiniCssExtractPlugin完成抽离css</h2><p>如果不做抽取配置，我们的css是直接打包进js里面的，我们希望能单独生成css文件。因为单独生成css，css可以和js并行下载，提高页面加载效率。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm i mini-css-extract-plugin -D</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        MiniCssExtractPlugin.loader, <span class="comment">// 代替style-loader</span></span><br><span class="line">        <span class="string">"css-loader"</span>,     <span class="comment">// 编译css</span></span><br><span class="line">        <span class="string">"postcss-loader"</span>, <span class="comment">//自动补齐浏览器前缀</span></span><br><span class="line">        <span class="string">"sass-loader"</span>     <span class="comment">// 编译scss</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">"css/[name]_[contenthash:6].css"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].css"</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h2><p>借助optimize-css-assets-webpack-plugin<br>借助cssnano</p>
<p>安装</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm i cssnano -D</span><br><span class="line">npm i optimize-css-assets-webpack-plugin -D</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">        cssProcessor: <span class="built_in">require</span>(<span class="string">"cssnano"</span>), <span class="comment">// 引入cssnano配置压缩选项</span></span><br><span class="line">        cssProcessorOptions: &#123;</span><br><span class="line">            discardComments: &#123;</span><br><span class="line">                removeAll: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="压缩HTML"><a href="#压缩HTML" class="headerlink" title="压缩HTML"></a>压缩HTML</h2><p>借助html-webpack-plugin</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">    title: <span class="string">"my app"</span>,</span><br><span class="line">    template: <span class="string">"./index.html"</span>,</span><br><span class="line">    filename: <span class="string">"index.html"</span>,</span><br><span class="line">    minify: &#123; <span class="comment">// 压缩HTML文件</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, <span class="comment">// 移除HTML中的注释</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空白符与换行符</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>           <span class="comment">// 压缩内联css</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="development-VS-production模式区分打包"><a href="#development-VS-production模式区分打包" class="headerlink" title="development VS production模式区分打包"></a>development VS production模式区分打包</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装webpack-merge</span></span><br><span class="line">npm i webpack-merge -D</span><br><span class="line"><span class="comment">// 合并通用配置到特定模式 webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">"webpack-merge"</span>)</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">"./webpack.common.js"</span>)</span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, devConfig)</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --config ./build/webpack.dev.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config ./build/webpack.prod.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于环境变量区分"><a href="#基于环境变量区分" class="headerlink" title="基于环境变量区分"></a>基于环境变量区分</h3><p>借助cross-env</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cross-env -D</span><br></pre></td></tr></table></figure>

<p>package里面配置命令脚本，传入参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"test"</span>: <span class="string">"cross-env NODE_ENV=test webpack --config ./webpack.config.test.js"</span></span><br></pre></td></tr></table></figure>

<p>在webpack.config.js里面拿到参数<br>process.env.NODE_ENV</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部传入变量</span></span><br><span class="line">scripts:<span class="string">" --env.production xxx"</span></span><br><span class="line"><span class="comment">// 外部传入的全局变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (env &amp;&amp; env.production) &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(commonConfig, prodConfig)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(commonConfig, devConfig)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>webpack 2.x开始支持tree shaking概念，也就是”摇树”，清除无用的css,js(dead code)。<br>Dead Code 一般具有以下几个特征</p>
<ol>
<li>代码不会被执行，不可到达。</li>
<li>代码执行的结果不会被用到</li>
<li>代码只会影响死变量(只写不读)</li>
</ol>
<h3 id="CSS-Tree-Shaking"><a href="#CSS-Tree-Shaking" class="headerlink" title="CSS Tree Shaking"></a>CSS Tree Shaking</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm i glob-all purify-css purifycss-webpack -D</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="keyword">const</span> PurifyCSS = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 进行css tree shaking</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob-all'</span>)                <span class="comment">// 路径处理，定位要做tree shaking的文件</span></span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="comment">// 清除无用css</span></span><br><span class="line">    <span class="keyword">new</span> PurifyCSS(&#123;</span><br><span class="line">        paths: glob.sync([ <span class="comment">// 要做CSS Tree Shaking的路径文件</span></span><br><span class="line">            path.resolve(__dirname, <span class="string">'./src/*.html'</span>), <span class="comment">// 对html文件进行tree shaking</span></span><br><span class="line">            path.resolve(__dirname, <span class="string">'./src/*.js'</span>)</span><br><span class="line">        ])</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="JS-tree-shaking"><a href="#JS-tree-shaking" class="headerlink" title="JS tree shaking"></a>JS tree shaking</h3><p>只有mode是production才会生效，development的tree shaking是不生效的，因为webpack为了方便调试。生产模式不需要配置，默认开启。<br>只支持import方式引入，不支持commonjs的方式引入。因为JS tree shaking 依赖于ES6的静态分析，在编译时确定模块。如果是require，在运行时确定模块，那么将无法去分析模块是否可用，只有在编译时分析，才不会影响运行时的状态。<br>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expo.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> minus = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">"./expo"</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">optimization: &#123;</span><br><span class="line">    usedExports: <span class="literal">true</span> <span class="comment">// 被使用了的导出模块。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>如果引入的包/模块被标记为sideEffects：false，那么不管它是否真的有副作用，只要它没有被引用到，整个模块/包都会被完整的移除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">"sideEffects"</span>: <span class="literal">false</span>, <span class="comment">// 正常对所有模块进行tree shaking</span></span><br><span class="line"><span class="string">"sideEffects"</span>: [<span class="string">'*.css'</span>, <span class="string">'@babel/polyfill'</span>] <span class="comment">// 在数组中排除不需要tree shaking的模块</span></span><br></pre></td></tr></table></figure>

<h2 id="代码分割Code-Splitting"><a href="#代码分割Code-Splitting" class="headerlink" title="代码分割Code Splitting"></a>代码分割Code Splitting</h2><p>代码分离指将代码分成不同的包/块，然后可以按需加载，而不是加载包含所有内容的单个包。</p>
<ol>
<li>分离第三方库(vendor)代码和业务代码<br>业务代码经常会改变，但第三方库改变频率低，充分利用浏览器缓存来加载第三方库，可以加快网页加载速度。</li>
<li>按需加载(import())<br>用到了才去加载，比如访问某个路由的时候再去加载对应的组件，用户不一定会访问所有的路由，所以没必要把所有路由对应的组件先在开始加载完。而且某些用户的权限只能访问到某些页面，因此没有必要把它们没权限访问的页面的代码也加载。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.join([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在webpack中实现代码分割</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'async'</span>,    <span class="comment">// 对同步 initial，异步 async，所有的模块有效 all    </span></span><br><span class="line">            minSize: <span class="number">30000</span>,     <span class="comment">// ⼩尺寸，当模块⼤于30kb   </span></span><br><span class="line">            maxSize: <span class="number">0</span>,         <span class="comment">// 对模块进行二次分割时使用，不推荐使用    </span></span><br><span class="line">            minChunks: <span class="number">1</span>,       <span class="comment">// 打包生成的chunk文件少有⼏个chunk引用了这个模块     </span></span><br><span class="line">            maxAsyncRequests: <span class="number">5</span>,<span class="comment">// 大异步请求数，默认5  </span></span><br><span class="line">            maxInitialRequests: <span class="number">3</span>, <span class="comment">// ⼤初始化请求书，⼊口文件同步请求，默认 3     </span></span><br><span class="line">            automaticNameDelimiter: <span class="string">'~'</span>, <span class="comment">// 打包分割符号 </span></span><br><span class="line">            name: <span class="literal">true</span>,                  <span class="comment">// 打包后的名称，除了布尔值，还可以接收⼀个函数 function      </span></span><br><span class="line">            cacheGroups: &#123;               <span class="comment">// 缓存组     </span></span><br><span class="line">                vendors: &#123;</span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                    name: <span class="string">"vendor"</span>,      <span class="comment">// 要缓存的 分隔出来的 chunk 名称          </span></span><br><span class="line">                    priority: <span class="number">-10</span>        <span class="comment">// 缓存组优先级 数字越⼤，优先级越高  </span></span><br><span class="line">                &#125;,</span><br><span class="line">                other: &#123;</span><br><span class="line">                    chunks: <span class="string">"initial"</span>,   <span class="comment">// 必须三选一："initial" | "all" | "async"(默认就是async)</span></span><br><span class="line">                    test: <span class="regexp">/react|lodash/</span>, <span class="comment">// 正则规验证，如果符合就提取 chunk,   </span></span><br><span class="line">                    name: <span class="string">"other"</span>,</span><br><span class="line">                    minSize: <span class="number">30000</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">default</span>: &#123;</span><br><span class="line">                        minChunks: <span class="number">2</span>,</span><br><span class="line">                        priority: <span class="number">-20</span>,</span><br><span class="line">                        reuseExistingChunk: <span class="literal">true</span> <span class="comment">// 可设置是否重用该chunk        </span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用下面配置即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;  </span><br><span class="line">    <span class="comment">//帮我们⾃自动做代码分割  </span></span><br><span class="line">    splitChunks:&#123;    <span class="attr">chunks</span>:<span class="string">"all"</span>, <span class="comment">//默认是支持异步，我们使用all </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DllPlugin插件打包第三方类库-优化构建性能"><a href="#DllPlugin插件打包第三方类库-优化构建性能" class="headerlink" title="DllPlugin插件打包第三方类库 优化构建性能"></a>DllPlugin插件打包第三方类库 优化构建性能</h2><p>Dll动态链接库<br>项目中引入了很多第三方库，这些库在很长的一段时间内，基本不会更新，打包的时候分开打包来提升打包速度。而DllPlugin动态链接库插件，其原理就是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。</p>
<p>新建webpack.dll.config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态公共资源打包配置</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; DllPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NODE_ENV = process.env.NODE_ENV;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: NODE_ENV,</span><br><span class="line">    entry: [<span class="string">"react"</span>, <span class="string">"react-dom"</span>],</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'dll'</span>),</span><br><span class="line">        filename: <span class="string">'react.dll.js'</span>,</span><br><span class="line">        library: <span class="string">'react'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> DllPlugin(&#123;           </span><br><span class="line">            path: path.resolve(__dirname, <span class="string">'dll/reactmanifest.json'</span>),  <span class="comment">// manifest.json文件的输出位置       </span></span><br><span class="line">            name: <span class="string">'react'</span>                                             <span class="comment">// 定义打包的公共vendor文件对外暴露的函数名   </span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在package.json中添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build:dll"</span>: <span class="string">"cross-env NODE_ENV=development webpack --config ./build/webpack.dll.config.js"</span>,</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:dll</span><br></pre></td></tr></table></figure>

<p>运行之后会发现多了一个dll文件夹，里面有dll.js文件，这样就把第三方库单独打包了。</p>
<p>安装依赖以下依赖，它将我们打包后的dll.js文件注入到我们生成的index.html中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i add-asset-html-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>在webpack.base.config.js文件中进行更改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    filepath: path.resolve(__dirname, <span class="string">'../dll/react.dll.js'</span>) <span class="comment">// 对应的dll文件路径</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    manifest: path.resolve(__dirname, <span class="string">'dll/react-manifest.json'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="使⽤happypack并发执⾏任务"><a href="#使⽤happypack并发执⾏任务" class="headerlink" title="使⽤happypack并发执⾏任务"></a>使⽤happypack并发执⾏任务</h2><p>运行在NodeJS上的webpack是单线程模型的，也就是说webpack需要一个一个地处理任务，不能同时处理多个任务。Happy Pack 就能让webpack做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完之后再将结果发送给主进程。</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D happypack</span><br></pre></td></tr></table></figure>

<p>配置webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123;<span class="attr">size</span>:<span class="number">5</span>&#125;)</span><br><span class="line">rules: [ </span><br><span class="line">     &#123;</span><br><span class="line">         test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">         exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">         use: [</span><br><span class="line">            &#123;   <span class="comment">// 一个loader对应一个id</span></span><br><span class="line">                loader: <span class="string">"happypack/loader?id=babel"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                include: path.reslove(__dirname, <span class="string">"./src"</span>),</span><br><span class="line">                use: [<span class="string">"happypack/loader?id=css"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">     &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">plugins: &#123;</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">        <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">        id: <span class="string">'babel'</span>,</span><br><span class="line">        <span class="comment">// 如何处理.js文件，用法和loader配置中一样</span></span><br><span class="line">        loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">        threadPool: HappyPackThreadPool</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">        id: <span class="string">"css"</span>,</span><br><span class="line">        loaders: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/webpack3/" data-id="ckh5zzypz001eq4v2vhd6oyz2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/08/vue-面试题/" class="article-date">
  <time datetime="2020-08-08T07:47:54.000Z" itemprop="datePublished">2020-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/08/vue-面试题/">vue 面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h1><p>v-if 的值从false 变为true，会重新触发组件的生命周期函数。</p>
<h1 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h1><p>通过props属性传递的值不能够改变，可以通过computed的get和set去包裹一层。</p>
<h1 id="computed属性"><a href="#computed属性" class="headerlink" title="computed属性"></a>computed属性</h1><p>computed属性在mounted之前操作，因此不能在computed里面获取到dom元素。</p>
<h1 id="v-if-和v-for哪个优先级更高？如果同时出现，应该怎么优化得到更好的性能？"><a href="#v-if-和v-for哪个优先级更高？如果同时出现，应该怎么优化得到更好的性能？" class="headerlink" title="v-if 和v-for哪个优先级更高？如果同时出现，应该怎么优化得到更好的性能？"></a>v-if 和v-for哪个优先级更高？如果同时出现，应该怎么优化得到更好的性能？</h1><p>源码位置:compiler/codegen/index.js<br>答案：</p>
<ol>
<li>v-for优先于v-if被解析，在源码中模板编译的时候，for先于if处理。并且在最终生成渲染函数时，_l()代表v-for循环，其中包括了v-if的判断。所以最终的效果就是v-if的条件判断被包裹在v-for中。</li>
<li>如果同时出现，每次渲染都会执行循环再判断条件，无论如何循环都不可避免，浪费了性能。</li>
<li>要避免这种情况的出现，需要在外层嵌套template，并且使用v-if的判断，然后在内部进行v-for循环。</li>
<li>优化：使用computed选项，进行筛选之后，只需要渲染需要显示的数据，不需要再做判断了。</li>
</ol>
<h1 id="Vue组件data为什么必须是一个函数，而Vue根实例则没有此限制？"><a href="#Vue组件data为什么必须是一个函数，而Vue根实例则没有此限制？" class="headerlink" title="Vue组件data为什么必须是一个函数，而Vue根实例则没有此限制？"></a>Vue组件data为什么必须是一个函数，而Vue根实例则没有此限制？</h1><p>源码位置：src/core/instance/state.js - initData()<br>答案：</p>
<ol>
<li>Vue组件可能存在多个实例，如果在使用对象形式定义data，则会导致他们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；</li>
<li>采用函数形式定义data，在intitData时，会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染的问题。而在Vue根实例创建的过程中则不存在该限制，也是因为为根实例只能有一个，不需要担心这种情况。</li>
<li>在源码中，在vue组件创建和vue根实例创建时，进入的是不同的处理分支。vue根实例mergeData的时候会传入vm参数，vue组件不会传入vm参数，以此来区分。在vue组件创建过程中，对data选项合并时，当data选项不是function时，就会报错。</li>
</ol>
<h1 id="vue中key的作用和工作原理？"><a href="#vue中key的作用和工作原理？" class="headerlink" title="vue中key的作用和工作原理？"></a>vue中key的作用和工作原理？</h1><p>src/core/vdom/patch.js - updateChildren()<br>答案：</p>
<ol>
<li>key的作用主要是为了高效更新虚拟DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个pathch过程更加高效，较少DOM操作两量，提高性能。</li>
<li>另外，如果不设置key可能在列表更新时引发一些隐蔽的bug。</li>
<li>vue中在使用相同标签名元素的过度切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过度效果。</li>
</ol>
<h1 id="怎么理解vue中diff算法？"><a href="#怎么理解vue中diff算法？" class="headerlink" title="怎么理解vue中diff算法？"></a>怎么理解vue中diff算法？</h1><p>源码位置：</p>
<ol>
<li>必要性，lifecycle.js-mountComponent()<br>组件中可能存在很多个data中的key的使用。</li>
<li>执行方式，patch.js-patchVnode()<br>patchVnode时diff发生的地方，整体策略：深度优先，同层比较。</li>
<li>高效性，patch.js-updateChildren()</li>
</ol>
<p>答案：</p>
<ol>
<li>diff算法时虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比(即diff)，将变化的地方 更新在真实DOM上。另外，也需要diff高效的执行对比过程。从而降低时间复杂度O(n)。</li>
<li>Vue2.x中为了降低Watcher粒度，每个组件创建时，只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。</li>
<li>vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。</li>
<li>diff过程整体遵循深度优先，同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能是相同，做4次对比尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。</li>
</ol>
<h1 id="谈一谈vue组件化的理解"><a href="#谈一谈vue组件化的理解" class="headerlink" title="谈一谈vue组件化的理解"></a>谈一谈vue组件化的理解</h1><p>组件化定义，优点，使用场景和注意事项等方面展开陈述，同时要强调vue中组件化的一些特点。</p>
<p>源码位置：</p>
<ol>
<li>组件定义 src/core/global-api/assets.js<br>对于单文件组件中的template标签，vue-loader会编译template为render函数，最终导出的依然是组件配置对象。</li>
<li>组件化优点 src/core/instance/lifecycle.js - mountComponent()<br>组件，Watcher，渲染函数和更新函数之间的关系。</li>
<li>组件化实现<br>构造函数 src/core/global-api/extend.js<br>实例化及挂载 src/core/vdom/patch.js - createElm()</li>
</ol>
<p>总结</p>
<ol>
<li>组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型，独立和可复用的组件构建大型应用；</li>
<li>组件化开发能大幅度提高应用的开发效率，测试性，复用性等；</li>
<li>组件使用按分类有：页面组件，业务组件，通用组件；</li>
<li>vue的组件是基于配置的，我们通常编写的组件是组件配置，而非组件，框架后续会生成其构造函数，它们基于VueComponent类，继承自Vue。</li>
<li>vue中常见的组件化技术有：属性prop，自定义事件，插槽，它们主要用于组件通信，扩展等。</li>
<li>合理的划分组件，有助于提升应用性能。</li>
<li>组件应该是高内聚，低耦合的。</li>
<li>遵循单向数据流的原则。</li>
</ol>
<h1 id="谈一谈对vue设计原则的理解？"><a href="#谈一谈对vue设计原则的理解？" class="headerlink" title="谈一谈对vue设计原则的理解？"></a>谈一谈对vue设计原则的理解？</h1><ol>
<li><p>渐进式JavaScript框架<br>与其他大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页面应用提供驱动。</p>
</li>
<li><p>易用，灵活和高效<br>易用性： vue提供数据响应式，声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js，html和css就能轻松编写vue应用。</p>
</li>
</ol>
<p>灵活性：渐进式框架的最大有点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模的不断扩大，我们才可能组件引入路由，状态管理，vue-cli等库和工具，不管是应用体积还是学习难度都是一个组件增加的平和曲线。</p>
<p>高效性： 超快的虚拟DOM和Diff算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。</p>
<h1 id="Vue为什么要求组件模板只能有一个根元素"><a href="#Vue为什么要求组件模板只能有一个根元素" class="headerlink" title="Vue为什么要求组件模板只能有一个根元素"></a>Vue为什么要求组件模板只能有一个根元素</h1><p>从以下方面考虑：</p>
<h2 id="单文件组件中，template下的元素div。其实就是’树’状数据结构中的根。"><a href="#单文件组件中，template下的元素div。其实就是’树’状数据结构中的根。" class="headerlink" title="单文件组件中，template下的元素div。其实就是’树’状数据结构中的根。"></a>单文件组件中，template下的元素div。其实就是’树’状数据结构中的根。</h2><p>在webpack搭建的vue开发环境下，使用单文件组件时：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>template是html5的新标签，有三个特性：</p>
<ol>
<li>隐藏性： 该标签不会显示在页面的任何地方，即便里面有多少内容，它永远都是隐藏的状态，设置了display：none</li>
<li>任意性： 该标签可以写在任何地方，甚至是head，body，script标签内。</li>
<li>无效性： 该标签里的任何HTML内容都是无效的不会起任何作用；只能通过innerHTML来获取里面的内容。</li>
</ol>
<p>一个vue单文件组件就是一个vue实例，为了让组件可以正常生成一个vue实例，这个div会自然的处理成程序的入口，通过这个根节点，来递归遍历整个vue树下的所有节点，并处理为vdom，最后在渲染成真正的HTML，插入在正确的位置。</p>
<h2 id="diff算法要求的，源码中patch-js里patchVnode"><a href="#diff算法要求的，源码中patch-js里patchVnode" class="headerlink" title="diff算法要求的，源码中patch.js里patchVnode()"></a>diff算法要求的，源码中patch.js里patchVnode()</h2><p>diff中patchVnode方法，用来比较新旧结点</p>
<h1 id="谈谈对MVC，MVP和MVVM的理解"><a href="#谈谈对MVC，MVP和MVVM的理解" class="headerlink" title="谈谈对MVC，MVP和MVVM的理解"></a>谈谈对MVC，MVP和MVVM的理解</h1><ol>
<li>这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。</li>
<li>MVC模式出现较早主要应用在后端，如Spring MVC、ASP.NET MVC等，在前端领域的早期也有应 用，如Backbone.js。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。</li>
<li>MVP模式在是MVC的进化形式，Presenter作为中间层负责MV通信，解决了两者耦合问题，但P层 过于臃肿会导致维护问题。 </li>
<li>MVVM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的 大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现.<br>M-model - 保存应用数据<br>V-view - 视图，展示数据<br>C-controller - 业务逻辑，修改数据<br>VM- ViewModel -通过DOM listener监听响应View中用户交互,修改Model中数据。<br>ViewModel通过实现一套数据响应式机制自动响应Model中数据变化； 同时ViewModel会实现一套更新策略自动将数据变化转换为视图更新。</li>
</ol>
<h1 id="你了解哪些Vue性能优化方法？"><a href="#你了解哪些Vue性能优化方法？" class="headerlink" title="你了解哪些Vue性能优化方法？"></a>你了解哪些Vue性能优化方法？</h1><p>主要探讨Vue代码层面的优化。</p>
<ol>
<li><p>路由懒加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>)&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>keep-alive缓存页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用v-show复用DOM<br>对于经常切换的组件，使用v-show。</p>
</li>
<li><p>v-for遍历避免同时使用v-if。</p>
</li>
<li><p>长列表性能优化<br>对于纯粹是数据展示的列表，就不需要做响应化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        users: []</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">async</span> created() &#123;</span><br><span class="line">        cosnt users = <span class="keyword">await</span> axios.get(<span class="string">"/api/users"</span>)</span><br><span class="line">        <span class="keyword">this</span>.users = <span class="built_in">Object</span>.freeze(users)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是大数据长列表，可以采用虚拟滚动，只渲染少部分区域的内容。<br>参考：vue-virtual-scroller , vue-virtual-scroll-list</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">recycle-scroller</span> <span class="attr">class</span>=<span class="string">"items"</span> <span class="attr">:items</span>=<span class="string">"items"</span> <span class="attr">:item-size</span>=<span class="string">"24"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">"&#123; item &#125;"</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">FetchItemView</span> <span class="attr">:item</span>=<span class="string">"item"</span> @<span class="attr">vote</span>=<span class="string">"voteItem(item)"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span></span></span><br><span class="line">&lt;/recycle-scroller&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件销毁<br>Vue组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;  </span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="keyword">this</span>.refresh, <span class="number">2000</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;  </span><br><span class="line">   clearInterval(<span class="keyword">this</span>.timer) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片懒加载<br>对于图片过多的页面，为了加速页面加载速度，所以很多时候需要将页面内未出现在可试区域内的图片先不做均价在，等到滚动到可视区域后再去加载。<br>参考：vue-lazyload</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"/statix/img/1.png"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第三方插件按需引入<br>像element-ui这样的第三方组件可以按需引入避免体积太大。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Select)</span><br></pre></td></tr></table></figure>
</li>
<li><p>无状态的组件标记为函数式组件<br>组件只做展示，没有业务逻辑，就可以标记为函数式组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"cell"</span>&gt;</span><br><span class="line">        &lt;div v-<span class="keyword">if</span>=<span class="string">"props.value"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"on"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;section v-<span class="keyword">else</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"off"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt; </span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  <span class="attr">props</span>: [<span class="string">'value'</span>] &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件分割</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ChildComp/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span><br><span class="line">    components: &#123;    </span><br><span class="line">        ChildComp: &#123;      </span><br><span class="line">            methods: &#123;        </span><br><span class="line">                heavy () &#123; <span class="comment">/* 耗时任务 */</span> &#125;      </span><br><span class="line">            &#125;,</span><br><span class="line">            render (h) &#123;   </span><br><span class="line">                <span class="keyword">return</span> h(<span class="string">'div'</span>, <span class="keyword">this</span>.heavy())     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量本地化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cosnt base = <span class="keyword">this</span>.base <span class="comment">// 避免频繁的引用this.base</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在computed中将数据处理完之后，直接去渲染，减少v-if的条件判断。</p>
</li>
<li><p>SSR服务端渲染<br>优点：加快首屏渲染的速度，有利于seo。</p>
</li>
</ol>
<h1 id="Vue-3-0新特性"><a href="#Vue-3-0新特性" class="headerlink" title="Vue 3.0新特性"></a>Vue 3.0新特性</h1><p>Vue3.0 的改进主要在以下几点：</p>
<h2 id="更快："><a href="#更快：" class="headerlink" title="更快："></a>更快：</h2><h3 id="虚拟DOM重写"><a href="#虚拟DOM重写" class="headerlink" title="虚拟DOM重写"></a>虚拟DOM重写</h3><p>期待更多的编译时提示来减少运行时开销，使用更有效的代码来创建虚拟节点。<br>组件快速路径+单个调用+ 子节点类型检测</p>
<ul>
<li>跳过不必要的条件分支</li>
<li>JS引擎更容易优化<h3 id="优化slots的生成"><a href="#优化slots的生成" class="headerlink" title="优化slots的生成"></a>优化slots的生成</h3>Vue 3中可以单独重新渲染父级和子级</li>
<li>确保实例正确的跟踪依赖关系</li>
<li>避免不必要的父子组件重新渲染<h3 id="静态树提升"><a href="#静态树提升" class="headerlink" title="静态树提升"></a>静态树提升</h3>使用静态树提升，这意味着Vue 3的编译器将能检测到什么是静态的，然后将其提升，从而降低了渲染成本。</li>
<li>跳过修补整棵树，从而降低渲染成本</li>
<li>即使多次出现也能正常工作<h3 id="静态属性提升"><a href="#静态属性提升" class="headerlink" title="静态属性提升"></a>静态属性提升</h3>使用静态属性提升，Vue 3打补丁时将跳过这些属性不会改变的节点。<h3 id="基于Proxy的响应式系统"><a href="#基于Proxy的响应式系统" class="headerlink" title="基于Proxy的响应式系统"></a>基于Proxy的响应式系统</h3>Vue 2的响应式系统使用Object.defineProperty的getter和setter。Vue 3将使用ES6 Proxy作为其观察机制，这将带来如下改变：</li>
<li>组件实例初始化的速度提高1倍。</li>
<li>使用Proxy内存开销节省一半，加快速度，但是存在低版本浏览器的不兼容。</li>
<li>为了继续支持IE11,Vue 3将发布一个支持旧观察者和新Proxy版本的构建。<h2 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h2>通过摇树优化核心库体积<h2 id="更容易维护"><a href="#更容易维护" class="headerlink" title="更容易维护"></a>更容易维护</h2>Vue 3 将带来更可维护的源代码。它不仅会使用 TypeScript，而且许多包被解耦，更加模块化。<h2 id="更加友好"><a href="#更加友好" class="headerlink" title="更加友好"></a>更加友好</h2>跨平台，编译器核心和运行时核心与平台无关，使得 Vue 更容易与任何平台(web, android, ios)一起使用。<h2 id="更容易使用"><a href="#更容易使用" class="headerlink" title="更容易使用"></a>更容易使用</h2></li>
</ul>
<ol>
<li>改进的TypeScript支持，编辑器能提供强有力的类型检查，错误和警告。</li>
<li>更好的调试支持</li>
<li>独立的响应化模块</li>
<li>composition API</li>
</ol>
<h1 id="Vuex使用及其理解"><a href="#Vuex使用及其理解" class="headerlink" title="Vuex使用及其理解"></a>Vuex使用及其理解</h1><p>vue中的状态管理，使用场景：登陆验证，购物车，播放器等。</p>
<h2 id="Vuex介绍"><a href="#Vuex介绍" class="headerlink" title="Vuex介绍"></a>Vuex介绍</h2><p>Vuex数据流程：通过actions 异步请求数据，mutations修改state，getter类似computed获取state的值。</p>
<h2 id="Vuex-核心概念"><a href="#Vuex-核心概念" class="headerlink" title="Vuex 核心概念"></a>Vuex 核心概念</h2><p>state：vuex的唯一数据来源，获取多个state，可以使用…mapState()。<br>getters：getter理解为computed，getter的返回值根据他的依赖缓存起来，依赖发生变化才被重新计算，辅助函数…mapGetter()。<br>mutations: 更改state中唯一的途径。只能是同步操作。通过$store.commit提交,辅助函数…mapMutations()。<br>actions： 获取异步数据的地方。通过$store.dispatch触发，辅助函数…mapActions()。<br>module：模块化。</p>
<h2 id="Vuex中数据存储"><a href="#Vuex中数据存储" class="headerlink" title="Vuex中数据存储"></a>Vuex中数据存储</h2><p>vuex是vue的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存数据，取出来再替换store里的state。</p>
<p>注意：localStorage存储数据的格式都是以字符串的形式来存储的，需要使用JSON.parse(localStorage.getItem(“userInfo”))解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultCity = <span class="string">"上海"</span></span><br><span class="line"><span class="keyword">try</span> &#123;    <span class="comment">// 用户关闭了本地存储功能，此时在外层加个try...catch  </span></span><br><span class="line">    <span class="keyword">if</span> (!defaultCity) &#123;      </span><br><span class="line">        defaultCity = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'defaultCity'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vuex</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(</span><br><span class="line">    &#123;</span><br><span class="line">        state: &#123; <span class="attr">city</span>: defaultCity &#125;,</span><br><span class="line">        mutations: &#123;</span><br><span class="line">            changeCity(state, city) &#123;</span><br><span class="line">                state.city = city</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">window</span>.localStorage.setItem(<span class="string">'defaultCity'</span>, <span class="built_in">JSON</span>.stringify(state.city));      <span class="comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面      </span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">                    <span class="built_in">console</span>.log(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>总结： </p>
<ol>
<li>首先说明Vuex是一个专门为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li>
<li>vuex核心概念：mutations，actions介绍</li>
<li>vuex如何做数据存储： 配合localStorage</li>
</ol>
<h1 id="Vue中组件之间的通信方式"><a href="#Vue中组件之间的通信方式" class="headerlink" title="Vue中组件之间的通信方式"></a>Vue中组件之间的通信方式</h1><p>组件可以有以下几种关系：</p>
<ol>
<li>父子关系</li>
<li>兄弟关系</li>
<li>隔代关系</li>
</ol>
<h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><h4 id="props-和-emit-on"><a href="#props-和-emit-on" class="headerlink" title="props 和 $emit/$on"></a>props 和 $emit/$on</h4><p>在父组件中给子组件绑定属性，子组件声明props，将数据从父组件传递到子组件。<br>在父组件中给子组件绑定自定义事件，子组件通过$emit触发自定义事件，以参数的形式，将数据传递到父组件。</p>
<h4 id="parent-children-与-ref-refs"><a href="#parent-children-与-ref-refs" class="headerlink" title="$parent/$children 与 ref/$refs"></a>$parent/$children 与 ref/$refs</h4><p>ref属性： 如果设置在DOM上引用指向DOM元素，在子组件上使用，引用就指向组件实例。设置ref属性，通过$refs获取数据。<br>$parent和$children: 直接获取父/子组件实例。</p>
<p>注意：这两种方式都不可以跨级以及兄弟之间通信。</p>
<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>兄弟组件通信的方式，通过vuex，以父组件做中间层使用自定义事件绑定emit/on，以及事件总线。</p>
<h3 id="跨层组件通信"><a href="#跨层组件通信" class="headerlink" title="跨层组件通信"></a>跨层组件通信</h3><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p>多层级嵌套需要传递数据可以使用 vuex，一次存储，所有页面都可访问。</p>
<h4 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs / $listeners"></a>$attrs / $listeners</h4><p>$attrs: 包含了父组件给子组件绑定的，并且没有在子组件props中声明的自定义属性(class和style除外)。同时可以通过v-bind=”$attrs”传入到内部组件。</p>
<p>$listeners: 包含了父组件给子组件绑定的自定义事件(不含native修饰的事件)。它可以通过v-on=”listeners”传入到内部组件。</p>
<h4 id="provide-inject-选项"><a href="#provide-inject-选项" class="headerlink" title="provide/inject 选项"></a>provide/inject 选项</h4><p>祖先组件中通过provide来提供变量，然后在子孙组件中通过inject来注入变量。</p>
<p>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<p>注意：provide/inject传递的数据并不是可响应的，但如果传入的数据本身是响应的对象，那么其对象的属性还是可响应的。</p>
<p>provide/inject如何实现数据响应式</p>
<ol>
<li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性。缺点：实例上挂载很多没必要的东西。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;A组件&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child-b&gt;&lt;/</span>child-b&gt;</span><br><span class="line">    &lt;child-c&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child-c</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">        color: "blue"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 这种方式绑定的数据并不是可响应的</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ provide() &#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/     return &#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/         theme: &#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/             color: this.color</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/         &#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/     &#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ &#125;</span></span><br><span class="line"><span class="regexp">provide() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">        theme: this /</span><span class="regexp">/ 方法1：提供祖先组件的实例</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">    changeColor() &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ changde color</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>推荐使用Vue.observable优化provide。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法2： 使用Vue.observable 优化响应式provide</span></span><br><span class="line">provide() &#123;</span><br><span class="line">    <span class="keyword">this</span>.theme = Vue.observable(&#123;</span><br><span class="line">        color: <span class="string">"blue"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        theme: <span class="keyword">this</span>.theme</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在组件中使用</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1 :style=<span class="string">"&#123;color: injections.theme.color&#125;"</span>&gt; xx&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">export default&#123;</span></span><br><span class="line"><span class="regexp">    inject: &#123;</span></span><br><span class="line"><span class="regexp">        theme: &#123;</span></span><br><span class="line"><span class="regexp">            default: () =&gt; (&#123;&#125;) /</span><span class="regexp">/ 函数式组件取值</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="bus"><a href="#bus" class="headerlink" title="$bus"></a>$bus</h4><p>使用vue实例作为事件总线，用来触发事件和监听事件，通过这种方式可以进行组件通信包括：父子，兄弟，跨级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// 监听事件 组件a</span></span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'./bus'</span></span><br><span class="line"></span><br><span class="line">bus.$on(<span class="string">'sendTitle'</span>, (val) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = val</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件 组件b</span></span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'./bus'</span></span><br><span class="line"></span><br><span class="line">bus.$emit(<span class="string">'sendTitle'</span>, <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Vue-router中的导航钩子有哪些？"><a href="#Vue-router中的导航钩子有哪些？" class="headerlink" title="Vue-router中的导航钩子有哪些？"></a>Vue-router中的导航钩子有哪些？</h1><ol>
<li><p>全局的钩子函数<br>beforeEach(to, from, next) 路由改变前调用，常用于验证权限。<br>afterEach(to, from) 路由改变后的钩子，常用自动让页面返回最顶端。</p>
</li>
<li><p>路由配置中的导航钩子<br>beforeEnter(to, from, next)</p>
</li>
<li><p>组件内的钩子函数<br>beforeRouteEnter(to, from, next),该组件的对应路由被comfirm前调用，此时实例还没被创建，所以不能获取实例(this)。<br>beforeRouteUpdate(to, from, next),当前路由改变，但是该组件被复用时调用，该函数内可以访问组件实例this。<br>beforeRouteLeave(to, from, next),当导航离开组件的对应路由时调用，该函数内可以访问获取组件实例。</p>
</li>
<li><p>路由监测变化<br>监听到路由对象发生变化，从而对路由变化做出响应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    watch:&#123;</span><br><span class="line">        $route: &#123;</span><br><span class="line">            handler: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(val);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 深度观察监听</span></span><br><span class="line">            deep: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>总结： </p>
<ol>
<li>路由中的导航钩子有三种：全局，组件，路由配置</li>
<li>在做页面登陆权限的时候可以使用到路由导航配置。</li>
<li>监听路由变化</li>
</ol>
<h1 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h1><p>概念： 组件是可以在他们自己的模板中调用自身的。<br>条件： 数据是满足递归条件，树状的递归数据结构。一定要设置递归组件的结束条件。<br>场景： 多层级目录。</p>
<p>总结：通过props从父组件拿到数据，递归组件每次进行递归的时候都会tree-menus组件传递下一级treeList数据，整个过程结束之后，递归也就完成了，对于折叠树状菜单来说，我们一般只会去渲染一级的数据，当点击一级菜单时，再去渲染一级菜单下的结构，如此往复。那么v-if就可以实现我们的这个需求，当v-if设置为false时，递归组件将不会再进行渲染，设置为true时，继续渲染。</p>
<h1 id="vue响应式理解"><a href="#vue响应式理解" class="headerlink" title="vue响应式理解"></a>vue响应式理解</h1><p>响应式实现：Object.defineProperty , proxy(ES6)</p>
<h2 id="Observe类"><a href="#Observe类" class="headerlink" title="Observe类"></a>Observe类</h2><p>对data选项Observe，分别对对象和数组做响应化处理。<br>对对象采用Object.defineProperty设置getter和setter的方式，这种方式称为数据劫持。<br>对数组采用扩展数组的7个变异方法，然后当数组改变的时候就会，通知更新。</p>
<h2 id="Dep类"><a href="#Dep类" class="headerlink" title="Dep类"></a>Dep类</h2><p>一个key 就会为之生成一个dep实例来管理依赖，依赖就是使用到了数据的地方，本质就是watcher。<br>当数据在页面上渲染的时候，就会通过getter函数来收集依赖到dep实例的subs数组下。</p>
<h2 id="Watcher-类"><a href="#Watcher-类" class="headerlink" title="Watcher 类"></a>Watcher 类</h2><p>当一个组件mount的时候，就会生成一个render watcher实例。<br>当数据变化时，会触发setter函数去通知watcher，watcher再去通知异步任务队列，执行异步更新。</p>
<h1 id="vue如何扩展组件"><a href="#vue如何扩展组件" class="headerlink" title="vue如何扩展组件"></a>vue如何扩展组件</h1><ol>
<li>使用混入mixin<br>混入(mixin)是一种分发Vue组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。</li>
</ol>
<p>mixins的调用顺序：全局混入的钩子函数 &gt; 组件内的混入的钩子函数 &gt; 组件自身的钩子。<br>选项合并： 组件和混入对象的同名选项递归合并，冲突以组件数据优先。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件内的混入：mixins选项接受一个混合对象的数组。</span></span><br><span class="line">&#123;</span><br><span class="line">    mixins:[xxx]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局混入：使用Vue.mixin 全局注册一个混入， 影响每个vue实例</span></span><br><span class="line">Vue.mixin(&#123;xxx&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>slot扩展组件<br>默认插槽，匿名插槽，具名插槽</li>
</ol>
<h1 id="watch和computed的区别以及怎么选用？"><a href="#watch和computed的区别以及怎么选用？" class="headerlink" title="watch和computed的区别以及怎么选用？"></a>watch和computed的区别以及怎么选用？</h1><p>原理：<br>计算属性computed底层实现本质是watch，但是实现了缓存。<br>使用场景不一样：<br>watch：需要在数据变化时，去执行异步操作或开销比较大的操作的时候使用。例如搜索数据。<br>computed：一个数据属性受多个属性影响的时候。例如：购物车商品结算。</p>
<h1 id="nextTick原理"><a href="#nextTick原理" class="headerlink" title="nextTick原理"></a>nextTick原理</h1><p>使用nextTick的场景： Vue不推荐操作DOM,但有时候不得不在修改数据后，获取DOM状态或者不得不操作DOM时。在数据变化之后立即使用 Vue.nextTick(callback)是为了在数据变化之后等待 Vue 完成更新DOM。这样回调函数将在 DOM 更新完成后被调用，因此可以在回调函数中获取到最新的DOM。</p>
<p>为什么要使用nextTick： Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p>
<h2 id="vue如何监听到DOM更新完毕"><a href="#vue如何监听到DOM更新完毕" class="headerlink" title="vue如何监听到DOM更新完毕"></a>vue如何监听到DOM更新完毕</h2><p>能监听到DOM改动的API：MutationObserver。<br>MutationObserver是HTML5新增属性，用于监听DOM修改事件，能够监听到节点的属性，文本内容，子节点的改动。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MutationObserver</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DOM 被修改了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> article = <span class="built_in">document</span>.querySelector(<span class="string">'article'</span>)</span><br><span class="line">observer.observer(article)</span><br></pre></td></tr></table></figure>

<p>Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p>
<p>Vue的处理思路就是将nextTick里面的代码放在UI render 之后执行，就能访问到最新的ODM。Vue并不是使用MutationObserver做DOM变化监听，而是用队列控制的方式达到目的。</p>
<h2 id="Vue如何进行队列控制"><a href="#Vue如何进行队列控制" class="headerlink" title="Vue如何进行队列控制"></a>Vue如何进行队列控制</h2><p>因为macrotask总是要等到microtask都执行完之后再执行，因此利用microtask这一特性，是做队列控制的最佳选择。</p>
<p>vue进行DOM更新内部也是调用nextTick来做异步队列控制。而当我们自己调用nextTick的时候,它就在更新DOM的那个microtask后追加了我们自己的回调函数,从而确保我们的代码在DOM更新后执行,同时也避免了setTimeout可能存在的多次执行问题。</p>
<p>常见的microtask有：Promise，MutationObserver，以及nodejs中的process.nextTick。</p>
<p>看到了MutationObserver,vue用MutationObserver是想利用它的microtask特性,而不是想做DOM监听。核心是microtask,用不用MutationObserver都行的。事实上,vue在2.5版本中已经删去了MutationObserver相关的代码,因为它是HTML5新增的特性,在iOS上尚有bug。</p>
<p>那么最优的microtask策略就是Promise了,而令人尴尬的是,Promise是ES6新增的东西,也存在兼容问题呀。所以vue就面临一个降级策略。</p>
<h2 id="Vue的降级策略"><a href="#Vue的降级策略" class="headerlink" title="Vue的降级策略"></a>Vue的降级策略</h2><p>队列控制的最佳选择是microtask,而microtask的最佳选择是Promise.但如果当前环境不支持Promise,vue就不得不降级为macrotask来做队列控制了。</p>
<p>setImmediate &gt; MessageChannnel &gt; setTimeout<br>前两个都有兼容性问题，在最后不得不使用setTimeout。</p>
<p>总结：</p>
<ol>
<li>vue用异步队列的方式来控制DOM更新和nextTick回调先后执行。</li>
<li>microtask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完。</li>
<li>因为兼容性问题vue不得不做了microtask想macrotask的降级方案。</li>
</ol>
<h1 id="Vue生命周期函数"><a href="#Vue生命周期函数" class="headerlink" title="Vue生命周期函数"></a>Vue生命周期函数</h1><p>最早在created中才能操作data数据。对于异步数据的获取最好在这里进行。<br>最早在mounted中才能操作DOM，其余情况需要使用nextTick操作DOM。</p>
<p>beforeDestroy销毁前 和 destroy销毁后这两个钩子是需要我们手动调用实例上的 $destroy 方法才会触发的。<br>activated:keep-alive 组件激活时调用。<br>deactivated:keep-alive 组件停用时调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/08/vue-面试题/" data-id="ckh5zzypw001aq4v2cpvn0hlh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web-API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/07/Web-API/" class="article-date">
  <time datetime="2020-08-07T07:39:30.000Z" itemprop="datePublished">2020-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/07/Web-API/">Web API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h1><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。</p>
<h2 id="创建Blob实例"><a href="#创建Blob实例" class="headerlink" title="创建Blob实例"></a>创建Blob实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob(array, options)</span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">var</span> aFileParts = [<span class="string">'&lt;a id="a"&gt;&lt;b id="b"&gt;hey!&lt;/b&gt;&lt;/a&gt;'</span>]; <span class="comment">// 一个包含DOMString的数组</span></span><br><span class="line"><span class="keyword">var</span> oMyBlob = <span class="keyword">new</span> Blob(aFileParts, &#123;<span class="attr">type</span> : <span class="string">'text/html'</span>&#125;); <span class="comment">// 得到 blob， type它代表了将会被放入到blob中的数组内容的MIME类型</span></span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blob.size <span class="comment">// blob对象中所包含数据的大小(字节)</span></span><br><span class="line">blob.type <span class="comment">// 一个字符串，表明该 blob对象中所包含数据的大小 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</span></span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blob.slice(start, end) <span class="comment">// 返回一个新的 Blob 对象，它包含了原始 Blob 对象的某一个段的数据。</span></span><br><span class="line">blob.stream() <span class="comment">// 返回一个ReadableStream对象，读取它将返回包含在Blob中的数据。</span></span><br><span class="line">blob.text()    <span class="comment">// 返回一个 Promise 对象，包含 blob 中的内容，使用 UTF-8 格式编码。</span></span><br><span class="line">blob.arrayBuffer() <span class="comment">// 返回一个promise且包含blob所有内容的二进制格式的 ArrayBuffer</span></span><br></pre></td></tr></table></figure>

<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>通常情况下， File 对象是来自用户在一个 input 元素上选择文件后返回的 FileList 对象。<br>File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<h2 id="创建File实例"><a href="#创建File实例" class="headerlink" title="创建File实例"></a>创建File实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFile = <span class="keyword">new</span> File(bits, name, options)</span><br></pre></td></tr></table></figure>

<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>File 接口也继承了 Blob 接口的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file.lastModified <span class="comment">// 只读属性 ，返回所引用文件最后修改日期，为自1970年1月1日0:00 以来的毫秒数。没有已知的最后修改时间则会返回当前时间。</span></span><br><span class="line">file.name <span class="comment">// 返回当前 File 对象所引用文件的名字。</span></span><br><span class="line">file.size <span class="comment">// 返回文件大小。</span></span><br><span class="line">file.type <span class="comment">// 返回文件的类型。</span></span><br></pre></td></tr></table></figure>

<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>File 接口没有定义任何方法，但是它从 Blob 接口继承了以下方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.slice() <span class="comment">// 返回一个新的 Blob 对象，它包含有源 Blob 对象中指定范围内的数据。</span></span><br></pre></td></tr></table></figure>

<h1 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h1><p>FileReader构造函数创建的实例允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，通常处理 File 或 Blob 对象。</p>
<h2 id="创建FileReader-实例"><a href="#创建FileReader-实例" class="headerlink" title="创建FileReader 实例"></a>创建FileReader 实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br></pre></td></tr></table></figure>

<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.result <span class="comment">// 只读属性，文件的内容，只有在读取操作完成后才有效。</span></span><br><span class="line">reader.error  <span class="comment">// 只读属性，表示在读取文件时发生的错误。</span></span><br><span class="line">reader.readyState <span class="comment">// 只读属性，表示reader的状态，0 还没有加载数据，1 数据正在被加载， 2 已经完成全部的读取请求</span></span><br></pre></td></tr></table></figure>

<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reader.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125; <span class="comment">// 处理abort事件。该事件在读取被中断时触发。</span></span><br><span class="line">reader.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125; <span class="comment">// 处理error事件。该事件在读取发生错误时触发。</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125; <span class="comment">// 处理load事件。该事件在读取完成时触发。</span></span><br><span class="line">reader.onloadstart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125; <span class="comment">// 处理loadstart事件。该事件在读取开始时触发。</span></span><br><span class="line">reader.onloadend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125; <span class="comment">// 处理loadend事件。该事件在读取结束时触发。</span></span><br><span class="line">reader.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125; <span class="comment">// 处理progress事件。该事件在读取Blob时触发。</span></span><br></pre></td></tr></table></figure>

<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reader.abort() <span class="comment">// 终止读取操作。 readyState为已完成。</span></span><br><span class="line">reader.readAsArrayBuffer() <span class="comment">// 读取指定的Blob中的内容，完成后result属性中保存的文件的ArrayBuffer数据对象。</span></span><br><span class="line">reader.readAsDataURL() <span class="comment">//  读取指定的Blob中的内容，完成之后result属性中将包含一个data：URL格式的Base64字符串表示读取文件的内容。</span></span><br><span class="line">reader.readAsText() <span class="comment">// 读取指定的Blob中的内容，完成之后result属性中包含一个字符串以表示所读取的文件内容。</span></span><br></pre></td></tr></table></figure>

<h1 id="ArrayBuffer对象"><a href="#ArrayBuffer对象" class="headerlink" title="ArrayBuffer对象"></a>ArrayBuffer对象</h1><p>ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。</p>
<h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>); <span class="comment">// 占8个字节的二进制数据。</span></span><br></pre></td></tr></table></figure>

<h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.byteLength <span class="comment">// 表示当前实例占用的内存长度（单位字节）</span></span><br></pre></td></tr></table></figure>

<h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subBuffer = buffer.slice(start, end)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/07/Web-API/" data-id="ckh5zzypk000wq4v2rbw0ieva" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/04/webpack2/" class="article-date">
  <time datetime="2020-08-04T14:51:48.000Z" itemprop="datePublished">2020-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/04/webpack2/">webpack2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WebpackDevServer"><a href="#WebpackDevServer" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h1><p>每次改完代码都需要重新打包一次，打开浏览器，刷新一次，很麻烦。可以安装使用WebpackDevServer来改善开发效率。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改package.json</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"script"</span>: &#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"webpack-dev-server"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在webpack.config.js配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">"./dist"</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8081</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run server</span><br></pre></td></tr></table></figure>

<p>启动服务后，会发现dist目录没有了，这是因为devServer把打包后的模块不会放到dist目录下，而是放到了内存中，从而提升速度。</p>
<h2 id="本地mock，解决跨域"><a href="#本地mock，解决跨域" class="headerlink" title="本地mock，解决跨域"></a>本地mock，解决跨域</h2><p>联调期间，前后端分离，直接获取数据会跨域，上线后我们使用nginx转发，开发期间，webpack就可以搞定这件事。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i express -D</span></span><br><span class="line"><span class="comment">// 创建一个server.js 修改package.js中的scripts选项 "server":"node server.js"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.get(<span class="string">'/api/info'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        name: <span class="string">'开课吧'</span>,</span><br><span class="line">        age: <span class="number">5</span>,</span><br><span class="line">        msg: <span class="string">'welcome to kkb'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">'9092'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// node server.js</span></span><br><span class="line"><span class="comment">// 通过 http://localhost:9092/api/info 获取mock数据</span></span><br></pre></td></tr></table></figure>

<h2 id="项目中安装axios工具"><a href="#项目中安装axios工具" class="headerlink" title="项目中安装axios工具"></a>项目中安装axios工具</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i axios -D</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="comment">// 会有跨域问题</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:9092/api/info'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="修改webpack-config-js设置服务器代理"><a href="#修改webpack-config-js设置服务器代理" class="headerlink" title="修改webpack.config.js设置服务器代理"></a>修改webpack.config.js设置服务器代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于/api的请求会转发到http://localhost:9092</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">    ...</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        <span class="string">"/api"</span>: &#123;</span><br><span class="line">            target: <span class="string">"http://localhost:9092"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改index-js"><a href="#修改index-js" class="headerlink" title="修改index.js"></a>修改index.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求/api/info的请求都会代理到webpack的proxy配置中下的地址中。</span></span><br><span class="line">axios.get(<span class="string">"/api/info"</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Hot-Module-Replacement-HMR-热模块替换"><a href="#Hot-Module-Replacement-HMR-热模块替换" class="headerlink" title="Hot Module Replacement(HMR:热模块替换)"></a>Hot Module Replacement(HMR:热模块替换)</h1><p>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。主要是通过以下几种方式，来显著加快开发速度：</p>
<ol>
<li>保留在完全重新加载页面时丢失的应用程序状态。</li>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
<li>调整样式更加快速，几乎相当于在浏览器调试器中更改样式。</li>
</ol>
<h2 id="启动HMR"><a href="#启动HMR" class="headerlink" title="启动HMR"></a>启动HMR</h2><p>注意启动HMR后,css抽离不会生效,还有不支持contenthash, chunkhash。HMR 不适用于生产环境，这意味着它应当只在开发环境使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件头部引入webpack</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置devServer</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">"./dist"</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,      <span class="comment">// 启用 webpack 的模块热替换特性, 会自动刷新页面。</span></span><br><span class="line">    hotOnly: <span class="literal">true</span>   <span class="comment">// 启用 webpack 的模块热替换特性，即便某些模块不支持热更新的情况下，浏览器也不自动刷新页面，而是在控制台输出热更新失败。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加插件</span></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="处理JS模块HMR"><a href="#处理JS模块HMR" class="headerlink" title="处理JS模块HMR"></a>处理JS模块HMR</h2><p>启用 webpack 内置的 HMR插件后, module.hot 接口就会暴露在 index.js 中, 接下来需要在 index.js 中配置告诉 webpack 接受HMR的模块。<br>需要使用module.hot.accept来观察模块更新，从而更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> printMe <span class="keyword">from</span> <span class="string">'./print.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        printMe()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"># Babel处理ES6</span></span><br><span class="line"><span class="string">中文网站： https://www.babeljs.cn/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Babel是JavaScript编译器，能将ES6代码转换成ES5代码，让我们开发过程中放心使用JS新特性而不用担心兼容性问题。并且还可以通过插件机制根据需求灵活的扩展。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Babel在执行编译的过程中，会从项目根目录下的.babelrc 文件中读取配置。没有该文件会从loader的options处读取配置。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 安装</span></span><br><span class="line"><span class="string">babel-loader是webpack与babel的通信桥梁，不会做把es6转换成es5的工作。</span></span><br><span class="line"><span class="string">@babel/preset-env 里包含了ES6,7,8转换成ES5的转换规则，由这个包去做转换的工作。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>bash</span><br><span class="line">npm i babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure>

<h2 id="配置webpack-config-js"><a href="#配置webpack-config-js" class="headerlink" title="配置webpack.config.js"></a>配置webpack.config.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">               exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">               use: &#123;</span><br><span class="line">                   loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">                   options: &#123;</span><br><span class="line">                       presets: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的几步还不够，默认的Babel只支持let等一些基础的特性转换，Promise等一些的转换还需要借助@babel/polyfill,把ES的新特性都装进来，来弥补低版本浏览器中缺失的特性。</p>
<h2 id="引入-babel-polyfill"><a href="#引入-babel-polyfill" class="headerlink" title="引入@babel/polyfill"></a>引入@babel/polyfill</h2><p>以全局变量的方式注入进来。windows.Promise,它会造成全局对象的污染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install -S @babel/polyfill</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"@babel/polyfill"</span></span><br></pre></td></tr></table></figure>

<h2 id="按需加载，减少冗余"><a href="#按需加载，减少冗余" class="headerlink" title="按需加载，减少冗余"></a>按需加载，减少冗余</h2><p>引入babel/polyfill后,打包的体积大了很多，这是因为polyfill默认会把所有特性注入进来。然而我们期望只有用到ES6+的特性才会注入，没有用到的特性不注入，从而减少打包的体积。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改webpack.config.js</span></span><br><span class="line"></span><br><span class="line">options: &#123;</span><br><span class="line">    preset: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                targets: &#123;</span><br><span class="line">                    edge: <span class="string">"17"</span>,</span><br><span class="line">                    firefox: <span class="string">"60"</span>,</span><br><span class="line">                    chrome: <span class="string">"67"</span>,</span><br><span class="line">                    safari: <span class="string">"11.1"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                corejs: <span class="number">2</span>,            <span class="comment">// 新版本需要指定核心版本库</span></span><br><span class="line">                useBuiltIns: <span class="string">"usage"</span> <span class="comment">// 按需注入</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useBuiltIns选项是babel 7 的新功能，这个选项告诉babel如何配置@babel/polyfill。它有三个参数可以使用： </p>
<ol>
<li>entry：需要在webpack的入口文件里import “@babel/polyfill”一次。babel会根据你的使用情况导入垫片,没有使用的功能不会被导入相应的垫片。</li>
<li>usage：不需要import，全自动检测，但是要安装@babel/polyfill 。(试验阶段)</li>
<li>false: 如果你 import”@babel/polyfill” ,它不会排除掉没有用到的垫片,程序体积会庞大。(不推荐)</li>
</ol>
<p>请注意: usage 的行为类似 babel-transform-runtime,不会造成全局污染,因此也不会对类似 Array.prototype.includes() 进行 polyfill。</p>
<h2 id="使用-babelrc文件"><a href="#使用-babelrc文件" class="headerlink" title="使用.babelrc文件"></a>使用.babelrc文件</h2><p>新建.babelrc文件。把options部分移入到该文件中，就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    preset: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                targets: &#123;</span><br><span class="line">                    edge: <span class="string">"17"</span>,</span><br><span class="line">                    firefox: <span class="string">"60"</span>,</span><br><span class="line">                    chrome: <span class="string">"67"</span>,</span><br><span class="line">                    safari: <span class="string">"11.1"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                corejs: <span class="number">2</span>,            <span class="comment">// 新版本需要指定核心版本库</span></span><br><span class="line">                useBuiltIns: <span class="string">"usage"</span> <span class="comment">// 按需注入</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude： /node_modules/,</span><br><span class="line">    loader: <span class="string">"babel-loader"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h2><p>当我们开发的是组件库，工具库这些场景的时候，polyfill就不合适了，因为polyfill是注入到全局变量window下的，会污染全局环境。<br>所以推荐闭包的方式： 使用@babel/plugin-transform-runtime，它不会造成全局污染。<br>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br><span class="line">npm install --save @babel/runtime</span><br></pre></td></tr></table></figure>

<p>修改配置文件： 注释掉之前的presets选项，添加plugins</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    <span class="comment">// presets: [</span></span><br><span class="line">    <span class="comment">//     [</span></span><br><span class="line">    <span class="comment">//         "@babel/preset-env",</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             targets: &#123;</span></span><br><span class="line">    <span class="comment">//                 edge: "17",</span></span><br><span class="line">    <span class="comment">//                 firefox: "60",</span></span><br><span class="line">    <span class="comment">//                 chrome: "67",</span></span><br><span class="line">    <span class="comment">//                 safari: "11.1"</span></span><br><span class="line">    <span class="comment">//             &#125;,</span></span><br><span class="line">    <span class="comment">//             useBuiltIns: "usage",</span></span><br><span class="line">    <span class="comment">//             corejs: 2</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     ]</span></span><br><span class="line">    <span class="comment">// ],</span></span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"absoluteRuntime"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"corejs"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"helpers"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"regenerator"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"useESModules"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多页面打包通用方案"><a href="#多页面打包通用方案" class="headerlink" title="多页面打包通用方案"></a>多页面打包通用方案</h1><h2 id="webpack-config-js配置文件"><a href="#webpack-config-js配置文件" class="headerlink" title="webpack.config.js配置文件"></a>webpack.config.js配置文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index"</span>,</span><br><span class="line">    list: <span class="string">"./src/list"</span>,</span><br><span class="line">    detail: <span class="string">"./src/detail"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> htmlWebpackPlugins(&#123;</span><br><span class="line">    title: <span class="string">"index.html"</span>,</span><br><span class="line">    template: path.join(__dirname, <span class="string">"./src/index/index.html"</span>),</span><br><span class="line">    filename: <span class="string">"index.html"</span>,</span><br><span class="line">    chunks: [index]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> htmlWebpackPlugins(&#123;</span><br><span class="line">    title: <span class="string">"list.html"</span>,</span><br><span class="line">    template: path.join(__dirname, <span class="string">"./src/list/index.html"</span>),</span><br><span class="line">    filename: <span class="string">"list.html"</span>,</span><br><span class="line">    chunks: [list]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> htmlWebpackPlugins(&#123;</span><br><span class="line">    title: <span class="string">"detail.html"</span>,</span><br><span class="line">    template: path.join(__dirname, <span class="string">"./src/detail/index.html"</span>),</span><br><span class="line">    filename: <span class="string">"detail.html"</span>,</span><br><span class="line">    chunks: [detail]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="目录结构调整"><a href="#目录结构调整" class="headerlink" title="目录结构调整"></a>目录结构调整</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">    index</span><br><span class="line">        index.js</span><br><span class="line">        index.html</span><br><span class="line">    list</span><br><span class="line">        index.js</span><br><span class="line">        index.html</span><br><span class="line">    detail</span><br><span class="line">        index.js</span><br><span class="line">        index.html</span><br></pre></td></tr></table></figure>

<h2 id="使用glob-sync第三方库来匹配路径"><a href="#使用glob-sync第三方库来匹配路径" class="headerlink" title="使用glob.sync第三方库来匹配路径"></a>使用glob.sync第三方库来匹配路径</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装glob</span></span><br><span class="line">npm i glob -D</span><br><span class="line"><span class="comment">// MPA多页面打包通用方案</span></span><br><span class="line"><span class="comment">// webpack.config.js配置文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">"glob"</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entry = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> htmlWebpackPlugins = []</span><br><span class="line">    <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">"./src/*/index.js"</span>))</span><br><span class="line">    entryFiles.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> entryFile = entryFiles[index]</span><br><span class="line">        <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.js$/</span>)</span><br><span class="line">        <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>]</span><br><span class="line">        entry[pageName] = entryFile</span><br><span class="line">        htmlWebpackPlugins.push(<span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            title: pageName,</span><br><span class="line">            template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">            filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>,</span><br><span class="line">            chunks: [pageName],</span><br><span class="line">            inject: <span class="literal">true</span></span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        entry,</span><br><span class="line">        htmlWebpackPlugins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlWebpackPlugins&#125; = setMpa()</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"./dist"</span>),</span><br><span class="line">        filename: <span class="string">"[name].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        ...htmlWebpackPlugins <span class="comment">// 展开数组</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件监听"><a href="#文件监听" class="headerlink" title="文件监听"></a>文件监听</h1><p>轮询判断文件的最后编辑时间是否变化，某个文件发生了变化，并不会立刻告诉监听者，先缓存起来。<br>webpack开启监听模式的两种方式：</p>
<ol>
<li><p>命令行形式，启动监听后，需要手动刷新浏览器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">    <span class="string">"watch"</span>: <span class="string">"webpack --watch"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件里设置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch：<span class="literal">true</span>, <span class="comment">// 默认为false，不开启</span></span><br><span class="line">watchOptions： &#123;</span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>, <span class="comment">// 默认为空，不监听的文件或目录，支持正则</span></span><br><span class="line">    aggregateTimeout：<span class="number">300</span>, <span class="comment">// 监听到文件变化后，等300ms再去执行，默认300ms</span></span><br><span class="line">    poll: <span class="number">1000</span>  <span class="comment">// 判断文件是否发生变化是通过不停的询问系统指定文件有没有变化，默认每1000ms问一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/04/webpack2/" data-id="ckh5zzyq2001hq4v2feep4x1k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-项目实战一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/03/项目实战一/" class="article-date">
  <time datetime="2020-08-02T23:29:43.000Z" itemprop="datePublished">2020-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/03/项目实战一/">项目实战一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><ol>
<li>Vue + nuxt or react + nuxt</li>
<li>小程序， APP, H5, Node(express, koa, egg)</li>
<li>埋点(原理+第三方), 发布(gitlab, CI/CD), 性能</li>
<li>报错sentry, 报警(钉钉 / 微信 / 短信)</li>
<li>其他基建(搭建, docker, 看板, 文档, 权限, 组件)<h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><h2 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h2><h2 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h2>git 提交规范</li>
</ol>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen</span><br><span class="line">commitizen init cz-conventional-changelog --save-dev --save-exact</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add xxx</span><br><span class="line">git cz</span><br></pre></td></tr></table></figure>

<h1 id="文件上传知识点"><a href="#文件上传知识点" class="headerlink" title="文件上传知识点"></a>文件上传知识点</h1><h2 id="拖拽效果和进度条显示"><a href="#拖拽效果和进度条显示" class="headerlink" title="拖拽效果和进度条显示"></a>拖拽效果和进度条显示</h2><h2 id="网格进度条显示切片上传的进度"><a href="#网格进度条显示切片上传的进度" class="headerlink" title="网格进度条显示切片上传的进度"></a>网格进度条显示切片上传的进度</h2><h2 id="文件类型的校验"><a href="#文件类型的校验" class="headerlink" title="文件类型的校验"></a>文件类型的校验</h2><p>任何文件都是用二进制码表示的，通过vscode 插件hexdump查看图片文件的16进制表示，可以通过查看图片文件头信息来辨别文件类型。<br>常见的文件类型有png, jpg, gif。</p>
<p>JPG图片头信息: FFD8FF<br>PNG图片头信息: 89 50 4E 47 0D 0A 1A 0A<br>GIF图片头信息: 47494638<br>BMP图片头信息: 424D</p>
<h2 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h2><p>场景：校验文件是否存在，对于上传的图片都必须是唯一的，需要设置唯一标识。<br>不能简单通过文件名检验，对文件内容使用md5加密得到唯一的字符串。</p>
<p>问题：对于大文件计算md5值需要很多的时间，如何解决这个问题？</p>
<h3 id="web-worker-结合-spark-md5"><a href="#web-worker-结合-spark-md5" class="headerlink" title="web-worker 结合 spark-md5"></a>web-worker 结合 spark-md5</h3><p>web-worker开启多个子线程计算md5，每个切片计算md5值然后追加。</p>
<h3 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h3><p>window.requestIdleCallback()方法将在浏览器的空闲时段内计算文件md5。</p>
<h3 id="hashMap抽样计算md5"><a href="#hashMap抽样计算md5" class="headerlink" title="hashMap抽样计算md5"></a>hashMap抽样计算md5</h3><p>hashMap，对文件切片，取首中尾三个切片的全部数据，然后合并再计算md5。</p>
<h2 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h2><p>前端将文件切成一些指定大小的块上传到后端，后端将切片合并。</p>
<h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p>场景：由于网络通信故障，导致只上传了一部分，之后再上传只需要上传剩下的。<br>主要操作： 前端切片，分块上传，后端合并切片。</p>
<h2 id="秒传"><a href="#秒传" class="headerlink" title="秒传"></a>秒传</h2><p>场景：文件已经存在，则不需要再上传，前端直接显示秒传成功。</p>
<h2 id="异步任务并发数控制"><a href="#异步任务并发数控制" class="headerlink" title="异步任务并发数控制"></a>异步任务并发数控制</h2><p>场景：前端切片很多，会有大量的请求，会造成浏览器请求卡顿。</p>
<h2 id="错误重试"><a href="#错误重试" class="headerlink" title="错误重试"></a>错误重试</h2><p>场景：上传切片时，有些切片上传失败，会自动重新尝试有限次数。</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>场景：文件的切片大小不是固定的，而是根据网络响应速度自动切换切片大小。借鉴了TCP策略。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li>碎片清理</li>
<li>文件碎片存储在多个机器上</li>
<li>文件碎片备份</li>
<li>兼容性更好的requestIdleCallback</li>
<li>并发+慢启动</li>
<li>抽样hash+全量hash双重判断</li>
<li>websocket推送</li>
<li>cdn<h1 id="登陆验证"><a href="#登陆验证" class="headerlink" title="登陆验证"></a>登陆验证</h1>前端页面注册，登录功能，调用service api，service端查询数据库。<h2 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h2><h2 id="登陆功能"><a href="#登陆功能" class="headerlink" title="登陆功能"></a>登陆功能</h2>用户名密码验证： </li>
<li>简单的验证码。</li>
<li>token的管理，登陆以后的请求，都会自动带上token。<br>用户信息：</li>
<li>信息的增删改查。</li>
<li>头像文件上传。<h2 id="用户验证"><a href="#用户验证" class="headerlink" title="用户验证"></a>用户验证</h2><h2 id="保存用户状态"><a href="#保存用户状态" class="headerlink" title="保存用户状态"></a>保存用户状态</h2></li>
<li>session</li>
<li>jwt(json web token)<h2 id="登录验证码"><a href="#登录验证码" class="headerlink" title="登录验证码"></a>登录验证码</h2>安装svg-captcha<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S svg-captcha</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="markdown和代码高亮扩展"><a href="#markdown和代码高亮扩展" class="headerlink" title="markdown和代码高亮扩展"></a>markdown和代码高亮扩展</h1><h1 id="副文本编辑器"><a href="#副文本编辑器" class="headerlink" title="副文本编辑器"></a>副文本编辑器</h1><ol>
<li>第三方的库，tiny，wangEditor</li>
<li>开源的定制slate.js</li>
<li>专门开发团队定制在线word<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line">&lt;div contenteditable=<span class="string">"true"</span>&gt;</span><br><span class="line">        haha</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用document.execCommand('xxx') 自定义命令</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="点赞和关注"><a href="#点赞和关注" class="headerlink" title="点赞和关注"></a>点赞和关注</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/03/项目实战一/" data-id="ckh5zzyqg001uq4v2svn56tli" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常见web攻击" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/30/常见web攻击/" class="article-date">
  <time datetime="2020-07-30T11:28:48.000Z" itemprop="datePublished">2020-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/30/常见web攻击/">常见web攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>Cross Site Script跨站脚本攻击。跨站脚本攻击是指通过存在安全漏洞的web网站，在用户的浏览器内运行非法的非本站点的javaScript脚本而进行的一种攻击。</p>
<p>跨站脚本攻击可能的影响：</p>
<ol>
<li>利用虚假输入表单骗取用户个人信息</li>
<li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片。</li>
</ol>
<h2 id="xss攻击分类"><a href="#xss攻击分类" class="headerlink" title="xss攻击分类"></a>xss攻击分类</h2><h3 id="基于DOM的XSS攻击"><a href="#基于DOM的XSS攻击" class="headerlink" title="基于DOM的XSS攻击"></a>基于DOM的XSS攻击</h3><p>一般来说，hacker不能劫持正常的网络传输，但如果有内鬼通过中间人代理劫持HTML传输，就可以修改html文件在其中任意穿插恶意脚本，再发送给用户。一般来说，这种情况出现在运营商中间。</p>
<h3 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h3><p>步骤：</p>
<ol>
<li>首先hacker利用站点漏洞将一段恶意javaScript代码提交到网站的数据库中。</li>
<li>然后用户向网站请求包含了恶意javaScript脚本的页面。</li>
<li>当用户浏览该页面的时候，恶意脚本就会将用户的cookie信息等数据上传到hacker服务器。</li>
</ol>
<h3 id="反射型-url参数直接注入"><a href="#反射型-url参数直接注入" class="headerlink" title="反射型-url参数直接注入"></a>反射型-url参数直接注入</h3><p>hacker找到有漏洞的接口，用户给服务器发送的一些参数后，服务器没有经过处理，直接原样返回了部分参数。<br>就给黑客可趁之机，把恶意js脚本当参数发给服务器，服务器直接返回了这个脚本字符串，在浏览器DOM解析器中就能顺利引入这个恶意脚本达成hack。</p>
<p>反射型XSS和存储型XSS最大的区别就是，反射型不会在服务器存储脚本，需要诱骗用户主动点击包含漏洞的url。存储型主要在于上传恶意脚本到服务器，后面只需要等待用户点击网页。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通</span></span><br><span class="line">http://localhost:3000/?from=china</span><br><span class="line"></span><br><span class="line"><span class="comment">#  alert 尝试</span></span><br><span class="line">http://localhost:3000/?from=&lt;script&gt;alert(3)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#  获取Cookie</span></span><br><span class="line">http://localhost:3000/?from=&lt;script src=<span class="string">"http://localhost:4000/hack.js"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 短域名伪造https://dwz.cn/</span></span><br><span class="line"><span class="comment">#  伪造cookie入侵 chrome</span></span><br><span class="line">document.cookie=<span class="string">"kaikeba:sess=eyJ1c2VybmFtZSI6Imxhb3dhbmciLCJfZXhwaXJlIjoxNTUzNT Y1MDAxODYxLCJfbWF4QWdlIjo4NjQwMDAwMH0="</span></span><br></pre></td></tr></table></figure>

<h2 id="xss-攻击的危害"><a href="#xss-攻击的危害" class="headerlink" title="xss 攻击的危害"></a>xss 攻击的危害</h2><p>简单来说Script脚本能干啥就能干啥。</p>
<ol>
<li>获取页面的数据</li>
<li>获取Cookie</li>
<li>劫持前端逻辑</li>
<li>发送请求</li>
<li>偷取网站的任意数据</li>
<li>偷取用户的资料</li>
<li>偷取用户的秘密和登录态</li>
<li>欺骗用户<h2 id="xss-防范手段"><a href="#xss-防范手段" class="headerlink" title="xss 防范手段"></a>xss 防范手段</h2><h3 id="转义字符-amp-ejs转义"><a href="#转义字符-amp-ejs转义" class="headerlink" title="转义字符 &amp; ejs转义"></a>转义字符 &amp; ejs转义</h3>对于用户的输入永远做不可信任处理，最普遍的做法就是转义输入输出的内容，对引号，尖括号，斜杠进行转义。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>) </span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>) </span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>) </span><br><span class="line">    str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)  </span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>ejs模板引擎中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% code %&gt; 用于执行其中javaScript 代码</span><br><span class="line">&lt;%= code %&gt; 会对code进行html转义</span><br><span class="line">&lt;%- code %&gt; 将不会进行转义</span><br></pre></td></tr></table></figure>

<p>对于富文本来说，显然不能通过上面的办法来转义所有的字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用的是白名单过滤的办法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = <span class="built_in">require</span>(<span class="string">'xss'</span>)</span><br><span class="line"><span class="keyword">let</span> html = xss(<span class="string">'&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(html) <span class="comment">//  &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置Header"><a href="#设置Header" class="headerlink" title="设置Header"></a>设置Header</h3><p>禁止xss过滤，因为这个设置本身有很高的安全隐患，当注入相同名字的脚本时，会导致浏览器误判，使原本使用的同名的第三方库也无法使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">'x-xss-Protection'</span>, <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 禁止XSS过滤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 启用XSS过滤，浏览器默认启用。如果检测到跨站脚本攻击，浏览器将清除页面(删除不安全的部分)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1; mode=block 启用xss过滤，如果哦检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1; report=&lt;reporting-URI&gt; 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。</span></span><br></pre></td></tr></table></figure>

<h3 id="CSP-Content-Security-Policy"><a href="#CSP-Content-Security-Policy" class="headerlink" title="CSP(Content Security Policy)"></a>CSP(Content Security Policy)</h3><p>CSP,内容安全策略是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本和数据注入等攻击。这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。</p>
<p>CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少XSS攻击。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只允许加载本站资源</span></span><br><span class="line">Content-Security-Policy: default-src <span class="string">'self'</span></span><br><span class="line"><span class="comment"># 只允许加载HTTPS协议图片</span></span><br><span class="line">Content-Security-Policy: img-src https://*</span><br><span class="line"><span class="comment"># 不允许加载任何来源框架</span></span><br><span class="line">Content-Security-Policy: child-src <span class="string">'none'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试一下外部资源不能加载 http://localhost:3000/?from=&lt;script src="http://localhost:4000/hack.js"&gt; &lt;/script&gt;</span></span><br><span class="line">ctx.set(<span class="string">'Content-Security-Policy'</span>, <span class="string">"default-src 'self'"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="HttpOnly-Cookie"><a href="#HttpOnly-Cookie" class="headerlink" title="HttpOnly Cookie"></a>HttpOnly Cookie</h3><p>这是预防XSS攻击窃取用户cookie最有效的防御手段。web应用程序在设置cookie时，将其属性设为HttpOnly后，客户端脚本就不能读取到cookie，从而保护用户cookie信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.addHeader(<span class="string">'Set-Cookie'</span>, <span class="string">'uid=112; Path=/; HttpOnly'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="cookie值进行hash"><a href="#cookie值进行hash" class="headerlink" title="cookie值进行hash"></a>cookie值进行hash</h3><p>攻击者在访问信任网站A时，虽然浏览器可以在请求中带上cookie，但是网站A不仅仅通过cookie来判断用户身份，同时通过用户发送过来的内容中的伪随机数来判断请求真正是用户发送的。攻击者在请求A的时候，不能在提交的内容中产生伪随机数(通过cookie哈希化的值)。</p>
<h1 id="CSRF-Cross-Site-Request-Forgery"><a href="#CSRF-Cross-Site-Request-Forgery" class="headerlink" title="CSRF(Cross Site Request Forgery)"></a>CSRF(Cross Site Request Forgery)</h1><p>跨站请求伪造,是一种常见的Web攻击，它利用用户已经登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li><p>用户已经登录了站点A，并在本地记录了cookie。</p>
</li>
<li><p>在用户没有登出站点A的情况下(也就是cookie生效的情况下)，访问了恶意攻击提供的危险站点B(B站点要求访问A站点)。</p>
</li>
<li><p>A站点没有做任何CSRF防御。</p>
<h2 id="CSRF-攻击危害"><a href="#CSRF-攻击危害" class="headerlink" title="CSRF 攻击危害"></a>CSRF 攻击危害</h2></li>
<li><p>利用用户登录态</p>
</li>
<li><p>用户不知情</p>
</li>
<li><p>完成业务请求</p>
</li>
<li><p>盗取用户资金(转账，消费)</p>
</li>
<li><p>冒充用户发帖</p>
</li>
<li><p>损害网站声誉</p>
<h2 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h2></li>
<li><p>禁止第三方网站带Cookie(有兼容性问题)</p>
</li>
<li><p>同源检测(referer check),Https 不发送 referer。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="keyword">const</span> referer = ctx.request.header.referer</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Referer:'</span>, referer) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证码</p>
</li>
</ol>
<h1 id="点击劫持-clickjacking"><a href="#点击劫持-clickjacking" class="headerlink" title="点击劫持(clickjacking)"></a>点击劫持(clickjacking)</h1><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过iframe嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<h2 id="clickjacking-防御"><a href="#clickjacking-防御" class="headerlink" title="clickjacking 防御"></a>clickjacking 防御</h2><ol>
<li><p>X-FRAME-OPTIONS<br>X-FRAME-OPTIONS 是一个HTTP响应头，在现代浏览器有一个很好的支持。这个HTTP响应头就是为了防御用iframe嵌套的点击劫持攻击。该响应头有三个值可以选择，分别是DENY，表示页面不允许通过iframe的方式展示；SAMEORIGIN，表示页面可以在相同域名下通过iframe的方式展示；ALLOW-FROM，表示页面可以在指定来源的iframe中展示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">'X-FRAME-OPTIONS'</span>, <span class="string">'DENY'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>JS防御方式<br>判断当前页面窗口self和主窗口top是否相同当通过，当iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">id</span>=<span class="string">"click-jack"</span>&gt;</span></span><br><span class="line">        html &#123;   </span><br><span class="line">            display: none !important;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (self == top) &#123;  <span class="comment">// 相同，则没有iframe嵌入，移除样式</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">'click-jack'</span>)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.removeChild(style) </span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不相同，则有iframe嵌入，则跳转到自己的页面导航地址</span></span></span><br><span class="line">            top.location = self.location  </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填入特殊密码 </span></span><br><span class="line"><span class="number">1</span><span class="string">'or'</span><span class="number">1</span><span class="string">'='</span><span class="number">1</span></span><br><span class="line"><span class="comment">// 拼接后的SQL 这样也能从数据库查到</span></span><br><span class="line"> SELECT * FROM test.user WHERE username = <span class="string">'laowang'</span> AND password = <span class="string">'1'</span>or<span class="string">'1'</span>=<span class="string">'1'</span></span><br></pre></td></tr></table></figure>

<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户 输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`SELECT * FROM test.user WHERE username = '<span class="subst">$&#123;ctx.request.body.username&#125;</span>' AND password = '<span class="subst">$&#123;ctx.request.body.password&#125;</span>'`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sql'</span>, sql)</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> query(sql)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`SELECT * FROM test.user WHERE username = ? AND password = ?`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sql'</span>, sql)</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> query(sql, [ctx.request.body.username, ctx.request.body.password])</span><br></pre></td></tr></table></figure>

<p>严格限制web应用的数据库的操作权限，给此用户提供仅仅能满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。</p>
<p>后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>
<p>对进入数据库的特殊字符(‘,”,,&lt;,&gt;,&amp;,*,;等)进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如lodash的lodash._escapehtmlchar。</p>
<h1 id="OS命令注入"><a href="#OS命令注入" class="headerlink" title="OS命令注入"></a>OS命令注入</h1><p>OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。如果调用Shell时存在疏漏，就可以职系那个插入的非法命令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo</span></span><br><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'mz/child_process'</span>).exec; </span><br><span class="line"><span class="keyword">let</span> params = &#123;<span class="comment">/* 用户输入的参数 */</span>&#125;; </span><br><span class="line">exec(<span class="string">`git clone <span class="subst">$&#123;params.repo&#125;</span> /some/path`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果传入的参数如下, 就会出现删除文件夹的危险操作</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="string">'https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;'</span></span><br></pre></td></tr></table></figure>

<h1 id="请求劫持"><a href="#请求劫持" class="headerlink" title="请求劫持"></a>请求劫持</h1><h2 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h2><p>顾名思义，就是DNS服务器解析各个步骤被篡改，修改了域名解析的结果，使得访问到的不是预期的不是预期的IP地址。</p>
<h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><p>运营商劫持，只能升级到HTTPS。</p>
<h1 id="DDOS-distributed-denial-of-service"><a href="#DDOS-distributed-denial-of-service" class="headerlink" title="DDOS (distributed denial of service )"></a>DDOS (distributed denial of service )</h1><p>DDOS 不是一种攻击，而是一大类攻击的总称。它有几十种类型，新的攻击方法还在不断发明出来。网 站运行的各个环节，都可以是攻击目标。只要把一个环节攻破，使得整个流程跑不起来，就达到了瘫痪 服务的目的。<br>其中，比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承 受量，导致宕机。</p>
<h2 id="常见的攻击方式"><a href="#常见的攻击方式" class="headerlink" title="常见的攻击方式"></a>常见的攻击方式</h2><h3 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h3><p>此攻击通过向目标发送具有欺骗性源IP地址的大量TCP“初始连接请求”SYN数据包来利用TCP握 手。目标机器响应每个连接请求，然后等待握手中的最后一步，这一步从未发生过，耗尽了进程 中的目标资源。</p>
<h3 id="HTTP-Flood"><a href="#HTTP-Flood" class="headerlink" title="HTTP Flood"></a>HTTP Flood</h3><p>此攻击类似于同时在多个不同计算机上反复按Web浏览器中的刷新 - 大量HTTP请求泛滥服务器， 导致拒绝服务。</p>
<h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><h3 id="备份网站"><a href="#备份网站" class="headerlink" title="备份网站"></a>备份网站</h3><p>备份网站不一定是全功能的，如果能做到全静态浏览，就能满足需求。最低限度应该可以显示公告，告诉用户，网站出现了问题，正在全力抢修。</p>
<h3 id="HTTP请求的来拦截"><a href="#HTTP请求的来拦截" class="headerlink" title="HTTP请求的来拦截"></a>HTTP请求的来拦截</h3><p>高防IP- 靠谱的运营商 多个Docker<br>硬件： 服务器 防火墙<br>带宽扩容 + cdn<br>提高犯罪成本</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/30/常见web攻击/" data-id="ckh5zzyq5001jq4v2poclh5ki" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/23/webpack/" class="article-date">
  <time datetime="2020-07-23T05:54:04.000Z" itemprop="datePublished">2020-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/23/webpack/">webpack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack is a module bundler(模块打包工具)，它会从入口模块出发，识别出源码中的模块导入语句，递归找出入口文件的所有依赖，将入口和其所有的依赖打包到一个单独的文件中。是工程化，自动化思想在前端开发中的体现。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>nodejs，版本参考官网发布的最新版本，可以提升webpack的打包速度。</p>
<h1 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h1><p>推荐项目安装，不要全局安装，全局安装webpack，这会将你项目中的webpack锁定到指定版本，造成不同的项目中因为webpack依赖不同版本⽽而导致冲突，构建失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装最新稳定版本</span></span><br><span class="line">npm i -D webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line">npm i -D webpack@&lt;version&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装最新的体验版本</span></span><br><span class="line">npm i -D webpack@beta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装webpack V4+版本时，需要额外安装webpack-cli</span></span><br><span class="line">npm i -D webpack-cli</span><br></pre></td></tr></table></figure>

<h1 id="检查安装"><a href="#检查安装" class="headerlink" title="检查安装"></a>检查安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command not found 默认在全局环境中查找</span></span><br><span class="line">webpack -v </span><br><span class="line"><span class="comment"># npx帮助我们在项目中的node_modules里查找webpack</span></span><br><span class="line">npx webpack -v</span><br><span class="line"><span class="comment"># 到当前的node_modules模块里指定webpack</span></span><br><span class="line">./node_modules/.bin/webpack -v</span><br></pre></td></tr></table></figure>

<h1 id="启动webpack执行构建"><a href="#启动webpack执行构建" class="headerlink" title="启动webpack执行构建"></a>启动webpack执行构建</h1><h2 id="webpack默认配置"><a href="#webpack默认配置" class="headerlink" title="webpack默认配置"></a>webpack默认配置</h2><ol>
<li>webpack默认支持JS模块和JSON模块</li>
<li>支持CommonJS，AMD和ES module等模块类型</li>
<li>webpack4支持零配置使用，但是很弱，稍微复杂些的场景都需要额外的扩展。<h2 id="准备执行构建"><a href="#准备执行构建" class="headerlink" title="准备执行构建"></a>准备执行构建</h2></li>
<li>新建src文件夹</li>
<li>新建src/index.js, src/index.json, src/other.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * webpack 打包入口文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 依赖文件</span></span><br><span class="line"><span class="keyword">const</span> json =<span class="built_in">require</span>(<span class="string">"./index.json"</span>) <span class="comment">// Common JS</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">"./other.js"</span>    <span class="comment">// ES Module</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(json, add(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"JSON"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/other.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+ n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a>执行构建</h2><p>原理:就是通过shell脚本在node_modules/.bin目录下创建一个软链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npx 方式: 会执行项目node_modules/.bin/xxx目录下的包</span></span><br><span class="line">npx webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm script方式</span></span><br><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>修改package.json文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"test"</span>: <span class="string">"webpack"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构建成功"><a href="#构建成功" class="headerlink" title="构建成功"></a>构建成功</h2><p>在项目根目录下会生成一个dist目录，里面会有一个main.js，这个文件是一个可执行的JavaScript文件，里面包含webpack BooStrap启动函数。</p>
<h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>webpack 默认配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./src/index.js"</span>,  <span class="comment">// webpack执行构建的入口，必填</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"main.js"</span>,  <span class="comment">// 将所有依赖的模块合并输出到main.js</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"./dist"</span>)  <span class="comment">// 输出文件的存放路径，必须是绝对路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="webpack配置核心概念"><a href="#webpack配置核心概念" class="headerlink" title="webpack配置核心概念"></a>webpack配置核心概念</h1><p>零配置是很弱，特定的需求，总是需要shiy自己进行配置。webpack有默认的配置文件，叫webpack.config.js，我们可以对这个文件进行修改，进行个性化配置。也可以使用自定义配置文件，通过–config webpack.config.dev.js 来指定webpack使用哪个配置文件来执行构建。</p>
<h2 id="webpack-config-js配置基础结构"><a href="#webpack-config-js配置基础结构" class="headerlink" title="webpack.config.js配置基础结构"></a>webpack.config.js配置基础结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./src/index.js"</span>, <span class="comment">// 打包入口文件</span></span><br><span class="line">    output: <span class="string">"./dist"</span>, <span class="comment">// 输出路径</span></span><br><span class="line">    mode: <span class="string">"production"</span>, <span class="comment">// 打包环境</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [  <span class="comment">// loader模块处理</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: <span class="string">"style-loader"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()] <span class="comment">// 插件配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>指定webpack打包入口文件：Webpack执行构建的第一步将从entry开始。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单入口SPA，本质是个字符串</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效如下</span></span><br><span class="line">entry: <span class="string">"./src/index.js"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多入口entry是个对象</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    login: <span class="string">"./src/login.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>打包转换后的文件输出到磁盘位置，在webpack经过一系列处理并得出最终想要的代码后输出结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">"build.js"</span>, <span class="comment">// 输出文件的名称</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>) <span class="comment">// 输出文件到磁盘的目录，必须是绝对路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多入口的处理</span></span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">"[name][chunkhash:8].js"</span>, <span class="comment">// 利用占位符，文件名称不要重复</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>) <span class="comment">// 输出文件到磁盘的目录，必须是绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>mode用来指定当前的构建环境，production，development，none。<br>设置mode可以自动触发webpack内置的函数，达到优化的效果。如果没有设置，webpack会将mode 的默认值设置为production。</p>
<p>development: 会将DefinePlugin中process.env.NODE_ENV的值设置为development。启用NamedChunksPlugin和NamedModulesPlugin。development的开启有利于热更新的处理，识别哪个模块变化了。</p>
<p>production: 会将DefinePlugin中process.env.NODE_ENV的值设置为production。启用FlagDependencyUsagePlugin，FlagIncludedChunksPlugin，ModuleConcatenationPlugin，NoEmitOnErrorsPlugin，OccurrenceOrderPlugin，SideEffectsPlugin 和 TerserPlugin。production开启会有帮助模块压缩，处理副作用等一些功能。</p>
<p>none: 不使用任何默认优化选项。</p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>模块解析，模块转换器，用于把模块原内容按照需求转换成新内容。</p>
<p>webpack是模块打包工具，而模块不仅仅是js，还可以是CSS，图片或者其他格式。</p>
<p>但是webpack默认只知道如何处理js和JSON模块，那么其他格式的模块处理就需要loader了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的loader</span></span><br><span class="line">style-loader</span><br><span class="line">css-loader</span><br><span class="line">less-loader</span><br><span class="line">sass-loader</span><br><span class="line">ts-loader <span class="comment">// 将TS转换成JS</span></span><br><span class="line">babel-loader <span class="comment">// 转换ES6，7等js新特性语法</span></span><br><span class="line">file-loader <span class="comment">// 处理图片子图</span></span><br><span class="line">eslint-loader</span><br></pre></td></tr></table></figure>

<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>模块，在Webpack里一切皆模块，一个模块对应着一个文件。Webpack会从配置里的entry开始递归找出所有依赖的模块。</p>
<p>当webpack处理到不认识的模块时，需要在webpack中的module处进行配置，当检测到是什么格式的模块，应使用什么loader来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.xxx$/</span>, <span class="comment">// 指定匹配规则</span></span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'xxx-loader'</span> <span class="comment">// 指定使用的loader</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>file-loader : 处理静态资源模块<br>原理是把打包入口中识别出的资源模块，移动到输出目录，并且返回一个地址名称。</li>
</ol>
<p>使用场景：当需要模块，仅仅是从项目源代码位置挪动到打包目录，就可以使用file-loader来处理，txt，svg，csv，excel，图片资源等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装loader</span></span><br><span class="line">npm install file-loader -D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">            use: &#123;                               <span class="comment">// use使用一个loader可以用对象，字符串，两个loader需要用数组</span></span><br><span class="line">                loader: <span class="string">"file-loader"</span>,</span><br><span class="line">                options: &#123;                       <span class="comment">// 额外的配置，输出资源名称。</span></span><br><span class="line">                    name: <span class="string">"[name]_[hash].[ext]"</span>, <span class="comment">// []括号里面是占位符，name表示老资源模块的名称，ext表示老资源模块的后缀名</span></span><br><span class="line">                    outputPath: <span class="string">"images/"</span>        <span class="comment">// 打包后的存放位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>css处理<br>css-loader 分析css模块之间的关系，并合并成一个css。<br>loader执行顺序: 从后往前。<br>style-loader会把css-loader生成的内容，以style挂载到页面的header部分。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install style-loader css-loader -D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: <span class="string">"style-loader"</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            injectType: <span class="string">"singletonStyleTag"</span> <span class="comment">// 将所有的style标签合并成一个style标签</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;， <span class="string">"css-loader"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>plugin可以在webpack运行到某个阶段的时候，帮你做一些事情，类似于生命周期的概念。</p>
<p>扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</p>
<h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>htmlwebpackplugin会在打包结束后，自动生成一个html文件，并把打包生成的js模块引入到该html中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  安装</span></span><br><span class="line">npm install -D html-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">title: 用来生成页面的title元素</span><br><span class="line">filename: 输出的HTML文件名，默认是index.html, 也可以直接配置带有子目录。</span><br><span class="line">template: 模板文件路径，支持加载器。</span><br><span class="line">inject: <span class="literal">true</span>|<span class="string">'head'</span>| <span class="string">'body'</span>|<span class="literal">false</span>, 注入所有的资源到特定的template或templateContent中，如果设置为<span class="literal">true</span>或者body，所有的javascript资源将被放到body元素的底部，<span class="string">'head'</span>将放到head元素中。</span><br><span class="line">favicon: 添加特定的favicon路径到输出的HTML文件中。</span><br><span class="line">minify: &#123;&#125; | <span class="literal">false</span>, 传递html-minifier选项给minify输出</span><br><span class="line">hash: <span class="literal">true</span>| <span class="literal">false</span>, 如果为<span class="literal">true</span>，将添加一个唯一的webpack编译hash到所有包含的脚本和css文件，对于解除cache很有用。</span><br><span class="line">cache: <span class="literal">true</span> | <span class="literal">false</span>, 如果为<span class="literal">true</span>，这是默认值，仅仅在文件修改之后才会发布文件。</span><br><span class="line">showErrors: <span class="literal">true</span>|<span class="literal">false</span>,如果为<span class="literal">true</span>，这是默认值，错误信息会写入到html页面中。</span><br><span class="line">chunks: 允许只添加某些模块（比如，仅仅unit test）。</span><br><span class="line">chunksSortMode: 允许控制块添加到页面之前的排序方式，支持的值: <span class="string">'none'</span>| <span class="string">'default'</span> | &#123;<span class="function"><span class="keyword">function</span>&#125;-<span class="title">default</span>: '<span class="title">auto</span>'</span></span><br><span class="line"><span class="function"><span class="title">excludeChunks</span>: 允许跳过某些块（比如，跳过单元测试的块）</span></span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            title: <span class="string">"my app"</span>,</span><br><span class="line">            filename: <span class="string">"app.html"</span>,</span><br><span class="line">            template: <span class="string">"./src/index.html"</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成新的index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>my app<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>clean-webpack-plugin 插件就是每次生成代码之前 先将 dist 目录 清空<br>一般这个插件是配合 webpack -p 这条命令来使用，就是说在为生产环境编译文件的时候，先把 build或dist (就是放生产环境用的文件) 目录里的文件先清除干净，再生成新的。</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D clean-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = reuqire(<span class="string">"clean-webpack-plugin"</span>)</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>源代码与打包后的代码的映射关系，通过sourceMap定位到源代码。<br>在dev模式下，默认开启，可以在配置文件里设置关闭。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">"none"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选项：</span></span><br><span class="line"><span class="string">"eval"</span> 速度最快，使用<span class="built_in">eval</span>包裹模块代码</span><br><span class="line"><span class="string">"source-map"</span> 产生.map文件</span><br><span class="line"><span class="string">"cheap"</span> 较快，不包含列信息</span><br><span class="line"><span class="string">"Module"</span> 第三方模块，包含loader的sourcemap</span><br><span class="line"><span class="string">"inline"</span> 将.map作为DataURI嵌入，不单独生成.map文件</span><br></pre></td></tr></table></figure>

<p>配置推荐</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">"cheap-module-eval-source-map"</span>, <span class="comment">// 开发环境配置</span></span><br><span class="line"><span class="comment">// 线上不推荐开启</span></span><br><span class="line">devtool: <span class="string">"cheap-module-source-map"</span>, <span class="comment">// 线上生成配置。</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/23/webpack/" data-id="ckh5zzypx001bq4v23izv4ned" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TypeScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/22/TypeScript/" class="article-date">
  <time datetime="2020-07-22T01:38:40.000Z" itemprop="datePublished">2020-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/22/TypeScript/">TypeScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>TypeScript是JavaScript的超集，它可编译为纯JavaScript，是一种给JavaScript添加特性的语言扩展。</p>
<p>TS有如下特点：</p>
<ul>
<li>类型注解和编译时类型检查</li>
<li>基于类的面向对象编程</li>
<li>泛型</li>
<li>接口</li>
<li>声明文件</li>
</ul>
<h1 id="创建基于TS的Vue项目"><a href="#创建基于TS的Vue项目" class="headerlink" title="创建基于TS的Vue项目"></a>创建基于TS的Vue项目</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在已经存在项目中安装ts，破坏性的</span></span><br><span class="line">vue add @vue/typescript</span><br></pre></td></tr></table></figure>

<h1 id="类型注解和编译时类型检查"><a href="#类型注解和编译时类型检查" class="headerlink" title="类型注解和编译时类型检查"></a>类型注解和编译时类型检查</h1><p>类型注解：变量后面通过冒号+类型来做类型注解</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用的类型：string, number, boolean, void, any, object, null, undefined</span></span><br><span class="line"><span class="comment">// 类型注解</span></span><br><span class="line"><span class="keyword">let</span>  title: string;</span><br><span class="line">title = <span class="string">'1'</span>; <span class="comment">// right</span></span><br><span class="line">title = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 类型推论</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'richard'</span></span><br><span class="line">name = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="keyword">let</span> nameList: string[];</span><br><span class="line">nameList = [<span class="string">"tom"</span>]; <span class="comment">// Array&lt;string&gt;</span></span><br><span class="line"><span class="comment">// 任意类型</span></span><br><span class="line"><span class="keyword">let</span> foo: any;</span><br><span class="line">foo = <span class="string">"xx"</span>;</span><br><span class="line">foo = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// any类型也可以用于数组</span></span><br><span class="line"><span class="keyword">let</span> list: any[];</span><br><span class="line">list = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">'xx'</span>]</span><br><span class="line"><span class="comment">// 函数中的类型，参数有类型，返回值有类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类作为类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Feature</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor函数 中声明的参数会被作为成员属性</span></span><br><span class="line">    <span class="keyword">constructor</span>(public id: number, public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> features: Feature[] = [&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>: <span class="string">'haha'</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>: <span class="string">'hehe'</span>&#125;]</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="必填参数"><a href="#必填参数" class="headerlink" title="必填参数"></a>必填参数</h2><p>参数一旦声明，就要求传递，且类型需要符合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">'tom'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>参数名后面加上问号，变成可选参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person:string, msg?: string</span>) :<span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span> + person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person:string, msg = <span class="string">'haha'</span></span>) :<span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span> + person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>同名函数，通过参数数量，参数类型的区别来返回不同类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明，再实现</span></span><br><span class="line"><span class="comment">// 声明1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">a: &#123;name: string&#125;</span>) :<span class="title">string</span>;</span></span><br><span class="line"><span class="function">// 声明2</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">info</span>(<span class="params">a: string</span>) : </span>&#123;name: string&#125;;</span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">a: &#123;name:string&#125; | string</span>) : </span>&#123;name:string&#125; | string &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.name</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">name</span>: a&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(info(&#123;<span class="attr">name</span>: <span class="string">'tom'</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(info(<span class="string">'tom'</span>));</span><br></pre></td></tr></table></figure>

<h2 id="方法直接作为回调函数"><a href="#方法直接作为回调函数" class="headerlink" title="方法直接作为回调函数"></a>方法直接作为回调函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addFeature(event: KeyboardEvent)：<span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="comment">// 类型断言</span></span><br><span class="line">    <span class="keyword">const</span> input = event.target <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line">    <span class="keyword">this</span>.feature.push(input.value);</span><br><span class="line">    input.value = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员属性</span></span><br><span class="line">    private _foo: string;  <span class="comment">// 私有属性，仅类的内部使用，不能在类的外部访问。</span></span><br><span class="line">    protected bar: string; <span class="comment">// 保护属性，子类可以访问</span></span><br><span class="line">    public zoo: string;    <span class="comment">// 公共的，都可以访问</span></span><br><span class="line">    <span class="comment">// 构造函数参数有修饰符，能够定义为成员属性</span></span><br><span class="line">    <span class="keyword">constructor</span>(private tua = 'tua') &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存取器：属性方式访问，可以添加额外逻辑，控制读写性</span></span><br><span class="line">    <span class="comment">// vue中存取器可以用作计算属性</span></span><br><span class="line">    <span class="keyword">get</span> foo() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._foo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> foo(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>._foo = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法也有修饰符</span></span><br><span class="line">    private someMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubComp</span> <span class="keyword">extends</span> <span class="title">MyComp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类中的 protected 修饰的变量bar，只能在子类通过this.bar访问到，不能在子类的实例中访问到。</span></span><br><span class="line">    <span class="keyword">constructor</span>(a: string) &#123;</span><br><span class="line">        <span class="keyword">super</span>(a); <span class="comment">// 将继承类构造函数的参数传入到父类构造函数中。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 - interface"></a>接口 - interface</h1><p>接口仅约束结构，不要求实现，使用更简单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Feature &#123;</span><br><span class="line">    id: number;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数参数为interface类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFeature</span>(<span class="params">feature: Feature</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> feature.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向接口编程-类实现接口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line">interface Person &#123;</span><br><span class="line">    firstName: string;  <span class="comment">// 要求必须有firstName属性</span></span><br><span class="line">    lastName: string;   <span class="comment">// 要求必须有lastName属性</span></span><br><span class="line">    sayHello(): string; <span class="comment">// 要求实现sayHello方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> <span class="title">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(public firstName = '', public lastName = '') &#123;&#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span> + <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象实例</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> Greeter(<span class="string">'richard'</span>, <span class="string">'zhao'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面向接口编程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(greeting(user));</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型(Generics)是指定义函数，接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。以此增加代码通用性。使用场景：有时候要求传入的参数类型和返回的结果类型一致，但传入的参数类型并不是确定的。类型变量T可以捕获用户传入的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用泛型</span></span><br><span class="line">interface Result &#123;</span><br><span class="line">    data: Feature[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用泛型</span></span><br><span class="line">interface Result&lt;T&gt; &#123;</span><br><span class="line">    data: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>): <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data: any = [&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'richard'</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>:<span class="string">'coke'</span>&#125;]</span><br><span class="line">    <span class="keyword">return</span> &#123; data &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>装饰器用于扩展类或者它的属性和方法。@xx就是装饰器的写法。</p>
<h2 id="Component-组件声明"><a href="#Component-组件声明" class="headerlink" title="@Component-组件声明"></a>@Component-组件声明</h2><p>典型应用是组件装饰器@Component,</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        HelloWorld</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Component装饰器的实现内部就是调用了Vue.extend(options).</span></span><br></pre></td></tr></table></figure>

<h2 id="Prop-属性声明"><a href="#Prop-属性声明" class="headerlink" title="@Prop-属性声明"></a>@Prop-属性声明</h2><p>除了在@Component中声明，还可以采用@Prop的方式声明组件属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    @Prop(&#123;<span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    private msg!: string; <span class="comment">// !为明确赋值断言，意味着不需要检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Emit-事件处理-watch-监听"><a href="#Emit-事件处理-watch-监听" class="headerlink" title="@Emit-事件处理 @watch-监听"></a>@Emit-事件处理 @watch-监听</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派发事件</span></span><br><span class="line">@Emit(<span class="string">'addFeature'</span>) <span class="comment">// 事件名称</span></span><br><span class="line">private addFeature(event: any) &#123;...&#125;</span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">@Watch(<span class="string">'msg'</span>)</span><br><span class="line">onMsgChange() &#123;..&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vuex使用：vuex-class"><a href="#vuex使用：vuex-class" class="headerlink" title="vuex使用：vuex-class"></a>vuex使用：vuex-class</h2><p>vuex-class为vue-class-component提供Vuex状态绑定帮助方法。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex-class -S</span><br></pre></td></tr></table></figure>

<h3 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        features: [</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"类型"</span>, <span class="attr">version</span>: <span class="string">"1.0"</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"编译型语言"</span>, <span class="attr">version</span>: <span class="string">"1.0"</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addFeatureMutation(state: any, featureName) &#123;</span><br><span class="line">            state.features.push(&#123; <span class="attr">id</span>: state.features.length + <span class="number">1</span>, <span class="attr">name</span>: featureName &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        addFeatureAction(&#123; commit &#125;, featureName) &#123;</span><br><span class="line">            commit(<span class="string">"addFeatureMutation"</span>, featureName);    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; State, Action, Mutation &#125; <span class="keyword">from</span> <span class="string">'vuex-class'</span>;</span><br><span class="line"></span><br><span class="line">@component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Feature</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态，动作，变更映射</span></span><br><span class="line">    @State features!: string[];</span><br><span class="line">    @Action addFeatureAction: any;</span><br><span class="line">    @Mutation addFeatureMutation: any;</span><br><span class="line"></span><br><span class="line">    private addFeature(event) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event);</span><br><span class="line">        <span class="keyword">this</span>.addFeatureAction(event.target.value);</span><br><span class="line">        event.target.value = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器原理"><a href="#装饰器原理" class="headerlink" title="装饰器原理"></a>装饰器原理</h2><p>装饰器其实就是函数，被装饰的部分会作为参数传入函数，它返回一个表达式，以供装饰器在运行时调用。使用@expression的形式。</p>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。<br>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。<br>类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target 是构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target: Function</span>) </span>&#123;</span><br><span class="line">    target.prototype.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果类装饰器返回一个值，它会使用提供的构造函数来替代类的声明</span></span><br><span class="line">&#125;</span><br><span class="line">@log</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    bar = <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo()</span><br><span class="line">foo.log();</span><br></pre></td></tr></table></figure>

<h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。如果方法装饰器返回一个值，它会被用作方法的属性描述符。</p>
<p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数:</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的属性描述符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">value: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        descriptor.enumerable = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    <span class="keyword">constructor</span>(message: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @enumerable(<span class="literal">false</span>)</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>属性装饰器声明在一个属性声明之前（紧靠着属性声明）。属性描述符不会做为参数传入属性装饰器。<br>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。<blockquote>
<p>属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mua</span>(<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">    target[name] = <span class="string">'mua...'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    @mua ns!: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.ns)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以接受参数的写法，返回的是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mua</span>(<span class="params">param: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">        target[name] = param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @mua('xxx') ns!:string;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>参数装饰器声明在一个参数声明之前（紧靠着参数声明）。参数装饰器应用于类构造函数或方法声明。<br>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>参数在函数参数列表中的索引。</li>
</ol>
<blockquote>
<p>参数装饰器只能用来监视一个方法的参数是否被传入。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    greeting: string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(message: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greet(@required name: string) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/22/TypeScript/" data-id="ckh5zzyp8000lq4v2rlq77akh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DS-js-数据驱动/">DS.js 数据驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/How-to-use-hexo-create-a-blog/">How to use hexo create a blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas-基础/">canvas 基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 20px;">CSS</a> <a href="/tags/DOM/" style="font-size: 10px;">DOM</a> <a href="/tags/DS-js-数据驱动/" style="font-size: 10px;">DS.js 数据驱动</a> <a href="/tags/How-to-use-hexo-create-a-blog/" style="font-size: 10px;">How to use hexo create a blog</a> <a href="/tags/canvas-基础/" style="font-size: 10px;">canvas 基础</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/05/D3/">D3</a>
          </li>
        
          <li>
            <a href="/2020/10/09/CSS总结/">CSS总结</a>
          </li>
        
          <li>
            <a href="/2020/10/09/DOM/">DOM</a>
          </li>
        
          <li>
            <a href="/2020/10/09/canvas基础/">canvas</a>
          </li>
        
          <li>
            <a href="/2020/10/09/设计模式/">设计模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Richard.Zhao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>