<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>RICHARD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Technology Blog">
<meta name="keywords" content="Python, JS, Vue, NodeJS">
<meta property="og:type" content="website">
<meta property="og:title" content="RICHARD">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="RICHARD">
<meta property="og:description" content="Technology Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RICHARD">
<meta name="twitter:description" content="Technology Blog">
  
    <link rel="alternate" href="/atom.xml" title="RICHARD" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RICHARD</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RICHARD BLOG</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-React-Native-Flutter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/React-Native-Flutter/" class="article-date">
  <time datetime="2020-07-10T15:45:31.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/React-Native-Flutter/">React Native&amp; Flutter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/React-Native-Flutter/" data-id="ckh44mztb000e4sv28lea1ub2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NodeJS高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/23/NodeJS高级/" class="article-date">
  <time datetime="2020-06-23T08:34:48.000Z" itemprop="datePublished">2020-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/NodeJS高级/">NodeJS高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="I-O处理"><a href="#I-O处理" class="headerlink" title="I/O处理"></a>I/O处理</h1><h2 id="同步与异步读取文件"><a href="#同步与异步读取文件" class="headerlink" title="同步与异步读取文件"></a>同步与异步读取文件</h2><h2 id="fs方法"><a href="#fs方法" class="headerlink" title="fs方法"></a>fs方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fs.truncate</td>
<td>截断文件到指定的长度</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/23/NodeJS高级/" data-id="ckh44mzt5000c4sv2y17tdsk3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javaScript异步编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/23/javaScript异步编程/" class="article-date">
  <time datetime="2020-06-23T02:41:43.000Z" itemprop="datePublished">2020-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/javaScript异步编程/">javaScript异步编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><p>javascript中将任务的执行方式分为两种：同步和异步。<br>同步：后一个任务等前一个任务结束之后再执行，程序的执行顺序和任务的排列顺序是一致的。<br>异步：每一个任务有一个或多个回调函数，前一个任务结束，会去执行它的回调函数。后一个任务不会等前一个任务结束，就会去执行。所以程序的执行顺序与任务的顺序是不一致的，异步的。</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步"></a>为什么需要异步</h2><ul>
<li>JS的执行环境是单线程(single thread)</li>
<li>I/O处理需要回调函数异步处理(异步I/O)</li>
<li>前端异步I/O可以消除UI阻塞，提高用户体验</li>
<li>放在后端则可以提高CPU和内存的利用率</li>
</ul>
<h2 id="异步操作串联处理"><a href="#异步操作串联处理" class="headerlink" title="异步操作串联处理"></a>异步操作串联处理</h2><p>有时候希望异步操作队列，按照期望顺序执行，比如在某个ajax异步操作之后，获取网络资源之后，再去执行另一个异步操作。这样的需求是很常见的，因此就需要将异步操作串联。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>采用回调的方式，可以把同步操作，变成异步操作。缺点：形成回调地狱，耦合度高，流程混乱，而且每个任务只能指定一个回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// f1的任务代码</span></span><br><span class="line">        callback();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过回调的方式，串联异步操作。</span></span><br><span class="line">f1(f2)</span><br></pre></td></tr></table></figure>

<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="function">(<span class="params">name, delay = <span class="number">100</span></span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Log...<span class="subst">$&#123;name&#125;</span>:`</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString())</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, delay)</span><br><span class="line">&#125;)</span><br><span class="line">promise(<span class="string">'promise1'</span>).then(promise(<span class="string">'promise2'</span>)).then(promise(<span class="string">'promise3'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>ES6新引入Generator函数，可以通过yield关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。<br>function* 称为Generator函数，函数内部有yield表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'one'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'1'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'two'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'three'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'3'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = func()</span><br><span class="line"><span class="built_in">console</span>.log(f.next())</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: '1', done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: '2', done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: '3', done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过迭代器执行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> func()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用generator串联异步操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟异步操作</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Log...<span class="subst">$&#123;name&#125;</span>:`</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString())</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// generator函数</span></span><br><span class="line"><span class="keyword">const</span> generatorFunc = <span class="function"><span class="keyword">function</span>* (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> promise(name + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> promise(name + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> promise(name + <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> promise(name + <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归执行generator</span></span><br><span class="line"><span class="keyword">const</span> callFunc = <span class="function"><span class="keyword">function</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it = generator.next().value) &#123;</span><br><span class="line">        it.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            callFunc(generator)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">callFunc(generatorFunc(<span class="string">'co-generator'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async/await 是es7推出的一套关于异步的终极解决方案。</p>
<ul>
<li>任何一个await语句后面的Promise对象变为reject状态，那么整个async函数都会中断执行。</li>
<li>async函数返回的Promise对象，必须等到内部所有await命令后面的Promise对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Log...<span class="subst">$&#123;name&#125;</span>:`</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString())</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncFunc = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> promise(<span class="string">'async 1'</span>)</span><br><span class="line">    <span class="keyword">await</span> promise(<span class="string">'async 2'</span>)</span><br><span class="line">    <span class="keyword">await</span> promise(<span class="string">'async 3'</span>)</span><br><span class="line">    <span class="keyword">await</span> promise(<span class="string">'async 4'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br></pre></td></tr></table></figure>

<h3 id="事件监听方式处理"><a href="#事件监听方式处理" class="headerlink" title="事件监听方式处理"></a>事件监听方式处理</h3><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncFunc = <span class="function"><span class="params">name</span> =&gt;</span> <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Log...<span class="subst">$&#123;name&#125;</span>:`</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString())</span><br><span class="line">        event.emit(<span class="string">'end'</span>)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventArray = [</span><br><span class="line">    asyncFunc(<span class="string">'event1'</span>),</span><br><span class="line">    asyncFunc(<span class="string">'event2'</span>),</span><br><span class="line">    asyncFunc(<span class="string">'event3'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; EventEmitter &#125; = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="comment">// 监听end事件</span></span><br><span class="line">event.on(<span class="string">'end'</span>, () =&gt; i &lt; eventArray.length &amp;&amp; eventArray[i++](event))</span><br><span class="line"><span class="comment">// 触发end事件</span></span><br><span class="line">event.emit(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="EventEmitter源码解析"><a href="#EventEmitter源码解析" class="headerlink" title="EventEmitter源码解析"></a>EventEmitter源码解析</h3><p>订阅/发布机制</p>
<h2 id="异步操作并行处理"><a href="#异步操作并行处理" class="headerlink" title="异步操作并行处理"></a>异步操作并行处理</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/23/javaScript异步编程/" data-id="ckh44mzty000z4sv2ovgp12xn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/22/HTTP缓存/" class="article-date">
  <time datetime="2020-06-22T06:33:56.000Z" itemprop="datePublished">2020-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/22/HTTP缓存/">HTTP缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTTP缓存是什么"><a href="#HTTP缓存是什么" class="headerlink" title="HTTP缓存是什么"></a>HTTP缓存是什么</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当浏览器加载一个页面的html时，引用的外部资源也会加载。但这些外部资源比如图片，CSS，js都不经常变化。如果每次都加载这些资源，会带来资源的浪费。而且加载时间过长也会影响用户体验。<br>HTTP缓存技术就是为了解决这个问题出现。HTTP缓存技术就是将静态资源存储在浏览器内部，下次请求相同的资源时可以直接使用。<br>如何使资源一旦更新，缓存也要随之更新，需要通过使用一些策略来保证。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>提高首屏加载速度，优化用户体验。</li>
<li>减少流量消耗</li>
<li>减轻服务器压力<h1 id="强缓存策略"><a href="#强缓存策略" class="headerlink" title="强缓存策略"></a>强缓存策略</h1>强缓存通过设置定时器的方式，设置静态资源的有效期，如果超过有效期就认为缓存作废，需要重新请求。<br>如果设置了expires和cache-control都会访问本地缓存直接验证看是否过期，如果没过期,不去请求服务器,直接使用本地缓存，并返回200。</li>
</ul>
<h2 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h2><p>expires是HTTP1.0 中定义的缓存字段。当请求一个资源，服务器返回时，可以在Response Headers中增加expires字段表示资源的过期时间。<br>expires字段的值是一个时间戳(格林尼治时间),当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果小于该时间戳则直接使用该缓存资源。如果大于该时间戳，则表示过期，缓存作废。</p>
<p>问题是发送请求时使用的是客户端时间去对比。客户端和服务端的时间可能快慢不一致，另一方面是客户端的时间是可以自行修改的(浏览器的时间是跟随系统的，修改系统时间会影响到)，所以不一定满足预期。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expires:  Mon, 22 Jun 2020 08:18:33 GMT</span></span><br><span class="line">res.setHeader(<span class="string">'Expires'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">10</span>*<span class="number">1000</span>).toUTCString())</span><br></pre></td></tr></table></figure>

<h2 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h2><p>HTTP 1.1新增cache-control字段来解决上述客户端和服务端时间不匹配的问题，所以当cache-control 和 expires都存在时，cache-control优先级更高。该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它不依赖客户端时间。<br>cache-control主要有max-age，s-maxage，public，private，no-cache，no-store等值。</p>
<ul>
<li>public<br>所有内容都将被缓存(客户端和代理服务器都可以缓存)</li>
<li>private<br>内容只缓存到私有缓存中(客户端可以缓存)</li>
<li>no-cache<br>需要使用协商缓存来验证缓存数据</li>
<li>no-store<br>所有内容都不缓存</li>
<li>must-revalidation/proxy-revalidation<br>如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证呢过</li>
<li>max-age=xxx<br>缓存的内容将在xxx秒后失效，这个选项只有在HTTP1.1可用，如果和Last-Modified一起使用时，优先级较高。</li>
</ul>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=20'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>协商缓存简单的说就是浏览器和服务器间就是否要使用缓存做协商。如果协商的结果是需要更新，就返回200并更新内容。如果不需要，就只需要返回状态吗304不用返回内容，这样虽然后端需要应答，但是后端既不需要生成内容也不需要传输内容。<br>如果设置了no-cache和no-store则本地缓存会被忽略，会去请求服务器，验证资源是否更新，如果没更新才继续使用本地缓存，此时返回的是304，这就是协商缓存。<br>设置协商缓存主要包括last-modified 和 Etag。</p>
<h2 id="last-modified-和-if-modified-since"><a href="#last-modified-和-if-modified-since" class="headerlink" title="last-modified 和 if-modified-since"></a>last-modified 和 if-modified-since</h2><p>通过比较时间， 判断是否需要使用缓存</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line">res.setHeader(<span class="string">'last-modified'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toUTCString())</span><br><span class="line"><span class="comment">// 判断是否在有效期内，req.headers['if-modified-since'] 就是last-modified设置的时间。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>(req.headers[<span class="string">'if-modified-since'</span>]).getTime() + <span class="number">10</span> * <span class="number">1000</span> &gt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'协商缓存命中'</span>)</span><br><span class="line">    res.statusCode = <span class="number">304</span></span><br><span class="line">    res.end()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Etag-和-if-none-match"><a href="#Etag-和-if-none-match" class="headerlink" title="Etag 和 if-none-match"></a>Etag 和 if-none-match</h2><p>通过比较内容，判断是否要使用缓存</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">'sha1'</span>).update(content).digest(<span class="string">'hex'</span>)</span><br><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line">res.setHeader(<span class="string">'Etag'</span>, hash)</span><br><span class="line"><span class="comment">// 判断服务器设置的hash和客户端请求头中携带的hash一样</span></span><br><span class="line"><span class="comment">// req.headers['if-none-match']就是 Etag 中的值</span></span><br><span class="line"><span class="keyword">if</span> (req.headers[<span class="string">'if-none-match'</span>] === hash) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Etag 缓存命中'</span>)</span><br><span class="line">    res.statusCode = <span class="number">304</span></span><br><span class="line">    res.end()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AJAX缓存"><a href="#AJAX缓存" class="headerlink" title="AJAX缓存"></a>AJAX缓存</h2><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/22/HTTP缓存/" data-id="ckh44mzsk00034sv2enqt85oc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/20/React高级/" class="article-date">
  <time datetime="2020-06-20T08:00:39.000Z" itemprop="datePublished">2020-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/20/React高级/">React高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>Hook是一个特殊函数，它可以钩入React特性，useState允许在React函数组件中添加state的Hook。</p>
<h2 id="使用Effect-Hook-和-state-Hook"><a href="#使用Effect-Hook-和-state-Hook" class="headerlink" title="使用Effect Hook 和 state Hook"></a>使用Effect Hook 和 state Hook</h2><p>useSate可以添加state，useEffect可以在函数组件中执行副作用操作。<br>数据获取，设置订阅以及手动更改React组件中的DOM都属于副作用。 </p>
<p>默认情况下，useEffect会在每轮组件渲染完成后执行。一旦 eﬀect 的依赖发⽣生变化，它就会被重新创建。<br>useEffect 的第二个参数就表示依赖于这个变量的值，它改变了才会重新执行这个副作用函数里面的代码。<br>如果这个参数是空数组[]，则useEffect只会执行一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用useState 创建state：count，初始化值为0，改变count的方法</span></span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与componentDidMount 和componentDidUpdate相似</span></span><br><span class="line">   </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You click <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;, [count])</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setDate(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        <span class="comment">// 组件卸载时需要清楚effect创建的订阅或计时器ID等资源，需要返回一个清除函数，清除函数会在组件卸载前执行。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            clearInterval(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;Hook page&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;&#123;count&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count+<span class="number">1</span>)&#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;&#123;date.toLocaleTimeString()&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>使用自定义Hook，在组件之间重用一些状态逻辑。<br>自定义Hook是一个函数，其名称必须以’use’开头，函数内部可以调用其他的Hook。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useClock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"date effect"</span>)</span><br><span class="line">        <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setDate(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">    &#125;, [])</span><br><span class="line">    <span class="keyword">return</span> date</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hook使用规则"><a href="#Hook使用规则" class="headerlink" title="Hook使用规则"></a>Hook使用规则</h2><p>Hook就是JavaScript函数，但是使用它们会有两个额外的规则：</p>
<ol>
<li>只能在函数最外层调用Hook，不能在循环，条件或者子函数中使用。</li>
<li>只能在React的函数组件中和自定义的Hook中可以调用Hook，不要在其它的JavaScript函数中调用。</li>
</ol>
<h2 id="useMemo-和-useCallback"><a href="#useMemo-和-useCallback" class="headerlink" title="useMemo 和 useCallback"></a>useMemo 和 useCallback</h2><p>类比Vue中的计算属性，只有在依赖项的数据变化时，才执行函数，具有缓存的作用。<br>useCallback是useMemo的变体：useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useMemo</span></span><br><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br><span class="line"><span class="comment">// useCallback</span></span><br><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="React-VS-CODE-插件"><a href="#React-VS-CODE-插件" class="headerlink" title="React VS CODE 插件"></a>React VS CODE 插件</h1><h2 id="处理HTML标签"><a href="#处理HTML标签" class="headerlink" title="处理HTML标签"></a>处理HTML标签</h2><p>Auto Close Tag<br>Auto Complete Tag<br>Auto Raname Tag<br>Auto Import<br>HTML Format</p>
<h2 id="处理CSS"><a href="#处理CSS" class="headerlink" title="处理CSS"></a>处理CSS</h2><p>Beautify css/sass/scss/less</p>
<h2 id="处理注释"><a href="#处理注释" class="headerlink" title="处理注释"></a>处理注释</h2><p>Better Comments</p>
<h2 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h2><p>ESLint</p>
<h2 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h2><p>open in browser</p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>Prettier-Code formatter</p>
<h2 id="React-代码快捷方式"><a href="#React-代码快捷方式" class="headerlink" title="React 代码快捷方式"></a>React 代码快捷方式</h2><p>React-Native/React/Redux snippets for es6/es7</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/20/React高级/" data-id="ckh44mzte000g4sv23k945l46" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/16/React基础/" class="article-date">
  <time datetime="2020-06-16T06:40:10.000Z" itemprop="datePublished">2020-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/16/React基础/">React基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>React是一个用于构建用户界面的JavaScript库。</p>
<h2 id="构建React应用"><a href="#构建React应用" class="headerlink" title="构建React应用"></a>构建React应用</h2><p>使用Create React App创建React应用。<br>npx 是npm5.2+附带的package运行工具</p>
<ol>
<li>创建项目：npx create-react-app my-app</li>
<li>进入项目：cd my-app</li>
<li>启动项目： npm start</li>
<li>暴露配置项： npm run eject (执行这行命令之后，就会暴露出config文件夹，其中包括webpack.config.js)<h2 id="React应用文件结构"><a href="#React应用文件结构" class="headerlink" title="React应用文件结构"></a>React应用文件结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── README.md                     文档</span><br><span class="line">├── public                        静态资源</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html                打包之后的文件会以script标签的形式插入index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">└── src                           源码</span><br><span class="line">    ├── App.css</span><br><span class="line">    ├── App.js                    根组件</span><br><span class="line">    ├── App.test.js              </span><br><span class="line">    ├── index.css                 全局样式</span><br><span class="line">    ├── index.js                  ⼊⼝⽂件 （webpack要打包处理的入口文件）</span><br><span class="line">    ├── logo.svg</span><br><span class="line">    └── serviceWorker.js          pwa⽀持</span><br><span class="line">├── package.json                  npm包依赖</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>入口文件定义的位置，/config/webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">    <span class="comment">// WebpackDevServer客户端，它实现开发时热更更新功能</span></span><br><span class="line">    isEnvDevelopment &amp;&amp; <span class="built_in">require</span>.resolve(<span class="string">'react-dev-utils/webpackHotDevClient'</span>),</span><br><span class="line">    <span class="comment">// 应用程序入口： src/index.js</span></span><br><span class="line">    paths.appIndexJs,</span><br><span class="line">].filter(<span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure>

<p>webpack.config.js是webpack配置文件，开头的常量声明可以看出React app能够支持ts,sass以及css模块化.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if TypeScript is setup</span></span><br><span class="line"><span class="keyword">const</span> useTypeScript = fs.existsSync(paths.appTsConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// style files regexes</span></span><br><span class="line"><span class="keyword">const</span> cssRegex = <span class="regexp">/\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassRegex = <span class="regexp">/\.(scss|sass)$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassModuleRegex = <span class="regexp">/\.module\.(scss|sass)$/</span>;</span><br></pre></td></tr></table></figure>

<h2 id="React-和-ReactDom"><a href="#React-和-ReactDom" class="headerlink" title="React 和 ReactDom"></a>React 和 ReactDom</h2><p>React 负责逻辑控制，将数据转化成VDOM<br>ReactDom 负责渲染，将VDOM渲染成真是DOM<br>React中使用JSX来描述UI。babel-loader把JSX编译成JS对象，React.crreteElement()再把这个JS对象构造成React的VDOM。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> JSX = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  JSX,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h1><p>JSX是一种JavaScript的语法扩展，其格式像模板语言，但实际上完全实在JavaScript内部实现。JSX可以很好地描述UI，能够有效提高开发效率。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>{}用来包裹表达式，其内部的表达式会被计算出来。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'react'</span></span><br><span class="line"><span class="keyword">const</span> jsx = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello, &#123; name &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    firstName: <span class="string">'Harry'</span>,</span><br><span class="line">    lastName: <span class="string">'Potter'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.firstName + <span class="string">' '</span> + v.lastName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jsx = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123; formatName(obj) &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>jsx也是js对象，也是合法的表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>good<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> jsx = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;greet&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> show = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> greet = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>good<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123; show ？greet : <span class="string">"bad"</span> &#125;</span><br><span class="line">        &#123; show &amp;&amp; greet &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组会被作为一组子元素对待，数组中存放一组jsx可用于现实列表数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在diff的时候先比较标签type，然后是key，所以同级元素的key必须是唯一的</span></span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123; a.map(<span class="function"><span class="params">item</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;</span> <span class="attr">item</span> &#125;&gt;</span>&#123; item &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>))&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="属性上使用"><a href="#属性上使用" class="headerlink" title="属性上使用{}"></a>属性上使用{}</h3><p>属性：静态值使用双引号，动态值使用花括号，双花括号里面的花括号用来表示对象的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.svg'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;img src=&#123;logo&#125; style=&#123;&#123; <span class="attr">width</span>: <span class="number">100</span>px&#125;&#125; className=<span class="string">"img"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h3 id="css模块化"><a href="#css模块化" class="headerlink" title="css模块化"></a>css模块化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSS模块化规则：http://www.ruanyifeng.com/blog/2016/06/css_modules.html</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'./index.module.css'</span></span><br><span class="line">&lt;img className=&#123;style.logo&#125;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>组件，类似于JavaScript函数。它接受任意的参数(props),并返回描述页面展示内容的React元素。<br>组件有两种形式：class组件和function组件。<br>props: 自定义组件的属性和其子组件会转换为一个对象，这个对象就称为props。<br>组件名称必须以大写字母开头，小写字母开头的组件将会被视为原生DOM标签。</p>
<h2 id="Class组件"><a href="#Class组件" class="headerlink" title="Class组件"></a>Class组件</h2><p>class组件拥有状态和生命周期，继承于React.Component，必须定义render方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="comment">// 使用state属性维护状态，在构造函数中初始化状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生命周期钩子函数， 挂载之后执行</span></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// 组件挂载之后启动定时每秒更新状态</span></span><br><span class="line">        <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 使用setState方法更新状态</span></span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生命周期钩子函数，在组件卸载之前停止定时器</span></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生命周期钩子函数， 在组件更新后调用</span></span><br><span class="line">    componentDidUpdate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">" component did update"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须有这个render函数，将来会返回jsx</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.date.toLocaleTimeString()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="function组件"><a href="#function组件" class="headerlink" title="function组件"></a>function组件</h2><p>函数组件通常无状态，仅关注内容展示，返回渲染结果即可。<br>从React16.8开始引入hooks, 函数组件也能够拥有状态。<br>可以把useEffect Hook看作是componentDidMount,componentWillUnmount和componentDidUpdate这三个函数的结合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FunctionComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明状态 和 要改变状态的函数</span></span><br><span class="line">    <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 副作用，当组件挂载之后执行，对应class component中的生命周期钩子函数-componentDidMount()</span></span><br><span class="line">        <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setDate(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        <span class="comment">// 组件卸载的时候执行，对应class component 中的生命周期钩子函数-componentWillUnmount()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">    &#125;, []) <span class="comment">// []数组中放依赖项表示，谁的值改变了就执行了回调函数，空数组表示，谁的值变了都不重新执行回调函数。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;<span class="built_in">Function</span> component&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;&#123; date.toLocaleTimeString()&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><h3 id="正确使用setState"><a href="#正确使用setState" class="headerlink" title="正确使用setState"></a>正确使用setState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(partialState, callback)</span><br></pre></td></tr></table></figure>

<ol>
<li>partialState: Object | function<br>要合并到当前State的对象。</li>
<li>callback: function<br>state更新完成之后要执行的回调函数。<h3 id="不要直接修改State"><a href="#不要直接修改State" class="headerlink" title="不要直接修改State"></a>不要直接修改State</h3>构造函数是唯一可以给 this.state 赋值的地方。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.state.commet = &apos;hello&apos;</span><br><span class="line">// correct</span><br><span class="line">this.setState(&#123; comment: &apos;hello&apos; &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="State的更新可能是异步的"><a href="#State的更新可能是异步的" class="headerlink" title="State的更新可能是异步的"></a>State的更新可能是异步的</h3><p>出于性能考虑，React可能会把多个setState() 合并成一个调用。<br>因为this.porps 和 this.state可能会异步更新，所以不要以它们的值来更新下一个状态。<br>setState只有在合成事件和生命周期函数中是异步的，在原生事件和setTimeout中都是同步的，这⾥里里的异步其实是批量更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// wrong 可能无法更新</span><br><span class="line">this.setState(&#123;</span><br><span class="line">    counter: this.state.counter + this.props.increment</span><br><span class="line">&#125;)</span><br><span class="line">// correct 使用函数返回要合并的对象</span><br><span class="line">this.setState((state, props) =&gt; (&#123;</span><br><span class="line">    counter: state.counter + props.increment</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="State的更新会被合并"><a href="#State的更新会被合并" class="headerlink" title="State的更新会被合并"></a>State的更新会被合并</h3><p>当调用setState()的时候，React会把提供的对象合并到当前的state，浅合并。</p>
<h3 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h3><p>不管是父组件或子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是class组件。<br>其他组件无法访问state。<br>组件可以把它的state作为props向下传递到它的子组件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;this.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>FormattedDate 组件会在其 props 中接收参数 date，但是组件本身无法知道它是来自于 Clock 的 state，或是 Clock 的 props，还是手动输入的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function FormattedDate(props) &#123;</span><br><span class="line">  return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>每个组件都包含”生命周期方法”，重写生命周期方法，会在组件运行的特别阶段执行这些方法。<br>React 16.3之前的生命周期函数图<br><img src="/static/img/react1.png"><br>React 16.4之后的生命周期函数图<br><img src="/static/img/react2.png"></p>
<p>React 17即将废除的三个生命周期函数：</p>
<ul>
<li>componentWillMount()</li>
<li>componentWillReceiveProps()</li>
<li>componentWillUpdate()</li>
</ul>
<p>可以替代的两个新的生命周期函数：</p>
<ul>
<li>static getDerivedStateFromProps()</li>
<li>getSnapshotBeforeUpdate()<br>如果要使用即将废除的生命周期函数，需要加上前缀’UNSAFE_’, 或这运行如下命令，自动加前缀。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your_project</span><br><span class="line">npx react-codemod rename-unsafe-lifecycles</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="挂载相关"><a href="#挂载相关" class="headerlink" title="挂载相关"></a>挂载相关</h4><p>当组件实例被创建并插入DOM中时，其生命周期调用顺序如下：</p>
<ul>
<li>constructor()</li>
<li>static getDerivedStateFromProps()</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<h4 id="更新相关"><a href="#更新相关" class="headerlink" title="更新相关"></a>更新相关</h4><p>当组件的porps或state发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()</li>
<li>componentDidUpdate()<h4 id="卸载相关"><a href="#卸载相关" class="headerlink" title="卸载相关"></a>卸载相关</h4>当组件从DOM中移除时会调用如下方法：</li>
<li>componentWillUnmount()<h4 id="错误处理相关"><a href="#错误处理相关" class="headerlink" title="错误处理相关"></a>错误处理相关</h4>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</li>
<li>static getDerivedStateFromError()</li>
<li>componentDidCatch()</li>
</ul>
<h4 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span> <span class="comment">// react内置库，用于对props做类型检查</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecyclepage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置静态属性defaultProps 作为 props的默认值</span></span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        msg: <span class="string">'omg'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置静态属性propTypes，规定props的值的类型。</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        msg: PropTypes.string.isRequired</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @constructor 构造函数</span></span><br><span class="line"><span class="comment">     * 如果构造React.Component的子组件，则必须使用super(props)</span></span><br><span class="line"><span class="comment">     * 在构造函数中，只做两件事:</span></span><br><span class="line"><span class="comment">     *      1. state初始化</span></span><br><span class="line"><span class="comment">     *      2. 给事件处理函数帮定当前实例：this.handleClick = this.handleClick.bind(this);</span></span><br><span class="line"><span class="comment">     * 如果不做上述的事情，constructor函数是不需要声明的，super默认会去执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props) </span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @getDerivedStateFromProps </span></span><br><span class="line"><span class="comment">     * 作用： 更新state</span></span><br><span class="line"><span class="comment">     * 时机： 在调用render方法之前调用，在第一次挂载和后续更新都会被调用。（每次渲染前触发此方法）</span></span><br><span class="line"><span class="comment">     * 用法： 返回一个对象来更新state，如果返回null，不更新任何内容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count &#125; = state</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getDerivedStateFromProps'</span>, count)</span><br><span class="line">        <span class="keyword">return</span> count &lt; <span class="number">5</span> ? <span class="literal">null</span> : &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">    UNSAFE_componentWillReceiveProps(nextProps) &#123;</span></span><br><span class="line"><span class="comment">        // 不推荐，将会被废弃</span></span><br><span class="line"><span class="comment">        // UNSAFE_componentWillReceiveProps() 会在已挂载的组件接收新的 props 之前被调用</span></span><br><span class="line"><span class="comment">        console.log("Foo componentWillReceiveProps");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @getSnapshotBeforeUpdate</span></span><br><span class="line"><span class="comment">     * 作用：   它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）</span></span><br><span class="line"><span class="comment">     * 时机：   在render之后，在componentDidUpdate之前。</span></span><br><span class="line"><span class="comment">     * 用法：   此生命周期的任何返回值将作为参数传递给 componentDidUpdate(prevProps, prevState, snapshot)。应返回 snapshot 的值（或 null）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getSnapshotBeforeUpdate = <span class="function">(<span class="params">prevProps, prevState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count &#125; = prevState</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getSnapshotBeforeUpdate'</span>, count)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    UNSAFE_componentWillMount() &#123;    </span></span><br><span class="line"><span class="comment">        //不推荐，将会被废弃    </span></span><br><span class="line"><span class="comment">        console.log("componentWillMount", this.state.count);  </span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @componentDidMount</span></span><br><span class="line"><span class="comment">     * 作用：   发起网络请求获取数据，添加订阅。 </span></span><br><span class="line"><span class="comment">     * 时机：   会在组件挂载后（插入DOM树中，也就是render执行后）立即调用。</span></span><br><span class="line"><span class="comment">     * 用法：   在此函数里可以直接调用setState，会触发额外的渲染，此渲染会发生在浏览器更新屏幕之前。</span></span><br><span class="line"><span class="comment">     * 注意：   谨慎使用，会导致性能问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @componentWillUnmount</span></span><br><span class="line"><span class="comment">     * 作用:    执行清理操作，如timer，取消网络请求，取消订阅</span></span><br><span class="line"><span class="comment">     * 时机：   在组件卸载及销毁之前直接调用。</span></span><br><span class="line"><span class="comment">     * 用法：   不能使用setState,组件实例卸载后，将不会再挂载它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    UNSAFE_componentWillUpdate() &#123;    </span></span><br><span class="line"><span class="comment">        // 不推荐，将会被废弃    </span></span><br><span class="line"><span class="comment">        console.log("componentWillUpdate", this.state.count);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @componentDidUpdate</span></span><br><span class="line"><span class="comment">     * 作用：   当组件更新后，可以在此处对DOM进行操作</span></span><br><span class="line"><span class="comment">     * 时机：   在更新后会被立即调用，首次渲染不会执行此方法。</span></span><br><span class="line"><span class="comment">     * 用法：   对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。</span></span><br><span class="line"><span class="comment">     * 注意1：  可以使用setState,它必须被包裹在一个条件语句里,否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。</span></span><br><span class="line"><span class="comment">     * 注意2：  shouldComponentUpdate返回值为false，则不会调用该方法。</span></span><br><span class="line"><span class="comment">     * 注意3：  getSnapshotBeforeUpdate的返回值将作为该方法的第三个参数snapshot。  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @shouldComponentUpdate</span></span><br><span class="line"><span class="comment">     * 作用：   默认行为state每次发生变化，组件都会重新渲染，根据该函数的返回值，判断组件的输出是否受当前state或props更改的影响。</span></span><br><span class="line"><span class="comment">     * 时机：   首次渲染或使用 forceUpdate() 时不会调用该方法。当props和state变化时，在render前被调用。</span></span><br><span class="line"><span class="comment">     * 用法：   返回值默认为true，返回false则不会调用 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()。</span></span><br><span class="line"><span class="comment">     * 注意：   返回 false 并不会阻止子组件在 state 更改时重新渲染。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count &#125; = nextState</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'shouldCOmponentUpdate'</span>, count, nextState.count)</span><br><span class="line">        <span class="keyword">return</span> count !== <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @render</span></span><br><span class="line"><span class="comment">     * 作用：   返回由JSX创建的React元素</span></span><br><span class="line"><span class="comment">     * 时机：   constructor执行之后</span></span><br><span class="line"><span class="comment">     * 用法：   保持render函数为纯函数，不与浏览器交互。与浏览器进行交互，请在 componentDidMount</span></span><br><span class="line"><span class="comment">     * 注意：   如果 shouldComponentUpdate() 返回 false，则不会调用 render()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render'</span>, <span class="keyword">this</span>.state)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Life cycle page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;&#123; count &#125;&lt;/</span>p&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.setCount&#125;&gt;改变count&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><p>React推荐使用组合而非继承来实现组件间的代码重用。</p>
<h3 id="不具名的方式传入子组件"><a href="#不具名的方式传入子组件" class="headerlink" title="不具名的方式传入子组件"></a>不具名的方式传入子组件</h3><p>类比Vue中的slot插槽的不具名插槽。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// children 为插入该组件的子组件</span></span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123; children &#125;</span><br><span class="line">            &#123; children.content &#125;</span><br><span class="line">            &#123; children.txt&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function RootComponent() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;Component&gt;</span></span><br><span class="line"><span class="regexp">            &#123;/</span>* 这个组件里面的内容全部会被作为 默认的children组件 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">            &lt;h1&gt;Welcome&lt;/</span>h1&gt;</span><br><span class="line">            &lt;p&gt;Richard!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/Component&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="具名的方式传入子组件"><a href="#具名的方式传入子组件" class="headerlink" title="具名的方式传入子组件"></a>具名的方式传入子组件</h3><p>类比Vue中的具名插槽</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RootComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 不使用children, 自定义传入props的内容</span></span><br><span class="line">            <span class="comment">// 可以将任何东西作为 props 进行传递。</span></span><br><span class="line">            &lt;Component top=&#123;&lt;TopBar /&gt;&#125; bottom=&#123;&lt;BottomBar /&gt;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// children 为插入该组件的子组件</span></span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 使用自定义传入的内容</span></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123; props.top &#125;</span><br><span class="line">            &#123; props.bottom &#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>redux是JavaScript应用的状态容器，提供可预测的状态管理。它保证程序行为一致性且易于测试。<br>应用场景：</p>
<ul>
<li>有相当大量的，随时变化的数据。</li>
<li>state需要有一个单一的可靠来源</li>
<li>state太多，放在顶层组件，不方便维护。</li>
<li>state需要共享的时候。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux --save</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用步骤：</p>
<ol>
<li>createStore() 创建 store</li>
<li>reducer 初始化state和定义修改状态的函数</li>
<li>store.getState() 获取状态</li>
<li>store.dispatch() 提交对数据的更改</li>
<li>store.subscribe() 订阅<br>创建store<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// state  表示状态</span></span><br><span class="line"><span class="comment">// action 表示方法，用来更改状态。</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'MINUS'</span>:</span><br><span class="line">            <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(counterReducer)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用store</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store/ReduxStore'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduxPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// 订阅，当state改变就会执行函数</span></span><br><span class="line">        store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"subscribe"</span>)</span><br><span class="line">            <span class="comment">// 强制更新</span></span><br><span class="line">            <span class="keyword">this</span>.forceUpdate()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        store.dispatch(&#123;<span class="attr">type</span>: <span class="string">"ADD"</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    minus = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        store.dispatch(&#123;<span class="attr">type</span>: <span class="string">"MINUS"</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"store"</span>, store)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;Redux Page&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">                &#123;/</span>* 获取state *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;&#123;store.getState()&#125;&lt;/</span>p&gt;</span><br><span class="line">                &lt;button onClick=&#123; <span class="keyword">this</span>.add &#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123; this.minus &#125;&gt;minus&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-redux --save</span><br></pre></td></tr></table></figure>

<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>react-redux提供了两个api</p>
<ol>
<li>Provider为后代组件提供store</li>
<li>connect为组件提供数据和变更方法</li>
</ol>
<p>全局使用store：index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span></span><br><span class="line"><span class="keyword">import</span> ReactReduxComponent <span class="keyword">from</span> <span class="string">'src/components/ReactReduxComponent.js'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;ReactReduxComponent /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<p>创建store：store/index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state  表示状态</span></span><br><span class="line"><span class="comment">// action 表示方法，用来更改状态。</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'MINUS'</span>:</span><br><span class="line">            <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(counterReducer)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>使用react-redux的组件：src/components/ReactReduxComponent.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        num: state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">'ADD'</span>&#125;),</span><br><span class="line">        minus: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">'MINUS'</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactReduxPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; num, add, minus &#125; = <span class="keyword">this</span>.props</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;React Redux Page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;&#123;num&#125;&lt;/</span>p&gt;</span><br><span class="line">                &lt;button onClick=&#123;add&#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;minus&#125;&gt;minus&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 状态映射 mapStateToProps</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 派发事件映射 mapDispatchToProps</span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps, mapDispatchToProps)(ReactReduxPage)</span></span><br></pre></td></tr></table></figure>

<h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p>react-router是react的路由库。它通过管理 URL，实现组件的切换和状态的变化。<br>react-router包含3个库，react-router,react-router-dom和react-router-native。<br>react-router提供最基本的路由功能，实际使用的时候，不会直接安装react-router。而是根据应用运行的环境选择安装react-router-dom(安装在浏览器使用)或react-router-native(在react native中使用)。<br>因为在安装时react-router也会安装。</p>
<h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-router-dom --save</span><br></pre></td></tr></table></figure>

<h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>react-router中奉行一切皆组件的思想，路由器-Router，链接-link，路由-Route，独占-Switch，重定向-Redirect都是以组件形式存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;Router Page&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Router&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Link to="/</span><span class="string">"&gt;首页&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                    &lt;Link to="</span>/user<span class="string">"&gt;用户中心&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                    &#123;/** Switch 表示仅匹配路由列表中的一个 */&#125;</span></span><br><span class="line"><span class="string">                    &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                        &#123;/**exact 表示实现精确匹配 */&#125;</span></span><br><span class="line"><span class="string">                        &lt;Route exact path="</span>/<span class="string">" component=&#123;HomePage&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">                        &lt;Route </span></span><br><span class="line"><span class="string">                            path="</span>/user<span class="string">" </span></span><br><span class="line"><span class="string">                            component=&#123;UserPage&#125;</span></span><br><span class="line"><span class="string">                            // children=&#123;() =&gt; &lt;div&gt;children&lt;/div&gt;&#125;</span></span><br><span class="line"><span class="string">                            // render=&#123;() =&gt; &lt;div&gt;render&lt;div/&gt;&#125;</span></span><br><span class="line"><span class="string">                        &gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">                        &#123;/* 路由列表最后设置一个path为空的路由，为找不到的资源，匹配404页面 */&#125;</span></span><br><span class="line"><span class="string">                        &lt;Route component=&#123;EmptyPage&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">                    &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">                &lt;/Router&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class HomePage extends Component &#123;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;h3&gt;HomePage&lt;/h3&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class UserPage extends Component &#123;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;h3&gt;UserPage&lt;/h3&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class EmptyPage extends Component &#123;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;h3&gt;Empty page 404&lt;/h3&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Route渲染内容的三种方式"><a href="#Route渲染内容的三种方式" class="headerlink" title="Route渲染内容的三种方式"></a>Route渲染内容的三种方式</h2><p>Route渲染的优先级： children &gt; component &gt; render。三种方式同时应用，也只有一种有效。</p>
<ul>
<li>children属性<br>children属性接受一个函数，不管location是否匹配，都需要渲染一些内容，这时可以使用children。<br>Switch组件特性会让children属性的路由匹配到，才显示。</li>
<li>component属性<br>component属性接受一个component，只有当location匹配的时候渲染。</li>
<li>render属性<br>render属性接受一个函数，只有当location匹配的时候渲染。<h1 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h1>继承自PureComponent的组件，会去默认的执行shouldComponentUpdate 方法,去比较state，props，改变了数据才去重新render。并且是以浅层对比prop和state的方式实现该函数。<br>如果赋予React组件相同的props和state，render会渲染同样的内容，那么使用PureComponent就不会再去渲染，从而提高性能。<br>注意： PureComponent中的shouldComponentUpdate会跳过所有子组件树的prop更新。只有在数据比较简单的时候使用PureComponent.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">PureComponentPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            counter: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setCounter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            counter: <span class="number">100</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; counter &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;PureComponent Page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div onClick=&#123;this.setCounter&#125;&gt;counter: &#123;counter&#125;&lt;/</span>div&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用Coomponent来实现PureComponent的效果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            counter: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义shouldComponentUpdate</span></span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextState.counter !== <span class="keyword">this</span>.state.counter</span><br><span class="line">    &#125;</span><br><span class="line">    setCounter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            counter: <span class="number">100</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; counter &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;PureComponent Page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div onClick=&#123;this.setCounter&#125;&gt;counter: &#123;counter&#125;&lt;/</span>div&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/16/React基础/" data-id="ckh44mztj000k4sv2qeycsjx6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/算法/" class="article-date">
  <time datetime="2020-06-14T07:18:59.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/算法/">算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h1><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<h1 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h1><p>五个特性： 输入，输出，有穷性，确定性，可行性。</p>
<h1 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h1><p>好的算法应该具有正确性，可读性，健壮性，高效率和低存储的特点。</p>
<h1 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h1><p>事后统计方法：用设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率高低。<br>事前分析估算：在计算机程序编制前，依据统计方法对算法进行估算。<br>程序在计算机运行时所消耗的时间取决于以下因素：</p>
<ol>
<li>算法采用的策略，方法。(根本)</li>
<li>编译产生的代码质量。(取决于软件)</li>
<li>问题的输入规模。(输入量的多少)</li>
<li>机器执行指令的速度。(取决硬件性能)</li>
</ol>
<p>因此排除软硬件的因素，算法好坏取决于输入量和算法本身。通过算法时间复杂度来估算算法时间效率。</p>
<h1 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h1><p>大O表示法： 用1表示加法常数，只保留最高阶，去掉最高阶的常系数。<br>O(1):常数阶，<br>O(n):线性阶，<br>O(log):对数阶，<br>O(n<em>n):平方阶<br>常见的时间复杂度所耗费的时间从大到小：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n</em>n) &lt; O(n<em>n</em>n)<br>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p>
<h1 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h1><p>算法的空间复杂度是通过计算算法所需的存储空间来实现的。</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>零个或多个数据元素的有限序列。这些元素必须像线一样一个一个连接起来。<br>特点：第一个元素无前驱元素，最后一个元素无后继元素，中间的元素都只有一个直接前驱元素和一个直接后继元素。<br>线性表常用操作：<br>isEmpty(): 判断是否为空,<br>clear()： 清空操作,<br>getElem(i)： 将第i个位置的元素返回,<br>locateElem(e)：查找和e相同的元素，并将序号返回，没有返回false。<br>insert(i, e): 在i的位置插入元素e。<br>size(): 返回元素的个数。</p>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p>使用一组地址连续的存储单元来存储线性表中的元素。</p>
<h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><p>使用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/算法/" data-id="ckh44mzui001m4sv2sz5qgnlq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构与算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/08/数据结构与算法/" class="article-date">
  <time datetime="2020-06-08T12:09:26.000Z" itemprop="datePublished">2020-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/08/数据结构与算法/">数据结构与算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><p>数据结构是数据之间存在的一种或多种关系的数据元素的集合。<br>数据结构这门学科是研究程序设计问题中的操作对象，以及它们之间的关系和操作等的学科。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="数据，数据对象，数据元素，数据项"><a href="#数据，数据对象，数据元素，数据项" class="headerlink" title="数据，数据对象，数据元素，数据项"></a>数据，数据对象，数据元素，数据项</h2><p>数据：是描述客观事物的符号是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如：声音，图像，视频等。<br>数据对象：是性质相同的数据元素的集合，是数据的子集。<br>数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。<br>数据项：一个数据元素可以由若干个数据项组成。数据项是不可分割的最小单位。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是指数据对象中数据元素之间的相互关系。</p>
<ol>
<li>集合结构</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图形结构<h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2>物理结构也叫存储结构，，指数据的逻辑结构在计算机中的存储形式。数据的存储结构应正确反映数据元素之间的逻辑关系。<br>数据元素的存储结构形式有两种：顺序存储和链式存储。<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3>把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系一致。比如数组。<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3>把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系不能反应其逻辑关系，需要一个指针存放数据元素的地址，通过地址找到相关联的数据元素的位置。<h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型(ADT)"></a>抽象数据类型(ADT)</h2>抽象数据类型(Abstract Data Type)：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型定义了一个数据对象，数据对象中各数据元素之间的关系及对数据元素的操作。<br>抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。</li>
</ol>
<h1 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h1><p>特点：后入先出，所有操作都是针对栈顶元素进行。<br>实现：用数组实现栈<br>应用：撤回操作。</p>
<h1 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h1><p>特点：先进先出，只允许在队列的头部删除元素，在队列的尾部添加元素。<br>实现：用数组实现队列<br>应用：消息队列，socket服务器将请求放入队列，先来的先处理，后来的后处理，队列满时，新来的请求直接抛弃。</p>
<h1 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h1><p>链表是物理存储单元上非连续的，非顺序的存储结构，由一系列节点组成，一个节点连接到下一个节点。</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点包含两部分，一部分是存储数据元素的数据域，一部分是存储指向下一个节点的指针域，它们一起共同构成一个节点。</p>
<h3 id="首尾节点"><a href="#首尾节点" class="headerlink" title="首尾节点"></a>首尾节点</h3><p>链表中的第一个节点是首节点，最后一个节点是尾节点。</p>
<h3 id="有头链表和无头链表"><a href="#有头链表和无头链表" class="headerlink" title="有头链表和无头链表"></a>有头链表和无头链表</h3><p>无头链表是指第一个节点既有数据域，又有指针域，第一个节点既是首节点又是头节点。<br>有头链表是指第一个节点只有指针域，而没有数据域。</p>
<h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>用bit位来表示数字是否存在，0表示不存在，1表示存在。<br>BitMap在处理大数据时，才具有优势。<br>应用：大数据排序，使用BitMap排序必须要数据量很大，而且集合中不能有重复数据，只能处理整数。</p>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>布隆过滤器是一种数据结构，比较巧妙的概率型数据结构，特点是高效地插入和查询。<br>原理： 处理字符串，把字符串变成多个整数。<br>可以把布隆过滤器看作是BitMap的扩展，布隆过滤器要求使用k个hash函数，把字符串散列成k个整数，这k个整数的数值就作为二进制数组的下标，然后将数组对应下标的值设置为1。判断某个字符串是否存在时，还是使用k个hash函数对key进行散列，得到k个整数，如果这k个整数所对应的二进制位都是1,就说明这个字符串存在。否则，这个字符串不存在。</p>
<p>对于布隆过滤器，有两个参数需要设置，一个是预估的最多存放的数据的数量，一个是可以接受的冲突率。</p>
<h2 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h2><p>哈希函数将不定长的对象映射成一个定长的对象。<br>murmurhash函数。</p>
<h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>树是一种非线性的数据结构，由n个节点组成的有限集合。</p>
<ul>
<li>n = 0,是空树</li>
<li>根节点是唯一的，根节点没有父节点</li>
<li>叶节点，没有子节点</li>
<li>子树，除根节点的其他元素组成的互不相交的集合<h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2>结点包含一个数据元素和一些指向子树的分支。<h3 id="结点的度"><a href="#结点的度" class="headerlink" title="结点的度"></a>结点的度</h3>结点拥有的子树的个数(分支数目)称为结点的度。<h3 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h3><h4 id="根结点"><a href="#根结点" class="headerlink" title="根结点"></a>根结点</h4>一个非空树，有且只有一个根结点。<h4 id="分支结点"><a href="#分支结点" class="headerlink" title="分支结点"></a>分支结点</h4>度不为0的结点称为分支结点(除根结点外，分结节点也称为内部结点)。<h4 id="叶结点"><a href="#叶结点" class="headerlink" title="叶结点"></a>叶结点</h4>度为0的结点称为叶结点(即拥有的子树的个数为0)。<h3 id="结点关系"><a href="#结点关系" class="headerlink" title="结点关系"></a>结点关系</h3></li>
<li>双亲结点。</li>
<li>孩子结点：结点的子树的根称为该结点的孩子。</li>
<li>兄弟结点：同一个双亲结点的孩子之间互称兄弟。</li>
<li>祖先结点：结点的祖先是从根到该结点所经分支上的所有结点。</li>
<li>子孙结点: 以某一结点为根的的子树中的任一结点都称为该结点的子孙。<h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3>结点的层次从根结点开始定义起，根结点为第一层，根的孩子结点为第二层。<h3 id="结点的深度"><a href="#结点的深度" class="headerlink" title="结点的深度"></a>结点的深度</h3>对于任意结点n,n的深度为从根到n的唯一路径长，根的深度为0<h3 id="结点的高度"><a href="#结点的高度" class="headerlink" title="结点的高度"></a>结点的高度</h3>对于任意结点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0<h2 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h2>树的度是树内各结点的度的最大值。<h2 id="树的深度和高度"><a href="#树的深度和高度" class="headerlink" title="树的深度和高度"></a>树的深度和高度</h2>树中结点的最大层次称为树的深度或高度。<h2 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h2>树中结点的各棵树是有次序的，位置不能交换。<h2 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h2>树中结点的各棵子树之间的次序不重要，可以相互交换位置。<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2>森林是m(m&gt;0)棵不相交的树的集合，增加一个根节点，让其他树成为根节点的子树，那么森林就变成了一颗树。<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2>存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适，是否方便，时间复杂度好不好。<h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3>除了根结点外，每个结点不一定有孩子结点，但一定有双亲结点。因此用一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。<br>每个结点包含数据域和指针域，指针域存储该节点的双亲在数组的下标。还可以设置左子域保存左孩子结点的位置，或者是右兄弟域保存右兄弟的位置，没有都用-1表示。<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3>由于树的每个结点有多棵子树，可以用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，这种表示方法称为多重链表表示法。</li>
<li>方式一： 指针域的个数等于树的度。缺点：可能造成空间浪费。</li>
<li>方式二： 每个结点指针域的个数等于该结点的度，专门设置一个域来存储该结点的子结点的个数。克服了浪费空间的问题，但是每个结点的链表结构不同，加上要维护结点的度的数值，在运算上就增加了时间上的损耗。<br>为了减少空指针的浪费，又使结点结构相同，使用孩子表示法。</li>
</ul>
<p>孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。<br>n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。</p>
<p>结构：表头数组和孩子链表<br>两种结点结构：</p>
<ol>
<li>一个是孩子链表的孩子结点，有孩子结点的数据域保存孩子结点n在表头数组中的下标。有指针域存储指向下一个孩子结点的指针。</li>
<li>一个是表头数组的表头结点，有数据域存储结点的数据信息，有头指针域，存储该结点的孩子链表的头指针。</li>
</ol>
<p>孩子表示法的缺陷是无法知道某个结点的双亲。解决办法是结合双亲表示法，设置一个数据域存储双亲结点的下标。</p>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是树的一种特殊情况，每个结点最多有两个孩子结点，分别称为该结点的左孩子结点和右孩子结点。在二叉树中，不存在度大于2的节点。二叉树的子树有左右之分，次序不能颠倒。</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li>在二叉树的第i层，最多有2的i-1次方个结点。</li>
<li>深度为k的二叉树，最少有k个节点，最多有2的k次方-1个结点。</li>
<li>对于一棵非空二叉树，叶结点的数量等于度为2的节点数量加1。</li>
<li>二叉树的结点总数为叶子结点数和度为1的结点数和度为2的结点数之和。</li>
<li>树的分支总数为结点总数-1。</li>
<li>具有n个结点的完全二叉树的深度为log2为底n为真数的向下取整 + 1。</li>
<li>对一棵有n个结点的完全二叉树的结点按层序编号，从第一层到最后一层，每层从左到右依次编号。对任一结点i，如果i=1，则结点i为根节点，如果i&gt;1，则其双亲结点为i/2向下取整。如果2i&gt;n，则结点无左孩子，且i结点为叶子结点。如果2i &lt; n，则i结点的左孩子结点为2i。如果2i+1 &gt; n，则i结点无右孩子，如果2i+1 &lt; n, 则i结点的右孩子结点为2i+1。<h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><h4 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h4>所有结点都是只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树。斜树的每一层都只有一个结点，因此斜树的结点的个数等于树的层数。<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4>深度为k的满二叉树，是有2的k次方-1个节点的二叉树，每一层都达到了可以容纳的最大数量的节点。<br>特点：</li>
</ul>
<ol>
<li>叶子结点只能出现在最底下的那层。</li>
<li>非叶子结点的度一定是2.</li>
<li>同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4>深度为k的完全二叉树，从第1层到第k-1层都是满的，第k层的节点必须从左向右依次排列，第k层也可以是满的。<br>满二叉树一定是一棵完全二叉树，完全二叉树不一定是满二叉树。<br>特点：</li>
<li>叶子结点只能出现在最底下两层。</li>
<li>最底下的叶子结点一定集中在左部连续位置。</li>
<li>倒数第二层，若有叶子结点，一定集中在右部连续位置。</li>
<li>结点的度为1,则该结点只有左孩子，不存在只有右孩子的情况。</li>
<li>同样结点数的二叉树，完全二叉树的深度最小。<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4>顺序存储对于树这种一对多的关系结构实现比较困难。但是二叉树是一种特殊的树，因此也可以使用顺序存储实现二叉树。<br>二叉树的顺序存储结构就是用以为数组存储二叉树中的结点。并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。<br>对于一般二叉树，使用顺序存储结构，按照完全二叉树的方式，按层序去存放到数组，没有的结点可以设置为空，因此存在浪费存储空间的问题。顺序存储结构一般只用于完全二叉树。<h4 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h4>二叉树每个结点最多有两个孩子，因此设置一个数据域和两个指针域，一个左指针和一个右指针分别指向左孩子和右孩子。<br>如果有需要还可以增加一个指向其双亲的指针域，那样的称之为三叉链表。<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4>先访问根节点，然后前序遍历左子树，再前序遍历右子树。前序遍历的第一个结点一定是根结点。<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4>先中序遍历左子树，然后访问根节点，再中序遍历右子树。<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4>先后序遍历左子树，然后后序遍历右子树，再访问根节点。<br>就是从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。后序遍历的最后一个结点一定是根结点。<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4>从根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<h4 id="遍历的性质"><a href="#遍历的性质" class="headerlink" title="遍历的性质"></a>遍历的性质</h4></li>
</ol>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>树的遍历中，使用递归大大提高效率，简化代码。<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3>对二叉树遍历之后，得出序列之后，让结点的空指针域存放指向结点在某种遍历次序下的前驱和后继结点的地址。<br>这种指向前驱和后继的指针称为线索，加上线索的二叉树链表称为线索链表，相对的二叉树就称为线索二叉树。所以对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。<br>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。</li>
</ul>
<p>给每个结点增加两个标志域，ltag存放0表示指向该结点的左孩子，存放1表示指向该结点的前驱。rtag存放0表示指向该结点的右孩子，存放1表示指向该结点的后继。<br>在实际问题中，如果所用的二叉树需经常遍历或查找结点时，需要某种遍历序列中的前驱和后继，那么就采用线索二叉链表的存储结构。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>二叉搜索树具有以下四点性质：</p>
<ol>
<li>所有节点关键码都互不相同</li>
<li>左子树上所有节点的关键码都小于根节点的关键码</li>
<li>右子树上所有节点的关键码都大于根节点的关键码</li>
<li>左右子树也是二叉搜索树</li>
</ol>
<p>关键码是节点所保存元素中的某个属性，它能够<br>唯一的表示这个节点。对二叉搜索树进行中序遍历，就可以按照关键码的大小从小到大的顺序将节点排列起来。因此，二叉搜索树也叫二叉排序树。</p>
<p>二叉搜索树可以用来表示字典结构，它的搜索，插入，删除操作的平均时间代价为O(log2N)。</p>
<p>二叉搜索树的左子树的最后一个左节点是最小值，右子树的最后一个右节点是最大值。</p>
<p>当二叉搜索树只有左子树或右子树的时候是等同于一个链表结构的。</p>
<p>搜索一个数据的时候，树有几层，最多就只需要比较几次。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入时，从根节点开始，被插入元素的关键码如果小于根节点的关键码，则进入到左子树中执行插入操作，如果左子树不存在，则被插入元素成为左孩子节点；反之，进入右子树中执行插入操作，右子树不存在，则被插入元素成为右孩子，如果被插入元素的关键码已经存在，则返回false。</p>
<h4 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h4><p>从树的根节点开始，如果被搜索元素的关键码比根节点关键码小，则进入到左子树中进行搜索，若左子树不存在，返回null。如果被搜索元素的关键码比根节点关键码大，则进入到右子树中进行搜索，若右子树不存在，返回null。如果根节点的关键码和被搜索元素的关键码相同，返回这个根节点。</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除一个节点时，要考虑必须将删除节点的子孙节点连接到树上，同时保证二叉搜索树的性质。<br>根据被删除节点的左右子孩子，可以总结以下几种情况：</p>
<ol>
<li>被删除节点左右孩子都不存在：只需要让其父节点指向它的指针指向null即可。</li>
<li>被删除节点没有左孩子：用右孩子替代它的位置。</li>
<li>被删除节点没有右孩子：用左孩子替代它的位置。</li>
<li>被删除节点左右孩子都存在：首先去被删除节点的右子树中找到中序遍历下的第一个节点，假设节点的data数据为x，将被删除节点的data替换成x，而后，在被删除节点的右子树中执行删除x的操作。<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3>AVL树首先是一棵二叉搜索树，但它具备自平衡的能力，它的左右子树都是AVL树，且左右子树的高度差的绝对值不超过1。AVL树是高度平衡的二叉搜索树。AVL树就是为了避免二叉搜索树形成链表的形式。</li>
</ol>
<p>节点的平衡因子为该节点的右子树的高度-左子树的高度，左右子树的高度差的绝对值不超过1称为高度平衡。</p>
<h4 id="插入时的平衡化旋转"><a href="#插入时的平衡化旋转" class="headerlink" title="插入时的平衡化旋转"></a>插入时的平衡化旋转</h4><p>对一个AVL树，它的任意一个节点的平衡因子都只能取-1，0，1中的一个，如果节点的平衡因子绝对值大于1，则AVL树失去平衡性。<br>每插入一个节点后，都要从这个节点开始向上更新父节点的平衡因子，如果插入节点是父节点的左孩子，则父节点的平衡因子减去1，如果插入节点是父节点的右孩子，则父节点的平衡因子加1，更新后有以下3种情况：</p>
<ol>
<li>父节点的平衡因子为0，插入的这个新节点不会导致不平衡。</li>
<li>父节点的平衡因子变为2或者-2，需要进行平衡化调整。</li>
<li>父节点的平衡因子变为-1 或1，但这棵子树的高度增加了1，会因此昂到更高层的节点，因此要继续遍历更新父节点的平衡因子，直到找到平衡因子变为2 或-2 的节点，或者遍历到整棵树的根节点。</li>
</ol>
<p>对于一个平衡因子为2或者-2的节点，有四种平衡旋转方式使其平衡，分别是：左单旋转，右单旋转，先左后右双旋转，先右后左双旋转。</p>
<h3 id="树-森林和二叉树的转换"><a href="#树-森林和二叉树的转换" class="headerlink" title="树,森林和二叉树的转换"></a>树,森林和二叉树的转换</h3><h4 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h4><p>将树转换为二叉树的步骤：</p>
<ol>
<li>加线：在所有兄弟结点之间加一条连线。</li>
<li>去线：对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</li>
<li>层次调整：以根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。 <h4 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h4>森林由若干棵树组成，所以森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。</li>
<li>把每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后，就得到了由森林转换来的二叉树。<h4 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h4>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。</li>
<li>加线：若某结点k的左孩子结点存在，则将这个左孩子结点的n个右孩子结点都作为此结点k的孩子结点。将该结点k与右孩子结点用线连接。</li>
<li>去线：删除原二叉树中所有结点与右孩子结点的连线。</li>
<li>层次调整：使结构层次分明。<h4 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h4>首先判断一个二叉树能否转换为森林还是一棵树，看这个二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。<br>二叉树转换成森林的步骤：</li>
<li>从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再看分离后的二叉树，若右孩子存在，则连线删除，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每个分离后的二叉树转换为树即可。<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4>树的遍历分为两种方式。</li>
<li>先根遍历树，即先访问树的根结点，然后依次先根遍历根的每个子树。</li>
<li>后根遍历树，即先依次后根遍历每个子树，然后再访问根节点。<h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4>森林的遍历也分为两种方式。</li>
<li>前序遍历。</li>
<li>后序遍历。<br>森林的前序遍历和二叉树的前序遍历结果是一样的，森林的后序遍历和二叉树的中序遍历结果相同。也就是当二叉链表作为树的存储结构时，树和森林的先序遍历和后序遍历可以借用二叉树的前序遍历和中序遍历的算法来实现。先把树和森林转化成二叉树，在使用二叉树的前序遍历或中序遍历。<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3>带权路径长度(WPL)最小的二叉树称作哈夫曼树。也称为最优二叉树。<h4 id="权"><a href="#权" class="headerlink" title="权"></a>权</h4>树结点之间边相关的数叫做权。<h4 id="树的路径长度"><a href="#树的路径长度" class="headerlink" title="树的路径长度"></a>树的路径长度</h4>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。<br>树的路径长度就是从树的根结点到每一个结点的路径长度之和。<h4 id="结点的带权路径长度"><a href="#结点的带权路径长度" class="headerlink" title="结点的带权路径长度"></a>结点的带权路径长度</h4>从某结点到根结点之间的路径长度与该结点上权的乘积。<h4 id="树的带权路径长度"><a href="#树的带权路径长度" class="headerlink" title="树的带权路径长度"></a>树的带权路径长度</h4>树的带权路径长度为树中所有叶子结点的带权路径长度之和。<h4 id="构造哈夫曼树的算法描述"><a href="#构造哈夫曼树的算法描述" class="headerlink" title="构造哈夫曼树的算法描述"></a>构造哈夫曼树的算法描述</h4></li>
<li>根据给定的n个权值{W1,W2,W3,W4…,Wn}构成n棵二叉树的集合F={T1,T2,T3,T4…,Tn}，其中每个二叉树Ti中只有一个带权为Wi的根结点，其左右子树均为空。</li>
<li>在F中选取两个根结点的权值最小的树作为左右子树构造一个新的二叉树，且让新的二叉树的根结点的权值为其左右子树上根结点权值之和。</li>
<li>在F中删除上述的两个树，将新的二叉树加入到F中。</li>
<li>重复上述2，3步骤直到F中只含有一个树为止，这个树就是哈夫曼树。<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4>哈夫曼树对于高频率出现的数据，遍历效率非常的高。哈夫曼编码主要的目的是节省数据存储空间和传输成本，哈夫曼编码原理就是数据压缩的基本原理。</li>
</ol>
<p>设需要编码的字符集为{d1,d2,d3,…,dn}，各个字符在电文中出现的次数或频率集合为{W1,W2,…Wn}，以d1,d2为叶子结点，以W1，W2作为相应的叶子结点的权值来构造一个哈夫曼树。规定哈夫曼的左分支代表0,右分支代表1,则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是哈夫曼编码。</p>
<p>编码中非0即1,长短不等的话非常容易混淆，要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码。<br>在发送和接受双方都必须要按约定好的相同的哈夫曼编码规则。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是由顶点的集合和顶点之间的边的集合组成。通常表示为：G(V,E)，V是顶点的集合，E是边的集合。<br>图中的数据元素称之为顶点，顶点集合一定是有穷且非空的。在图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</p>
<h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><h3 id="无向边"><a href="#无向边" class="headerlink" title="无向边"></a>无向边</h3><p>顶点之间的边没有方向，则称这条边为无向边。<br>无向边用(A, D)表示，可以交换顶点。</p>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>图中任意两个顶点之间的边都是无向边，则称该图为无向图。<br>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。<br>含有n个顶点的无向完全图有n*(n-1)/2条边。</p>
<h3 id="有向边"><a href="#有向边" class="headerlink" title="有向边"></a>有向边</h3><p>顶点之间有方向，则称这条边为有向边，也称为弧。<br>有向边用&lt;A, D&gt;表示，不可以交换顶点，它们出现的次序表示的边的方向。</p>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>图中任意两个顶点之间的边都是有向边，则称该图为有向图。<br>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。<br>含有n个顶点的有向完全图有n*(n-1)条弧。</p>
<h3 id="权-1"><a href="#权-1" class="headerlink" title="权"></a>权</h3><p>在图上的边或弧相关的数叫做权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。</p>
<h3 id="网"><a href="#网" class="headerlink" title="网"></a>网</h3><p>带权的图通常称为网。</p>
<h3 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h3><p>对于无向图，顶点的度是和顶点相关联的边的数目，记为TD(v)。边数其实就是各顶点度数和的一半。<br>对于有向图，进入顶点v的弧的数目称为v的入度，记为ID(v)。从顶点v出发的弧的数目称为v的出度，记为OD(v)。顶点的度为TD(v) = ID(v) + OD(v)</p>
<h3 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h3><p>从一个顶点到另一个顶点上的某一路径上边或弧的数目。</p>
<h3 id="回路"><a href="#回路" class="headerlink" title="回路"></a>回路</h3><p>第一个顶点到最后一个顶点相同的路径称为回路或者环。<br>序列中顶点不重复出现的路径称为简单路径。<br>除了第一个和最后一个顶点相同之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p>
<h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p>对于无向图中任意两个顶点都是连通的，则称此图是连通图。</p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p>无向图中的极大连通子图称为连通分量。</p>
<ul>
<li>连通分量必须是子图</li>
<li>子图必须是连通的</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li>
</ul>
<h3 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h3><p>在有向图中，每一对结点之间都存在路径。从v1到v2,也能从v2到v1。则称该图是强连通图。</p>
<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p>有向图中的极大强连通子图称为有向图的强连通分量。</p>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>无向图中连通且n个顶点n-1条边叫做生成树。不过有n-1条边并不一定是生成树。</p>
<h3 id="有向树"><a href="#有向树" class="headerlink" title="有向树"></a>有向树</h3><p>有向图中一顶点的入度为0,其余顶点入度为1的叫有向树。</p>
<h3 id="生成森林"><a href="#生成森林" class="headerlink" title="生成森林"></a>生成森林</h3><p>一个有向图由若干棵有向树构成生成森林。</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>图的结构比较复杂，任意两个顶点之间都可能有关系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而使用多重链表，尽管可以实现图结构，但是会造成存储单元的浪费。</p>
<h3 id="领接矩阵"><a href="#领接矩阵" class="headerlink" title="领接矩阵"></a>领接矩阵</h3><p>将图的顶点和边分成两个结构来分别存储。使用一个一维数组来存顶点，一个二维数组(领接矩阵)来存边，用0表示两点之间没有边，1表示两点之间有边。</p>
<p>无向图的边数组是一个对称矩阵，通过这个矩阵能得到以下信息：</p>
<ul>
<li>任意两顶点是否有边无边。</li>
<li>某个顶点vi的度，就是这个顶点所在i行或i列的元素数值之和。</li>
<li>某个顶点vi的所有领接点，就是将第i行的元素扫描一遍，arr[i][j]为1就是领接点。</li>
</ul>
<p>有向图的边数组并不一定是一个对称矩阵，有向图的矩阵有如下特点：</p>
<ul>
<li>顶点vi的入度的数目是矩阵中第i列各数之和，顶点vi的出度是第i行的各数之和。</li>
<li>判断顶点之间的边是否存在，只要查找矩阵中arc[i][j]是否为1。</li>
<li>求vi的所有邻接点，就是将矩阵第i行元素扫描一遍，找到arc[i][j]为1的点。</li>
</ul>
<p>缺点：邻接矩阵对于边数相对顶点较少的图，这种结构是对存储空间的极大浪费。</p>
<h3 id="有向网图的矩阵"><a href="#有向网图的矩阵" class="headerlink" title="有向网图的矩阵"></a>有向网图的矩阵</h3><p>带有权的有向图，称为有向网图，它的邻接矩阵用权值表示两个邻接点的边的存在，用0表示顶点自己指向自己，用无穷大表示两个顶点之间的边不存在。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>类似于树的孩子表示法，用数组存储每一个结点，对结点的孩子进行链式存储。这种数组和链表相结合的存储方式称为邻接表。<br>邻接表的处理方法：</p>
<ol>
<li>图中的所有顶点用一个一维数组存储，每个数据元素要设置一个指针域指向第一个邻接点的指针。</li>
<li>使用单链表存储每个顶点的邻接点。无向图中称为这个顶点的边表，有向图中称为这个顶点的出边表。单链表中每个结点设置两个域，一个数据域保存邻接点在数组中的下标，另一个指针域保存顶点指向的下一个邻接点的指针。</li>
</ol>
<p>获取图的信息：</p>
<ol>
<li>某个顶点的度 = 这个顶点的边表中结点的个数。</li>
<li>判断两个顶点之间是否有边，只要看某一个顶点的边表中是否有结点存在另一个顶点在数组中的下标即可。</li>
<li>求所有的顶点的邻接点，就是对此顶点的边表进行遍历，数据域上的值就是邻接点在数组中的下标，再通过下标去找到每一个邻接点。</li>
</ol>
<p>对于有向图有出度和入度之分，因此可以分别根据出度和入度做邻接表。根据入度做的邻接表，叫逆邻接表。这样可以算出每个顶点的入度和出度，判断的两顶点是否存在弧。<br>对于带有权值的网图，只要在边表结点定义中设置一个weigth的数据域来存储权值即可。</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>针对有向图，结合邻接表和逆邻接表。<br>表示方法：</p>
<ol>
<li>一维数组保存所有的顶点，每个数据元素有数据域data保存值，指针域firstin保存入边表的头指针，指向该顶点的入边表中的第一个结点，指针域firstout保存出边表的头指针，指向该顶点的出边表中的第一个顶点。</li>
<li>边表结构有数据域startIndx表示弧的起始顶点在数组中的下标，数据域endIndex表示弧的终止顶点在数组中的下标，指针域endPoint表示入边表的指针，指向终点相同的下一条边，指针域startPoint表示出边表的指针，指向起点相同的下一条边。</li>
<li>网图，可以增加一个数据域weight表示权值。</li>
</ol>
<p>虽然十字链表结构复杂，但是在有向图的应用中，十字链表是非常好的数据结构。</p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>对于无向图的邻接表，也可以仿照十字链表的方式，只不过对边表的结构进行一些改造。<br>表示方法：</p>
<ol>
<li>设置一个一维数组保存所有的顶点，每个数据元素有数据域data保存值，一个firstEdge指针域来保存顶点的第一条边。</li>
<li>设置一个边表，边表的结点设置有iIndex和jIndex数据域来保存这条边左右的两个顶点在数组中的下标。iNext和jNext两个指针域分别指向依附于下标为iIndex和jNext的顶点的下一条边。<br>邻接多重表和邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。要删除边，只需要设置依附于顶点的指针域为空即可。<h3 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h3>边集数组是由两个一维数组构成。一个存储顶点的信息；另一个存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)，终点下标(end)和权(weight)组成。</li>
</ol>
<p>边集数组是边的集合，在边集数组中要查找一个顶点的度需要扫描整个便数组，效率不高，因此它适合对边依次进行处理的操作，不适合对顶点的相关操作。</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中某一点出发访问图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫图的遍历。<br>在遍历过程中把访问过的顶点打上标记，以免访问多次。具体办法是设置一个访问数组visited[n]，n是图中顶点的个数，初始值为0，访问过就变为1.</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先遍历(Depth first search)，也称为深度优先搜索，简称DFS。深度优先遍历类似树的先序遍历。<br>方法： 先按约定好的一个访问策略去访问顶点，如在没有碰到重复点的情况下，始终是向右手边走，发现某顶点下没有未访问过的顶点，就返回到上一个顶点，每次访问一个点，就将它放入已经访问的数组中，并且在每次遍历的路径中，将顶点压入栈中，在返回时，如果当前栈顶元素没有其它邻接点没有访问，就弹出栈中，有的话就访问下一个顶点，压入栈中，重复这个过程。这是一个递归的过程，直到访问完所有的顶点。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历(Breadth first search)， 也称为广度优先搜索，简称BFS。<br>方法：在顶点和边的关系不变的情况下，将图稍微变形，将顶点分层放置，形状类似于树结构，然后一层一层访问所有的顶点。广度优先遍历类似树的层序遍历。</p>
<h2 id="构造连通网的最小生成树"><a href="#构造连通网的最小生成树" class="headerlink" title="构造连通网的最小生成树"></a>构造连通网的最小生成树</h2><p>一个带权值的图，即网结构。一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。那么我们称构造连通网的最小代价生成树称为最小生成树。<br>找连通网的最小生成树，有两种经典算法，普里姆算法和克鲁斯卡尔算法。</p>
<h2 id="普里姆算法（Prim）"><a href="#普里姆算法（Prim）" class="headerlink" title="普里姆算法（Prim）"></a>普里姆算法（Prim）</h2><h1 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h1><p>无序的数据集合。在优先级队列的各种实现中，堆是最高效的一种数据结构。</p>
<h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><h3 id="关键码"><a href="#关键码" class="headerlink" title="关键码"></a>关键码</h3><p>数据记录中存在一个能够标识数据记录的数据项，并可依据该数据项对数据进行组织，则称此数据项为关键码key。<br>把一个关键码集合的所有元素按照完全二叉树的顺序存储方式存在一个一维数组中。<br>在最小堆中，父节点的关键码小于等于它的左右子女的关键码。<br>在最大堆中，父节点的关键码大于等于它的左右子女的关键码。</p>
<h3 id="数组存储"><a href="#数组存储" class="headerlink" title="数组存储"></a>数组存储</h3><p>最小堆存储在数组中。</p>
<h3 id="最小堆的应用"><a href="#最小堆的应用" class="headerlink" title="最小堆的应用"></a>最小堆的应用</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>使用最小堆进行排序，使用待排序数组初始化最小堆，然后逐个删除堆顶元素，并用数组保存。然后调整最小堆，由于堆顶元素始终最小，所以可以得到一个有序的数组。</p>
<h4 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h4><p>求一个非常大的数据集合有n个整数，求集合中最大的K个值。<br>用最小堆来算，非常简单，初始化一个大小为k的最小堆，先放入k个数。这时，堆顶元素最小，集合中剩余的数依次和堆顶元素比较，如果比堆顶元素大，则删除堆顶元素，并放入新的元素，全部比较以后，对立的元素就是最大的k个值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/08/数据结构与算法/" data-id="ckh44mzuf001i4sv2pu032l49" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/05/面试学习/" class="article-date">
  <time datetime="2020-06-05T05:24:20.000Z" itemprop="datePublished">2020-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/05/面试学习/">面试学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="VS-Code-使用"><a href="#VS-Code-使用" class="headerlink" title="VS Code 使用"></a>VS Code 使用</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>F5启动调试，默认支持Node调试。</p>
<h2 id="网页调试"><a href="#网页调试" class="headerlink" title="网页调试"></a>网页调试</h2><p>安装Debugger for Chrome扩展，基本配置如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  launch.js启动调试的配置文件</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Launch localhost"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"chrome"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,            </span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"http://localhost:8080/"</span>,</span><br><span class="line">            <span class="string">"webRoot"</span>: <span class="string">"$&#123;workspaceFolder&#125;/wwwroot"</span> <span class="comment">//默认index.html的文件夹位置, workspaceFolder 是当前.vscode所在的文件夹</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装http-server, 并启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i http-server -g</span><br><span class="line">http-server</span><br></pre></td></tr></table></figure>

<p>然后按F5，选择使用Chrome，就可以使用Chrome进行调试html中的js文件。</p>
<h2 id="VS-Code集成Git"><a href="#VS-Code集成Git" class="headerlink" title="VS Code集成Git"></a>VS Code集成Git</h2><h3 id="下载-git"><a href="#下载-git" class="headerlink" title="下载 git"></a>下载 git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<h3 id="使用git"><a href="#使用git" class="headerlink" title="使用git"></a>使用git</h3><ol>
<li>命令行使用git命令</li>
<li>命令面板：ctrl+shift+P </li>
<li>克隆 git:clone  –&gt; enter url</li>
<li>将本地工作区文件夹 变为 git 本地仓库</li>
<li>添加远程仓库 git:add remote –&gt; enter remote name –&gt; enter remote url</li>
<li>git add</li>
<li>git commit</li>
<li>git push</li>
<li>git pull</li>
</ol>
<h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><h2 id="安装扩展"><a href="#安装扩展" class="headerlink" title="安装扩展"></a>安装扩展</h2><h3 id="vue-vscode-snippets"><a href="#vue-vscode-snippets" class="headerlink" title="vue-vscode-snippets"></a>vue-vscode-snippets</h3><p>生成代码片段的快捷方式</p>
<h3 id="vetur"><a href="#vetur" class="headerlink" title="vetur"></a>vetur</h3><p>语法高亮，代码片段，错误检查</p>
<h1 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h1><h2 id="Vue-核心思想简介"><a href="#Vue-核心思想简介" class="headerlink" title="Vue 核心思想简介"></a>Vue 核心思想简介</h2><p>Vue 核心思想：1.数据驱动应用 2.MVVM模式(Model, View, VirtualModel)</p>
<p>MVVM框架的三要素： 数据响应式， 模板引擎(模板 -&gt; VNode)， 渲染(VNode -&gt; DOM)</p>
<p>响应式： Vue如何监听数据变化？数据变化更新视图， 视图变化更新数据。<br>模板： Vue模板如何编写和解析。<br>渲染： Vue如何将模板转换为html。</p>
<h2 id="Vue-核心知识点"><a href="#Vue-核心知识点" class="headerlink" title="Vue 核心知识点"></a>Vue 核心知识点</h2><h3 id="插值文本"><a href="#插值文本" class="headerlink" title="插值文本"></a>插值文本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据绑定指令"><a href="#数据绑定指令" class="headerlink" title="数据绑定指令"></a>数据绑定指令</h3><p>v-bind:attr，缩写 :attr</p>
<h3 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h3><p>v-for=(item of array) 注意要绑定key属性(:key=’item.id’)。</p>
<h3 id="数据双向绑定指令"><a href="#数据双向绑定指令" class="headerlink" title="数据双向绑定指令"></a>数据双向绑定指令</h3><p>v-model 指令使用在表单元素 input, select, option等。</p>
<h3 id="事件处理指令"><a href="#事件处理指令" class="headerlink" title="事件处理指令"></a>事件处理指令</h3><p>v-on 指令监听DOM事件或传递自定义事件到子组件，触发时调用回调函数。<br>v-on:click=”clickFunc”, 缩写：:click=”clickFunc”。<br>事件修饰符，按键修饰符。</p>
<h3 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;active: condition === true&#125;"</span></span><br><span class="line">:style=<span class="string">"&#123;backgroundColor: isBlue ? 'blue' : 'purple'&#125;"</span></span><br></pre></td></tr></table></figure>

<p>active为class，后面的属性值是表达式的计算结果，表示是否添加active这个class。<br>还可以是一个数组，里面就要设置的一个个样式的className。</p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>v-if=”isExists” 控制元素是否真实的渲染<br>v-if=””<br>v-else-if=””<br>v-else<br>注意v-if不能和v-for在同一个标签上，v-for的优先级比v-if高。</p>
<p>v-show=”” 通过控制css属性display控制元素显示，但是元素总是存在的。<br>v-if惰性渲染元素，如果一开始条件就是falsy，那么元素就是不存在的，并不会渲染。</p>
<h3 id="Vue对模板的处理"><a href="#Vue对模板的处理" class="headerlink" title="Vue对模板的处理"></a>Vue对模板的处理</h3><p>Vue将模板编译成 虚拟DOM渲染函数，然后渲染函数会将VNode渲染成DOM。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。<br>实际上Vue内部，实际上是将模板转换成了render函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(app.$options.render)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是生成的模板渲染函数(render函数)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;<span class="keyword">with</span>(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125;&#125;,[_c(<span class="string">'h2'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"title"</span>:title&#125;&#125;,[_v(<span class="string">"\n            "</span>+_s(title)+<span class="string">"\n        "</span>)]),_v(<span class="string">" "</span>),_c(<span class="string">'input'</span>,&#123;<span class="attr">directives</span>:[&#123;<span class="attr">name</span>:<span class="string">"model"</span>,<span class="attr">rawName</span>:<span class="string">"v-model"</span>,<span class="attr">value</span>:(course),<span class="attr">expression</span>:<span class="string">"course"</span>&#125;],<span class="attr">attrs</span>:&#123;<span class="string">"type"</span>:<span class="string">"text"</span>&#125;,<span class="attr">domProps</span>:&#123;<span class="string">"value"</span>:(course)&#125;,<span class="attr">on</span>:&#123;<span class="string">"keydown"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;<span class="keyword">if</span>(!$event.type.indexOf(<span class="string">'key'</span>)&amp;&amp;_k($event.keyCode,<span class="string">"enter"</span>,<span class="number">13</span>,$event.key,<span class="string">"Enter"</span>))<span class="keyword">return</span> <span class="literal">null</span>;<span class="keyword">return</span> addCourse($event)&#125;,<span class="string">"input"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;<span class="keyword">if</span>($event.target.composing)<span class="keyword">return</span>;course=$event.target.value&#125;&#125;&#125;),_v(<span class="string">" "</span>),_c(<span class="string">'button'</span>,&#123;<span class="attr">on</span>:&#123;<span class="string">"click"</span>:addCourse&#125;&#125;,[_v(<span class="string">"新增课程"</span>)]),_v(<span class="string">" "</span>),(courses.length == <span class="number">0</span>)?_c(<span class="string">'p'</span>,[_v(<span class="string">"没有任何课程信息"</span>)]):_e(),_v(<span class="string">" "</span>),_c(<span class="string">'ul'</span>,_l((courses),<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span> _c(<span class="string">'li'</span>,&#123;<span class="attr">class</span>:&#123;<span class="attr">active</span>: (selectedCourse === c)&#125;,<span class="attr">on</span>:&#123;<span class="string">"click"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;selectedCourse = c&#125;&#125;&#125;,[_v(_s(c))])&#125;),<span class="number">0</span>)])&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="计算属性和监听器"><a href="#计算属性和监听器" class="headerlink" title="计算属性和监听器"></a>计算属性和监听器</h3><p>computed属性,计算属性有缓存性，只有依赖的数据变化了，才会去重新计算，重新渲染页面。<br>watch属性,默认情况下watch初始化时，不会执行，只有数据变化了，才会执行到watch里面的函数，但是通过配置immediate属性可以让watch立即执行。</p>
<p>watch和computed的差异<br>watch适用于一个值变化了，影响多个值的情形。一个值的变化引起很多事件的处理。当在数据变化时需要执行异步操作或者较大开销的操作情况更适合使用watch。<br>computed适用于多个值变化了，影响一个值的情形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> &#123;</span><br><span class="line">        title: <span class="string">'hello'</span>,</span><br><span class="line">        name: <span class="string">'Vue'</span></span><br><span class="line">    &#125;&#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.title === <span class="string">'hello'</span> ? <span class="string">'world'</span> : <span class="string">'vue'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    watch: &#123;</span><br><span class="line">        title: <span class="function"><span class="keyword">function</span> (<span class="params">newV, oldV</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// block</span></span><br><span class="line">        &#125;,</span><br><span class="line">        name: &#123;</span><br><span class="line">            immediate: <span class="literal">true</span>, <span class="comment">// 立即执行</span></span><br><span class="line">            <span class="comment">// deep: true, 深层的监听</span></span><br><span class="line">            handler: <span class="function"><span class="keyword">function</span> (<span class="params">newV, oldV</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// block</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每一个Vue实例创建时都要经过一系列的初始化过程： 设置数据监听， 编译模板， 将实例挂载到DOM，并在数据变化的时候更新DOM等，称为Vue实例的生命周期。</p>
<h4 id="使用生命周期钩子函数"><a href="#使用生命周期钩子函数" class="headerlink" title="使用生命周期钩子函数"></a>使用生命周期钩子函数</h4><p>在Vue实例的生命周期的过程中会运行一些叫做生命周期的钩子函数，可以在不同的阶段添加自己代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate() &#123;&#125;</span><br><span class="line">created() &#123;&#125; <span class="comment">//在生命周期钩子函数中使用data中的数据时，最早只能在created中，此时能使用data中的数据，但此时还没有挂载，还没有DOM，还不能操作DOM</span></span><br><span class="line">beforeMount() &#123;&#125;</span><br><span class="line">mounted() &#123;&#125; <span class="comment">// 这mounted中，DOM已经生成，可以操作DOM。</span></span><br></pre></td></tr></table></figure>

<p>生命周期四个阶段及使用场景<br>初始化数据： beforeCreate(组件实例还未创建，数据还没有准备好，通常用于插件开发中执行一些初始化任务), created(组件初始化完毕，各种数据可以使用，常用于异步数据获取)<br>挂载组件:   beforeMount(未执行渲染，dom没有创建), mounted(dom创建完毕，可以用于获取访问数据和dom元素)<br>更新组件： beforeUpdate(更新前，可用于获取更新前的各种状态), updated(更新后，所有状态已是最新)<br>销毁组件： beforeDestroy(销毁前，组件实例还在，可用于定时器或订阅器的取消), destroyed(组件已销毁，可用于定时器或订阅器的取消)</p>
<h3 id="组件化基础"><a href="#组件化基础" class="headerlink" title="组件化基础"></a>组件化基础</h3><h4 id="使用Vue-component-创建子组件"><a href="#使用Vue-component-创建子组件" class="headerlink" title="使用Vue.component()创建子组件"></a>使用Vue.component()创建子组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组件时，建议使用-命名</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        courses: &#123;</span><br><span class="line">            type: <span class="built_in">Array</span>,</span><br><span class="line">            <span class="keyword">default</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            selectedCourse: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123; selectedCourse &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用子组件</span></span><br><span class="line"><span class="comment">// &lt;my-component&gt;&lt;/my-component&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是组件名，第二个参数是创建Vue实例时的属性选项(option)</p>
<h4 id="自定义事件及监听"><a href="#自定义事件及监听" class="headerlink" title="自定义事件及监听"></a>自定义事件及监听</h4><p>子组件和父组件进行通信，可以派发并监听自定义事件。<br>使用this.$emit(‘my-event’, params)</p>
<h4 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h4><p>自定义组件支持v-model需要组件内部实现input的:value和@input</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;my-component v-model="mydata"&gt;&lt;/mycomponent&gt;</span></span><br><span class="line"><span class="comment">// v-model其实是语法糖，它等价于如下写法</span></span><br><span class="line"><span class="comment">// &lt;my-component :value="mydata" @input="mydata=$event"&gt;&lt;/my-component&gt;</span></span><br><span class="line"><span class="comment">// 子组件内部传入value，并派发input事件</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">    props: [<span class="string">'value'</span>],</span><br><span class="line">    template: </span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="text" :value="value" @input="inputEvent"&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        inputEvent(e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, e.target.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="slot通过插槽进行内容分发"><a href="#slot通过插槽进行内容分发" class="headerlink" title="slot通过插槽进行内容分发"></a>slot通过插槽进行内容分发</h4><p>通过slot元素可以给子组件传递内容<br>默认插槽<br>具名插槽<br>作用域插槽 (插槽props)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'message'</span>, &#123;</span><br><span class="line">    props: [<span class="string">'show'</span>],</span><br><span class="line">    template: </span><br><span class="line">        <span class="string">`&lt;div v-if="show"&gt;</span></span><br><span class="line"><span class="string">            &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">            &lt;slot name="title" title="来自于子组件的title"&gt;默认标题&lt;/slot&gt;</span></span><br><span class="line"><span class="string">            &lt;span @click="$emit('update:show', false)"&gt;X&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用message组件,使用事件修饰符.sync</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;message :show.sync="show"&gt;</span></span><br><span class="line"><span class="comment">        &lt;template v-slot:default&gt; hello world&lt;/template&gt;</span></span><br><span class="line"><span class="comment">        &lt;template v-slot:title="slotProps"&gt;</span></span><br><span class="line"><span class="comment">            haha &#123;&#123;slotProps.title&#125;&#125;</span></span><br><span class="line"><span class="comment">        &lt;/template&gt;</span></span><br><span class="line"><span class="comment">    &lt;/message&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="组件化总结"><a href="#组件化总结" class="headerlink" title="组件化总结"></a>组件化总结</h4><p>组件化是Vue的精髓，Vue应用由一个个组件构成。<br>定义：组件就是可复用的Vue实例，准确的说他们是Vue.component的实例，继承自Vue。<br>优点：组件化增加代码的可复用性，可维护性和可测试性<br>使用场景： 什么时候使用场景</p>
<ul>
<li>通用组件： 实现最基本的功能，具有通用性，复用性，例如按钮组件，输入组件，布局组件 等。</li>
<li>业务组件： 他们完成具体业务，具有一定的复用性，例如登录组件，注册组件。</li>
<li>页面组件： 组织应用各部分独立内容，需要时在不同的页面间切换，例如列表页，详情页组件。<br>如何使用组件</li>
<li>定义： Vue.component(), components选项</li>
<li>分类： 有状态组件，functional(函数式组件), abstract</li>
<li>通信： props, $emit/$on, provide/inject, $children/$parent/$root/$attrs/$listeners（耦合性强，使用的不多）</li>
<li>内容分发： slot元素，template， v-slot</li>
<li>优化： is(动态组件)， keep-alive, 异步组件<br>组件的本质<br>Vue组件的本质是产生虚拟DOM</li>
</ul>
<h3 id="Vue-API"><a href="#Vue-API" class="headerlink" title="Vue API"></a>Vue API</h3><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><ol>
<li><p>给对象增加属性。如果对象是响应式的，确保新增属性能触发视图更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(obj, <span class="string">'attrName'</span>, value)</span><br><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(obj, 'attrName', value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除对象的属性。如果对象是响应式的，确保删除能触发视图更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.delete(obj, <span class="string">'attrName'</span>)</span><br><span class="line"><span class="keyword">this</span>.$<span class="keyword">delete</span>(obj, <span class="string">'attrName'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h4><p>事件的监听和派发都是在同一个实例上。虽然写法上是父组件中绑定事件，但是底层Vue处理之后，仍然是同一个实例上做的监听。</p>
<ol>
<li><p>监听当前实例上的自定义事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板中 @test="func" </span></span><br><span class="line">vm.$on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callback function</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发当前实例上的事件。附加参数都会传给监听器的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$emit(<span class="string">'test'</span>, <span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听一个自定义事件，但只触发一次，触发之后，监听器就会被移除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$once(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callback</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除自定义事件监听器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$off() <span class="comment">// 移除所有事件监听器</span></span><br><span class="line">vm.$off(<span class="string">'test'</span>) <span class="comment">// 移除该事件所有的监听器</span></span><br><span class="line">vm.$off(<span class="string">'test'</span>, callback) <span class="comment">// 只移除这个回调的监听器</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h4><p>通过在Vue原型上添加一个Vue实例作为事件总线，实现组件间相互通信，而且不受组件间层级关系的影响。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样做可以在任意组件中使用this.$bus访问到该Vue实例。</span></span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'xxx'</span>, callback)</span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'xxx'</span>, value)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>组件或元素的引用<br>ref属性被用来给元素或者子组件注册引用信息，引用信息将会注册在父组件的vm.$refs对象上。<br>如果在普通的DOM元素上使用，引用指向的就是DOM元素，如果是子组件上使用，引用就指向组件。 </li>
</ol>
<p>注意 ref是作为渲染结果被创建的，在初始渲染时不能访问它们，最早只能在mounted里面。<br>$refs 不是响应式的，不要试图用它在模板中做数据绑定。<br>当v-for用于元素或组件时，引用信息将是包含DOM节点或组件实例的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;span ref="xxx"&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="keyword">this</span>.$refs.xxx</span><br></pre></td></tr></table></figure>

<h3 id="Vue扩展知识"><a href="#Vue扩展知识" class="headerlink" title="Vue扩展知识"></a>Vue扩展知识</h3><h4 id="过度和动画"><a href="#过度和动画" class="headerlink" title="过度和动画"></a>过度和动画</h4><p>Vue 在插入，更新或移除DOM时，提供了多种不同方式的应用过度效果。<br>包括以下工具： </p>
<ul>
<li>在CSS过度和动画中自动应用class</li>
<li>配合第三方CSS动画库，如Animate.css</li>
<li>在过度钩子函数中使用JavsScript直接操作DOM</li>
<li>配合使用第三方JS动画库，如Velocity.js</li>
</ul>
<ol>
<li>CSS过度动画<br>transition组件为嵌套元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. v-enter ：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移 除。</span></span><br><span class="line"><span class="comment">2. v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移 除。</span></span><br><span class="line"><span class="comment">3. v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。</span></span><br><span class="line"><span class="comment">4. v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</span></span><br><span class="line"><span class="comment">5. v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。</span></span><br><span class="line"><span class="comment">6. v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。</span></span><br><span class="line"><span class="comment">    fade-enter 入场前的动画</span></span><br><span class="line"><span class="comment">    fade-enter-active 入场动画</span></span><br><span class="line"><span class="comment">    fade-leave-to 离场的最后</span></span><br><span class="line"><span class="comment">    fade-leave-active 进入离场</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;transition name="fade"&gt;</span></span><br><span class="line"><span class="comment">        &lt;div class="fade-enter"&gt;</span></span><br><span class="line"><span class="comment">        &lt;/div&gt;</span></span><br><span class="line"><span class="comment">    &lt;/transition&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>v-enter<br>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.fade-enter &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>v-enter-active<br>v-enter-active ：定义进入过渡生效时的状态。在元素被插入之前生效，在过渡/动画完成之后移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fade-enter-active &#123; transition: opacity .5s; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>v-enter-to<br>v-enter-to : 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移 除)，在过渡/动画完成之后移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fade-enter-to &#123; opacity: 1; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>v-leave<br>v-leave : 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fade-leave &#123; opacity: 1; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>v-leave-active<br>v-leave-active ：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触 发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和 曲线函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fade-leave-active &#123; transition: opacity .5s; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>v-leave-to<br>v-leave-to : 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被 删除)，在过渡/动画完成之后移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fade-leave-to &#123; opacity: 0; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>使用CSS动画库<br>通过自定义过度类名可以有效结合Animate.css这类动画库制作更精美的动画效果。<br>引入animate.css<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在transition中使用animate中的class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOut&quot;&gt;&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>JavaScript 钩子<br>可以在transition中生命JavaScript钩子，使用JS实现动画。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &lt;transition </span><br><span class="line">    @before-enter=&quot;beforeEnter&quot;</span><br><span class="line">    @enter=&quot;enter&quot;</span><br><span class="line">    @before-leave=&quot;beforeLeave&quot;</span><br><span class="line">    @leave=&quot;leave&quot;</span><br><span class="line"> &gt;</span><br><span class="line"> &lt;/transition&gt;</span><br><span class="line"></span><br><span class="line">// JS钩子</span><br><span class="line">methods: &#123;</span><br><span class="line">    beforeEnter(el) &#123;</span><br><span class="line">        // 动画初始化状态</span><br><span class="line">        el.style.opacity = 0</span><br><span class="line">    &#125;,</span><br><span class="line">    enter(el, done) &#123;</span><br><span class="line">        // 触发回流激活动画</span><br><span class="line">        document.body.offsetHeight</span><br><span class="line">        // 动画结束状态</span><br><span class="line">        el.style.opacity = 1</span><br><span class="line">        // 监听动画结束事件，并执行done</span><br><span class="line">        el.addEventListener(&apos;transitionend&apos;, done)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeLeave(el) &#123;</span><br><span class="line">        // 动画初始状态</span><br><span class="line">        el.style.opacity = 1</span><br><span class="line">    &#125;,</span><br><span class="line">    leave(el, done) &#123;</span><br><span class="line">        // 触发回流激活动画</span><br><span class="line">        document.body.offsetHeight</span><br><span class="line">        // 动画结束状态</span><br><span class="line">        el.style.opacity = 0</span><br><span class="line">        // 监听动画结束事件，并执行done</span><br><span class="line">        el.addEventListener(&apos;transitionend&apos;, done)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>纯JS方案<br>引入velocity.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloundflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用velocity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> // JS钩子</span><br><span class="line">methods: &#123;</span><br><span class="line">    beforeEnter(el) &#123;</span><br><span class="line">        // 动画初始化状态</span><br><span class="line">        el.style.opacity = 0</span><br><span class="line">    &#125;,</span><br><span class="line">    enter(el, done) &#123;</span><br><span class="line">        Velocity(el, &#123; opacity:1 &#125;, &#123; duration: 1500, complete: done &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeLeave(el) &#123;</span><br><span class="line">        // 动画初始状态</span><br><span class="line">        el.style.opacity = 1</span><br><span class="line">    &#125;,</span><br><span class="line">    leave(el, done) &#123;</span><br><span class="line">        Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: 1500, complete: done&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>列表过度<br>利用transition-group元素可以对v-for渲染的每个元素应用过度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition-group name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;c in courses&quot; :key=&quot;c.name&quot;&gt;</span><br><span class="line">        &#123;&#123; c.name &#125;&#125; - ￥&#123;&#123;c.price&#125;&#125;&lt;button @click=&quot;addToCart(c)&quot;&gt;加购&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>Vue允许自定义过滤器，可以被用于一些常见的文本格式化。过滤器可以用在双大括号 和v-bind表达式。<br>注意管道符左边的值作为过滤器的第一个参数， ()中的第一个参数是过滤器的第二个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 全局定义过滤器 --&gt;</span><br><span class="line">Vue.filter(&apos;currency&apos;, function (val, symbol = &apos;$&apos;) &#123;</span><br><span class="line">    return symbol + val</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 局部定义过滤器 --&gt;</span><br><span class="line">filters: &#123;</span><br><span class="line">    currency(val, symbol = &apos;$&apos;) &#123;</span><br><span class="line">        return symbol + val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 在插值中使用 --&gt;</span><br><span class="line">&#123;&#123; money | capitalize(symbol) &#125;&#125;</span><br><span class="line">&lt;!-- 在 v-bind 中使用 --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>当我们仍然需要对DOM元素进行多次相同的底层操作时，就会用到自定义指令。(提高复用性)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 全局定义自定义指令 --&gt;</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">    inserted(el, binding) &#123;</span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 使用自定义指令 --&gt;</span><br><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure>

<p>自定义指令有如下几个钩子函数可以使用：<br>bind<br>inserted<br>update<br>componentUpdated<br>unbind<br>参数：el触发事件的元素, binding对象</p>
<h4 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h4><p>Vue推荐使用模板来创建html，但在一些特殊场景下，必须使用js，来用程序的方式控制。这时可以使用渲染函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render: function (createElement) &#123;</span><br><span class="line">    // createElement函数返回结果是VNode</span><br><span class="line">    return createElement(</span><br><span class="line">        tag, // 标签名称</span><br><span class="line">        data, // 传递数据</span><br><span class="line">        children //子节点数组</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用render实现heading组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;heading&apos;, &#123;</span><br><span class="line">    props: [&apos;level&apos;, &apos;title&apos;],</span><br><span class="line">    render(h) &#123;</span><br><span class="line">        return h(&apos;h&apos;+this.level, children)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>虚拟DOM的底层实现使用的是snabbdom， 在snabbdom中就是用的h作为createElement函数的名字，所以这里也用h。<br>Vue通过建立一个虚拟DOM来追踪自己要如何改变真实DOM。<br>createElement函数中的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render: function (createElement) &#123;</span><br><span class="line">    // createElement函数返回结果是VNode</span><br><span class="line">    return createElement(</span><br><span class="line">        tag, // 标签名称，一个 HTML 标签名、组件选项对象。</span><br><span class="line">        data, // 传递数据，一个与模板中属性对应的数据对象。</span><br><span class="line">        children // 子节点数组，子级虚拟节点 (VNodes)，由 `createElement()` 构建而成</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>组件没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法时，可以将组件标记为functional，这意味着它无状态(没有响应式数据)，也没有实例(没有this上下文)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;heading&apos;, &#123;</span><br><span class="line">    functional: true, // 函数式组件</span><br><span class="line">    props: [&apos;level&apos;, &apos;title],</span><br><span class="line">    render(h, context) &#123; // 组件需要的一切都是通过context获取的</span><br><span class="line">        return h()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h4><p>混入(mixin)提供了一种非常灵活的方式，来分发Vue组件中的可复用的功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个混入对象</span><br><span class="line">var myMixin = &#123;</span><br><span class="line">    created: function () &#123;</span><br><span class="line">        this.hello() // this 表示组件实例</span><br><span class="line">    &#125;,</span><br><span class="line">    // 公用方法</span><br><span class="line">    methods: &#123;</span><br><span class="line">        hello: function () &#123;</span><br><span class="line">            console.log(&apos;hello&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用混入对象的组件</span><br><span class="line">Vue.component(&apos;comp&apos;, &#123;</span><br><span class="line">    mixins: [myMixin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>选项合并的规则<br>数据对象(data选项)在内部会进行递归合并，并在发生冲突时以组件数据优先，组件的数据覆盖混入对象中的数据。<br>同名钩子函数将合并成一个数组，先调用混入对象中的钩子函数，再调用组件中的钩子函数。<br>值为对象的选项，如methods,components, directives,将被合并为同一个对象，两个对象中键名冲突时，取组件对象的键值对。</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件通常用来为Vue添加全局功能。插件的功能范围有以下几种：</p>
<ol>
<li>添加全局方法或者属性。如vue-custom-element</li>
<li>添加全局资源：指令/过滤器/过渡等。如vue-touch</li>
<li>通过全局混入来添加一些组件选项。如vue-router</li>
<li>添加Vue实例方法，通过把他们添加到Vue.prototype上实现。</li>
<li>一个库，提供自己的API，同时提供上面提到的一个或多个功能。如vue-router</li>
</ol>
<p>插件声明<br>Vue的插件生命应该暴露一个install方法。这个方法的第一个参数是Vue构造函数，第二个参数是一个可选的选项对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">myPlugin.install = function (Vue, options) &#123;</span><br><span class="line">    // 1. 添加全局方法或属性</span><br><span class="line">    Vue.myGlobalMethod = function () &#123;&#125;</span><br><span class="line">    // 2. 添加全局资源</span><br><span class="line">    Vue.directive(&apos;my-directive&apos;, &#123;&#125;)</span><br><span class="line">    // 3. 注入组件选项</span><br><span class="line">    Vue.mixin(&#123;&#125;)</span><br><span class="line">    // 4. 添加实例方法</span><br><span class="line">    Vue.prototype.$myMethod = function (methodOptios) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件使用<br>使用Vue.use()引入插件<br>修改heading组件为插件，通过插件的方式去分发,更加便捷。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const MyPlugin = &#123;    </span><br><span class="line">    install (Vue, options) &#123;</span><br><span class="line">        Vue.component(&apos;heading&apos;, &#123;...&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class="line">    window.Vue.use(MyPlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p>使用Vue-cli脚手架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<h4 id="快速原型开发"><a href="#快速原型开发" class="headerlink" title="快速原型开发"></a>快速原型开发</h4><p>vue serve 和 vue build命令对单个.vue文件进行快速原型开发。不过这需要先额外安装一个全局的扩展：@vue/cli-service-global.<br>vue serve 的缺点就是它需要安装全局依赖，这使得它在不同机器上的一致性不能得到保证。因此这只适用于快速原型开发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装@vue/cli-service-global扩展</span><br><span class="line">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure>

<h4 id="vue-serve"><a href="#vue-serve" class="headerlink" title="vue serve"></a>vue serve</h4><p>启动一个服务并运行一个原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue serve hello.vue</span><br></pre></td></tr></table></figure>

<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>创建一个vue项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-vue-project</span><br></pre></td></tr></table></figure>

<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>Vue Cli使用了一套基于插件的架构。插件可以修改webpack的内部配置，也可以向vue-cli-service诸如命令。在项目创建的过程中，绝大部分列出的特性都是通过插件来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在项目中安装插件</span><br><span class="line">vue add router</span><br></pre></td></tr></table></figure>

<p>安装插件完成后，会对项目目录以及内容有一些破坏性的更改，因此要提前备份之前的代码。</p>
<h4 id="处理资源路径"><a href="#处理资源路径" class="headerlink" title="处理资源路径"></a>处理资源路径</h4><p>当在js，css，vue文件中使用相对路径(必须以.开头)引用一个静态资源时，将来该资源将会被webpack处理。</p>
<h5 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h5><ul>
<li><p>URL 是一个绝对路径(如/images/foo.png),就是永远到当前服务器存放静态文件的路径下查找(一般是public)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/assets/logo.png&quot;&gt;</span><br><span class="line">&lt;img src=&quot;http://image.xx.com/logo.png&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>URL 以.开头会作为一个相对模块请求被解释并基于文件系统相对路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>URL 以~开头会作为一个模块请求被解释。因此可以引用Node模块中的资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;~npm-package/foo.png&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>URL 以@开头会作为一个模块请求被解释。Vue Cli默认会设置一个指向src的别名@。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Hello from &apos;@/components/hello.vue&apos;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="何时使用public文件夹-处理静态文件"><a href="#何时使用public文件夹-处理静态文件" class="headerlink" title="何时使用public文件夹(处理静态文件)"></a>何时使用public文件夹(处理静态文件)</h5><p>通过webpack的处理可以获得如下好处:</p>
<ul>
<li>脚本和样式表会被压缩且打包在一起，从而避免而外的网络请求。</li>
<li>文件丢失会直接在编译时报错，而不是到了客户端才产生404错误。</li>
<li>最终生成的文件名包含了内容哈希，因此不必担心浏览器会缓存它们的老版本。</li>
</ul>
<p>如下情况考虑使用public文件夹</p>
<ul>
<li>需要在构建输出中指定一个固定的文件名字。</li>
<li>有上千个图片，需要动态引用它们的路径。</li>
<li>有些库可能和webpack不兼容，除了将其用一个独立的script标签引入没有别的选择。</li>
</ul>
<p>使用public文件夹的注意事项</p>
<ul>
<li><p>如果你的应用没有部署在域名的根部，那么你需要为你的URL配置publicPath前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 新建vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/cart/&apos; : &apos;/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在public/index.html等通过html-webpack-plugin用作模板的HTML文件中，你需要通过&lt;%= BASE_URL %&gt;设置链接前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模板中，先向组件传入BASE_URL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        publicPath: process.env.BASE_URL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 动态文件路径拼接</span><br><span class="line">&lt;img :src=&quot;`$&#123;publicPath&#125;my-img.png`&quot;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一般不推荐使用public文件夹</p>
<h4 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h4><h5 id="使用预处理器"><a href="#使用预处理器" class="headerlink" title="使用预处理器"></a>使用预处理器</h5><p>如果创建项目的时候没有选择需要的预处理器(Sass/Less/Stylus)， 则需要手动安装相应的loader。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Sass</span><br><span class="line">npm install -D sass-loader node-sass</span><br><span class="line"></span><br><span class="line"># Less</span><br><span class="line">npm install -D less-loader less</span><br><span class="line"></span><br><span class="line"># Stylus</span><br><span class="line">npm install -D stylus-loader stylus</span><br></pre></td></tr></table></figure>

<h5 id="自动化导入样式"><a href="#自动化导入样式" class="headerlink" title="自动化导入样式"></a>自动化导入样式</h5><p>自动化导入样式文件(用于颜色，变量，mixin等)，可以使用style-resources-loader。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D style-resources-loader</span><br></pre></td></tr></table></figure>

<p>配置vue.config.js，就是与webpack在交互，这里面的配置都会设置到webpack的配置中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">function addStyleResource(rule) &#123;</span><br><span class="line">    rule.use(&apos;style-resource&apos;)</span><br><span class="line">        .loader(&apos;style-resources-loader&apos;)</span><br><span class="line">        .options(&#123;</span><br><span class="line">            patterns: [</span><br><span class="line">                path.resolve(__dirname, &apos;./src/styles/imports.scss&apos;)</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        const types = [&apos;vue-modules&apos;, &apos;vue&apos;, &apos;normal-modules&apos;, &apos;normal&apos;]</span><br><span class="line">        types.forEach(type =&gt; addStyleResource(config.module.rule(&apos;scss&apos;).oneof(type)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Scoped-CSS"><a href="#Scoped-CSS" class="headerlink" title="Scoped CSS"></a>Scoped CSS</h5><p>当标签style有scoped属性时，它的CSS只作用于当前组件中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .red &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>其原理就是通过使用postCSS来转换成如下，实际上就是增加了一个属性用来标记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;red&quot; data-v-f3f3eg9&gt;hi&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .red[data-v-f3f3eg9] &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>混用全局和本地样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">&lt;!-- 全局样式 --&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;!-- 本地样式 --&gt;</span><br><span class="line">&lt;!-- 注意在scoped中，样式只能设置到组件的第一层标签上，样式的设置不会穿透到组件内部元素。 --&gt;</span><br><span class="line">#app p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>深度作用选择器：使用&gt;&gt;&gt;操作符可以使用scoped样式中的一个选择器能够作用得更深。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">#app &gt;&gt;&gt; a &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>Sass之类的预处理器无法正确解析&gt;&gt;&gt;这中情况下可以使用/deep/或者::v-deep操作符取而代之</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">    #app &#123;</span><br><span class="line">        /deep/ a &#123;</span><br><span class="line">            color: rgb(196, 50, 140)</span><br><span class="line">        &#125;</span><br><span class="line">        ::v-deep a &#123;</span><br><span class="line">            color: rgb(196, 50, 140)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h5><p>CSS Modules 是一个流行的,用于模块化和组合CSS的系统。vue-loader 提供了与CSS Modules 的一流集成，可以作为模拟scoped CSS的替代方案。<br>原理：对类名做修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用module 替代 scoped</span><br><span class="line">&lt;style module lang=&quot;scss&quot;&gt;</span><br><span class="line">    .red &#123;</span><br><span class="line">        color: #f00;</span><br><span class="line">    &#125;</span><br><span class="line">    .bold &#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>模板中通过$style.xx访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a :class=&quot;$style.red&quot;&gt;awesome-vue&lt;/a&gt;</span><br><span class="line">&lt;a :class=&quot;&#123;[$style.red]:isRed&#125;&quot;&gt;awesome-vue&lt;/a&gt;</span><br><span class="line">&lt;a :class=&quot;[$style.red, $style.bold]&quot;&gt;awesome-vue&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>js中访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        created () &#123;</span><br><span class="line">            // red类名变成了red_1VyoJ-uz 附加在标签上，这是一个基于文件名和类名生成的标识符。</span><br><span class="line">            console.log(this.$style.red)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="数据访问相关"><a href="#数据访问相关" class="headerlink" title="数据访问相关"></a>数据访问相关</h4><h5 id="数据模拟"><a href="#数据模拟" class="headerlink" title="数据模拟"></a>数据模拟</h5><p>使用开发服务器配置before选项，可以编写接口，提供模拟数据。<br>在vue.config.js 中进行配置。<br>参考：<a href="https://cli.vuejs.org/zh/config/#devserver" target="_blank" rel="noopener">https://cli.vuejs.org/zh/config/#devserver</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        before(app) &#123;</span><br><span class="line">            // app是一个express实例, 模拟接口</span><br><span class="line">            app.get(&apos;/api/courses&apos;, (req, res) =&gt; &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    res.json([&#123;name: &apos;web&apos;, price: 9999&#125;, &#123;name: &apos;java&apos;, price: 10000&#125;])</span><br><span class="line">                &#125;, 1000)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装axios</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S axios</span><br></pre></td></tr></table></figure>

<p>使用axios请求数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function getCourses() &#123;</span><br><span class="line">    return axios.get(&apos;/api/courses&apos;).then(res =&gt; res.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代理proxy"><a href="#代理proxy" class="headerlink" title="代理proxy"></a>代理proxy</h5><p>当前端应用和后端API服务器没有运行在同一个主机上，需要在开发环境下将API请求代理到API服务器。可以通过vue.config.js中的devServer.proxy选项来配置。<br>设置开发服务器代理选项可以有效避免调用接口时出现的跨域问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        // 对于没有找到的url(静态资源)，转发到下面的地址。</span><br><span class="line">        proxy: &apos;http://localhost:3000&apos; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置代理服务器<br>当没有请求到资源的时候，会转发到下面这个服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// api.js</span><br><span class="line">// 需要安装express: npm i express</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const app = express()</span><br><span class="line">app.get(&apos;/api/courses&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.json([&#123;name: &apos;web&apos;, price: 9999&#125;, &#123;name: &apos;java&apos;, price: 10000&#125;])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure>

<p>启动代理服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node api.js</span><br></pre></td></tr></table></figure>

<h3 id="路由Vue-router"><a href="#路由Vue-router" class="headerlink" title="路由Vue-router"></a>路由Vue-router</h3><p>Vue Router 是Vue 的官方的路由管理器。<br>参考： <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add router</span><br></pre></td></tr></table></figure>

<h4 id="路由规划"><a href="#路由规划" class="headerlink" title="路由规划"></a>路由规划</h4><p>根据业务功能，做相应的路由规划，合理划分不同的路由对应不同的页面来实现相应的功能。</p>
<h5 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h5><p>以插件形式安装之后，就会有router文件夹，路由配置在index.js内，页面组件在views文件夹下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">import Home from &apos;../viewsHome.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        name: &apos;home&apos;,</span><br><span class="line">        component: Home</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    base: process.env.BASE_URL,</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/admin&quot;&gt;管理&lt;/router-link&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure>

<h5 id="路由出口"><a href="#路由出口" class="headerlink" title="路由出口"></a>路由出口</h5><p>这个标签相当于是一个占位符，组件将来会展示在这里，并把这个标签替换掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>

<h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>在Vue-router的路由路径中使用”动态路径参数”，实现动态路由匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// id 是可以变化的</span><br><span class="line">&#123;</span><br><span class="line">    path: &apos;/user/:id&apos;,</span><br><span class="line">    name: &apos;user&apos;</span><br><span class="line">    component: User</span><br><span class="line">&#125;</span><br><span class="line">// 获取参数id的值</span><br><span class="line">$route.params.id</span><br></pre></td></tr></table></figure>

<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符 *"></a>通配符 *</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 会匹配所有的路径</span><br><span class="line">&#123; </span><br><span class="line">    path: &apos;*&apos;,</span><br><span class="line">    component: () =&gt; import(&apos;../views/404.vue&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>应用界面通常由多层嵌套的组件组合而成。同样URL中各段动态路径也按某种结构对应嵌套的各层组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/about&apos;,</span><br><span class="line">    name: &apos;about&apos;,</span><br><span class="line">    component: () =&gt; import(&apos;../views/About.vue&apos;),</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/courses/:name&apos;, // 相对路径</span><br><span class="line">            name: &apos;detail&apos;</span><br><span class="line">            component: () =&gt; import(&apos;../views/Detail.vue&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套内容的出口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 动态变化的子组件会显示在这里</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编程导航"><a href="#编程导航" class="headerlink" title="编程导航"></a>编程导航</h4><p>借助$router的实例方法，可编写代码来实现路由导航。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">$router.push(&apos;/&apos;)</span><br><span class="line">// 对象</span><br><span class="line">$router.push(&#123;path: &apos;home&apos;&#125;)</span><br><span class="line">// 命名路由</span><br><span class="line">$router.push(&#123;name: &apos;detail&apos;, params: &#123;id: &apos;xxx&apos;&#125;&#125;)</span><br><span class="line">// 带查询参数 /detail?id=123</span><br><span class="line">$router.push(&#123;path: &apos;detail&apos;, query: &#123; id: &apos;123&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>给路由一个名称，使用会更加方便</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/user/:userId&apos;,</span><br><span class="line">            name: &apos;user&apos;,</span><br><span class="line">            component: User</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>链接到一个命名路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;user, params: &#123; userId: 123&#125;&apos;&#125;&quot;&gt;User&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p>在$router.push()中使用命名路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router.push(&#123; name: &apos;user&apos;, params: &#123;userId: 123&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>注意 组件复用时，路由切换引起的子组件切换不会重新创建父组件，包含有ajax请求数据的生命周期函数，不会被再次调用。可以通过监听路由参数变化，去请求数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 响应路由参数变化</span><br><span class="line">export default &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        $route: &#123;</span><br><span class="line">            handler: () =&gt; &#123;console.log(&quot;route changed&quot;)&#125;,</span><br><span class="line">            immediate: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的，单个路由独享的，或者组件级的。<br>应用场景：权限控制，登陆以后才可以查看。</p>
<ul>
<li>全局守卫<br>全局守卫，进入每一个路由前，都会先进入下面的钩子函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    // to: Route (即将要进入的目标 路由对象)</span><br><span class="line">    // from: Route (当前导航正要离开的路由)</span><br><span class="line">    // next: Function(一定要调用该方法来resolve这个钩子)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    // 判断路由是否需要守卫 先给该路由设置meta数据</span><br><span class="line">    if (to.meta.auth) &#123;</span><br><span class="line">        // 判断是否登陆</span><br><span class="line">        if (window.isLogin) &#123;</span><br><span class="line">            next()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next(&apos;/login?redirect=&apos; + to.fullPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// routes</span><br><span class="line">&#123;</span><br><span class="line">    path: &apos;/about&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">        auth: true</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&apos;../view/about.vue&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>路由独享的守卫<br>为某一个路由设置守卫，只有在进入这个路由的时候才会执行钩子函数。<br>在路由配置上直接定义beforeEnter守卫。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/about&apos;,</span><br><span class="line">    name: &apos;about&apos;,</span><br><span class="line">    component: () =&gt; import(&apos;../views/Login.vue&apos;),</span><br><span class="line">    beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件级的守卫<br>在路由组件内直接定义以下路由导航守卫：<br>beforeRouterEnter, beforeRouterUpdate, beforeRouterLeave</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beforeRouterEnter(to, from, next) &#123;</span><br><span class="line">    if (window.isLogin) &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next(&apos;/login?redirect=&apos; + to.fullPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据获取<br>路由激活时，如果需要获取服务器数据，有两个时机。<br>路由导航前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 此时组件未渲染，通过给next传递回调访问组件实例</span><br><span class="line">beforeRouterEnter(to, from, next) &#123;</span><br><span class="line">    getPost(to.params.id, post =&gt; &#123;</span><br><span class="line">        next(vm =&gt; vm.setData(post))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 此时组件已经渲染，可以访问this直接赋值</span><br><span class="line">beforeRouterUpdate(to, from, next) &#123;</span><br><span class="line">    this.post = null</span><br><span class="line">    getPost(to.params.id, post =&gt; &#123;</span><br><span class="line">        this.setData(post)</span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>路由导航后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    this.fetchData()</span><br><span class="line">&#125;,</span><br><span class="line">// 监听路由的方式出发异步获取数据的方法。</span><br><span class="line">watch: &#123;</span><br><span class="line">    &apos;$route&apos;: &apos;fetchData&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编程方式动态添加路由<br>通过router.addRoutes(routes)方式动态添加路由列表。<br>应用场景：只有登陆之后，才能访问某些路由。这里在登陆之后，才添加一些路由。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line">    window.login = true</span><br><span class="line">    this.$router.addRoutes([</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/about&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h3><p>重新创建动态组件的行为通常是非常有用的，但是有时候需要某个组件第一次被创建的时候状态就被缓存下来，再次切换到这个组件的时候，会以之前的状态显示。 利用keepalive做组件缓存，主要用于保留组件状态或避免重新渲染，提高执行效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 设置include, max属性，include 表示要缓存的组件</span><br><span class="line">&lt;keep-alive :include=&quot;[&apos;admin&apos;, &apos;about&apos;]&quot; :max=&quot;10&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;!-- 逗号分隔字符串 --&gt;</span><br><span class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>include 和 exclude 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示。组件需要设置name选项，匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。</p>
<p>max表示最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p>
<p>keep-alive组件的两个特别的生命周期钩子函数： activated，deactivated。它们会在keep-alive内部嵌套的所有组件中触发。</p>
<h3 id="状态管理-Vuex"><a href="#状态管理-Vuex" class="headerlink" title="状态管理 Vuex"></a>状态管理 Vuex</h3><p>Vuex是一个专为Vue应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化。<br>Vuex 中的数据的状态只能通过mutations来更改状态，如果直接在state上操作会报错，vuex 与 vue是紧耦合的，vuex利用了数据的响应式，来实现state变更时，触发视图更改。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add vuex</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>mutations是响应化的，只能是同步方法。<br>异步方法必须放在actions中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        isLogin: false,</span><br><span class="line">        userName: &apos;admin&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 派生状态，getter类似computed，只有当响应数据改变时，才会改变。</span><br><span class="line">    getters： &#123;</span><br><span class="line">        welcome(state) &#123;</span><br><span class="line">            return &apos;hello&apos; + state.userName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        setlogin(state) &#123;</span><br><span class="line">            state.isLogin = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        // 异步操作在actions中进行，要修改state也只能通过mutations</span><br><span class="line">        // 第一个参数是vuex传递的上下文： &#123;commit, dispatch, state&#125;</span><br><span class="line">        login(&#123; commit &#125;， username) &#123;</span><br><span class="line">            return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    if (username === &apos;admin&apos;) &#123;</span><br><span class="line">                        commit(&apos;setLogin&apos;)</span><br><span class="line">                        resolve()</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 1000)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 在组件中使用</span><br><span class="line">this.$store.state.isLogin</span><br><span class="line">this.$store.commit(&apos;setLogin&apos;)</span><br><span class="line">this.$store.dispatch(&apos;xxx&apos;, params)</span><br></pre></td></tr></table></figure>

<h4 id="Vuex最佳实践"><a href="#Vuex最佳实践" class="headerlink" title="Vuex最佳实践"></a>Vuex最佳实践</h4><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 子模块</span><br><span class="line">export default &#123;</span><br><span class="line">    namespaced: true, // 使用命名空间，避免命名冲突。</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册子模块</span><br><span class="line">import user from &apos;./user&apos;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        user</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 模块化必须使用模块名字去访问。</span><br><span class="line">this.$store.state.user.isLogin</span><br><span class="line">this.$store.dispatch(&apos;user/login&apos;, &apos;admin&apos;)</span><br><span class="line">this.$store.commit(&apos;user/setLogin&apos;)</span><br></pre></td></tr></table></figure>

<h5 id="Vuex辅助方法"><a href="#Vuex辅助方法" class="headerlink" title="Vuex辅助方法"></a>Vuex辅助方法</h5><p>mapState, mapGetter, mapMutations, mapActions<br>辅助函数的结果是一个对象，使用辅助函数后都可以通过this来引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 从vuex中引入mapState</span><br><span class="line">import &#123; mapState, mapGetters ,mapActions, mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        // 混入State的三种方式</span><br><span class="line">        ...mapState([&apos;login&apos;, &apos;logout&apos;]),</span><br><span class="line">        ...mapState(&apos;moduleName&apos;, [&apos;login&apos;, &apos;logout&apos;]), // 使用命名空间的方式</span><br><span class="line">        ...mapState(&#123; log: &apos;login&apos; &#125;)                   // 对象方式，重命名</span><br><span class="line">        ...mapState(&#123;                                   // 复杂的形式</span><br><span class="line">            count: state =&gt; state.count,</span><br><span class="line">            countAlias: &apos;count&apos;,</span><br><span class="line">            countPlusLocalState (state) &#123;               // 使用this关键字，不能使箭头函数。</span><br><span class="line">                return state.count + this.localCount </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 混入Getters的三种方式</span><br><span class="line">        ...mapGetters([&apos;xxx&apos;, &apos;ooo&apos;]),</span><br><span class="line">        ...mapGetters(&apos;moduleName&apos;, [&apos;xxx&apos;, &apos;ooo&apos;]), // 使用命名空间的方式</span><br><span class="line">        ...mapGetters(&#123; log: &apos;login&apos; &#125;)              // 对象方式，重命名</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        login() &#123;</span><br><span class="line">            this[&apos;user/login&apos;](&apos;admin&apos;).then(...)</span><br><span class="line">        &#125;,</span><br><span class="line">        // 混入Actions的三种方式</span><br><span class="line">        ...mapActions([&apos;user/login&apos;, &apos;user/logout&apos;]),</span><br><span class="line">        ...mapActions(&apos;user&apos;, [&apos;login&apos;, &apos;logout&apos;]), // 使用命名空间的方式</span><br><span class="line">        ...mapActions(&#123;add: &apos;increment&apos;&#125;)           // 对象方式，重命名</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        // 混入Mutations 三种方式</span><br><span class="line">        ...mapMutations(&apos;xxx&apos;, [&apos;increment&apos;, &apos;incrementBy&apos;]), </span><br><span class="line">        ...mapMutations([&apos;increment&apos;, &apos;incrementBy&apos;]),        // 使用命名空间的方式</span><br><span class="line">        ...mapMutations(&#123;add: &apos;increment&apos;&#125;)                   // 对象方式，重命名</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    strict: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="Vuex插件"><a href="#Vuex插件" class="headerlink" title="Vuex插件"></a>Vuex插件</h5><p>Vuex的store接受plugins选项，这个选项暴露出每次mutation的钩子。Vue插件就是一个函数，接受store作为唯一的参数。<br>使用场景：实现用户登陆状态持久化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// src/store/plugins/persist</span><br><span class="line"></span><br><span class="line">export default store =&gt; &#123;</span><br><span class="line">    // store初始化的时候，将存储在localStorage中的状态还原</span><br><span class="line">    if (localStorage) &#123;</span><br><span class="line">        const user = JSON.parse(localStorage.getItem(&apos;user))</span><br><span class="line">        if (user) &#123;</span><br><span class="line">            store.commit(&apos;login&apos;, user.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //  如果用户相关状态发生变化，执行回调函数，自动存入localStorage</span><br><span class="line">    store.subscribe((mutation, state) =&gt; &#123;</span><br><span class="line">        if (mutation.type === &apos;user/login&apos;) &#123;</span><br><span class="line">            // 将user数据写入缓存</span><br><span class="line">            const user =  JSON.stringify(state.user)</span><br><span class="line">            localStorage.setItem(&apos;user&apos;, user)</span><br><span class="line">        &#125; else if (mutation.type === &apos;user/logout&apos;) &#123;</span><br><span class="line">            // 移除缓存</span><br><span class="line">            localStorage.removeItem(&apos;user&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 注册插件, 插件在store初始化后调用</span><br><span class="line">import myPlugin from &apos;./store/plugins/persist.js&apos;</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    plugins: [myPlugin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p>路由组件的懒加载能把不同路由对应的组件分割成不同的代码，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/about&apos;,</span><br><span class="line">    name: &apos;about&apos;,</span><br><span class="line">    component: () =&gt; import(&apos;../views/Login.vue&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="To-do-list"><a href="#To-do-list" class="headerlink" title="To do list"></a>To do list</h1><h2 id="事件派发方式的祖先和孙子组件之间的通信方式-混入dispatch方法"><a href="#事件派发方式的祖先和孙子组件之间的通信方式-混入dispatch方法" class="headerlink" title="事件派发方式的祖先和孙子组件之间的通信方式-混入dispatch方法"></a>事件派发方式的祖先和孙子组件之间的通信方式-混入dispatch方法</h2><h1 id="Vue源码学习1"><a href="#Vue源码学习1" class="headerlink" title="Vue源码学习1"></a>Vue源码学习1</h1><p>Vue响应式注意点：</p>
<ol>
<li>没有在data中声明的变量，是没有响应式的。</li>
<li>对于数组的处理只有7个变异方法改数组后，数组还是响应化的，对于delete数组或者是用索引改变数组，数组都是无法响应的。<h1 id="Vue源码学习2"><a href="#Vue源码学习2" class="headerlink" title="Vue源码学习2"></a>Vue源码学习2</h1></li>
<li>Vue中如何处理双向绑定(v-model)。</li>
<li>Vue中如何处理事件。<h1 id="Vue源码component组件化机制"><a href="#Vue源码component组件化机制" class="headerlink" title="Vue源码component组件化机制"></a>Vue源码component组件化机制</h1><h1 id="Vue源码-patch"><a href="#Vue源码-patch" class="headerlink" title="Vue源码 patch"></a>Vue源码 patch</h1><h1 id="Vue-v-for-v-if-v-model-mixin-Vue-extend-Vue-component"><a href="#Vue-v-for-v-if-v-model-mixin-Vue-extend-Vue-component" class="headerlink" title="Vue v-for v-if v-model mixin Vue.extend Vue.component"></a>Vue v-for v-if v-model mixin Vue.extend Vue.component</h1><h1 id="nextTick-forceUpdate"><a href="#nextTick-forceUpdate" class="headerlink" title="nextTick forceUpdate"></a>nextTick forceUpdate</h1><h1 id="watch选项，computed选项"><a href="#watch选项，computed选项" class="headerlink" title="watch选项，computed选项"></a>watch选项，computed选项</h1></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/05/面试学习/" data-id="ckh44mzv2001r4sv225t9ws29" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue源码学习思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/04/Vue源码学习思考/" class="article-date">
  <time datetime="2020-06-04T05:57:42.000Z" itemprop="datePublished">2020-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/Vue源码学习思考/">Vue源码学习思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue-source-code"><a href="#Vue-source-code" class="headerlink" title="Vue source code"></a>Vue source code</h1><p>本章所有内容都是基于Vue 2.6.11版本</p>
<p>在学习Vue 源码之前，我们可以先思考Vue作为前端web框架，给我们提供了什么东西，我们以何种方式去使用Vue，在使用Vue的过程中有哪些值得注意的点（坑）。然后我们可以从这些点思考Vue如何实现这些功能(API)，探究Vue内部的具体实现原理。从整体的层面来考虑Vue，我们应该先思考Vue 做了一些什么事情，或者说是作为一个web框架应该实现的东西。当我们使用一个web框架去实现一个web应用程序的时候，不管使用这个框架时所使用的编程语法多么的复杂或是简单，其内部都应该不可避免的会去实现一些东西，比如编译器，将程序员写的代码(模板)编译成HTML代码，因为浏览器只会将html处理并渲染，并不理解程序员自定义的标签，因此我们可以学习，Vue是如何实现编译器的，如何实现将自定义的标签，属性，指令编译成html代码。然后我们可以思考一下Vue框架的特性，数据响应化，即Vue能够监听对用户定义的状态所做的更改，并对DOM进行响应式的更新。然后学习Vue中各种API具体是如何实现的，通过这一步，可以知道使用Vue的过程中出现一些错误的原因，比如为什么data必须是一个返回对象的函数，为什么获取数据的最早时机只能是在created生命周期函数钩子中。同时我们通过学习源码，能知道Vue内部一些代码的执行时机。综上所述，我们在学习完源码之后，应该可以知道如何以最佳方式去使用Vue，避免在使用Vue的时候出现一些迷惑性的操作，以及对出现的问题，能够很好的追根溯源。</p>
<p>总结 我们应该学习以下要点：</p>
<ol>
<li>Vue 构造函数 实现的完整流程。</li>
<li>Vue 数据响应化处理包括(object, array)，这里有监听器(Watcher class),依赖收集(Dep class).还涉及到了发布订阅模式的使用。</li>
<li>Vue 如何实现模板编译(compile), 这里有虚拟DOM(Vnode class)，抽象语法树(AST)。</li>
<li>Vue 具体如何实现这些API，$nextTick(), forceUpdate(), setData()。</li>
<li>Vue 中使用到的设计模式，比如发布订阅模式，混入模式等。</li>
<li>Vue 中可以实现的对于数据类型的判断的(object, null, undefined)，以及数据转换的实现(toString, toNumber)</li>
</ol>
<h2 id="How-to-start"><a href="#How-to-start" class="headerlink" title="How to start"></a>How to start</h2><p>首先我们需要获取Vue源码<br>Vue源码地址： https:/github.com/vuejs/vue<br>当前版本： 2.6.10</p>
<ol>
<li><p>获取源码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https:/github.com/vuejs/vue</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置调试环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入vue源文件，下载依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装rollup(专门用于js代码的打包工具)</span></span><br><span class="line">npm install -g rollup</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改package.json<br>在scripts &gt; dev 下添加 –sourcemap<br>指明配置文件所在目录： -c scripts/config.js </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动命令<br>当运行命令后会生成对应打包后的vue.js文件，在/dist目录下。<br>vue各版本： vue.runtime.common.js 用于webpack 1.x， browserify。vue.runtime.esm.js用于webpack 2.x。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建html文件用于浏览器调试<br>新建 /examples/test/test.html</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入vue.js 创建Vue实例</span></span><br><span class="line">&lt;script src=<span class="string">"/dist/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg1:<span class="string">'hello vue'</span>,</span><br><span class="line">            msg2: <span class="string">'coke'</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>源码入口文件<br>我们学习的是打包后生成的带编译器的vue.js文件。<br>所以源码学习从入口文件从 /src/platforms/web/entry-runtime-with-compiler.js开始。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Runtime+compiler development build (Browser)</span></span><br><span class="line">    <span class="string">'web-full-dev'</span>: &#123;</span><br><span class="line">        entry: resolve(<span class="string">'web/entry-runtime-with-compiler.js'</span>), <span class="comment">// webpack打包的入口文件</span></span><br><span class="line">        dest: resolve(<span class="string">'dist/vue.js'</span>), <span class="comment">// webpack打包生成的目标文件的位置</span></span><br><span class="line">        format: <span class="string">'umd'</span>, <span class="comment">// 输出规范</span></span><br><span class="line">        env: <span class="string">'development'</span>,</span><br><span class="line">        alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</span><br><span class="line">        banner</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Vue-Constructor-Function"><a href="#Vue-Constructor-Function" class="headerlink" title="Vue Constructor Function"></a>Vue Constructor Function</h2><p>经过以上步骤，我们已经知道了从哪一个文件开始分析vue源码，但是我这里不从最外层一层一层开始分析，因为我已经整理过，下图是我自己总结的Vue构造函数的简单的整体结构是什么样子的，所以我直接从Vue源码最底层开始讲起，分析Vue是如何从最初的构造函数一步步壮大的。更详细的Vue源码分析的思维导图，请查看地址：<a href="https://www.processon.com/view/link/5ed8b1df5653bb445ce4a8ba。" target="_blank" rel="noopener">https://www.processon.com/view/link/5ed8b1df5653bb445ce4a8ba。</a></p>
<img src="/static/img/VueCorFunc.png">
首先会有一个简单的Vue构造函数，我称之为Basic Vue，在这里这仅仅是一个简单的构造函数，其内部只有一个_init()方法的调用，也就是当我们写new Vue({xxx})的时候，会去执行到_init这个方法。看到这里你可能会问_init是在哪里定义的，继续往下看，我们会看到initMixin(Vue)这个方法的调用，也就是在这个方法中，我们可以看到给Vue的实例绑定了一个_init()方法。

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/04/Vue源码学习思考/" data-id="ckh44mztq000q4sv2da1onx1i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/How-to-use-hexo-create-a-blog/">How to use hexo create a blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas-基础/">canvas 基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 20px;">CSS</a> <a href="/tags/DOM/" style="font-size: 10px;">DOM</a> <a href="/tags/How-to-use-hexo-create-a-blog/" style="font-size: 10px;">How to use hexo create a blog</a> <a href="/tags/canvas-基础/" style="font-size: 10px;">canvas 基础</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/09/DOM/">DOM</a>
          </li>
        
          <li>
            <a href="/2020/10/09/CSS总结/">CSS总结</a>
          </li>
        
          <li>
            <a href="/2020/10/09/canvas基础/">canvas</a>
          </li>
        
          <li>
            <a href="/2020/10/09/设计模式/">设计模式</a>
          </li>
        
          <li>
            <a href="/2020/10/09/重识CSS/">重识CSS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Richard.Zhao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>