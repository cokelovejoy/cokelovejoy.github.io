<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Problems in working | RICHARD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Problems in working此章用于总结工作中遇到的问题. [Vuex]:  Don’t mutate vuex store state outside mutation handler 问题产生的原因:在mutations 之外改变了vuex store state中的数据,就会产生这个报错,而且 这个只会在strict: true 的时候产生.  配置strict: 1234567e">
<meta name="keywords" content="Python, JS, Vue, NodeJS">
<meta property="og:type" content="article">
<meta property="og:title" content="Problems in working">
<meta property="og:url" content="http://yoursite.com/2019/11/02/Problems-in-working/index.html">
<meta property="og:site_name" content="RICHARD">
<meta property="og:description" content="Problems in working此章用于总结工作中遇到的问题. [Vuex]:  Don’t mutate vuex store state outside mutation handler 问题产生的原因:在mutations 之外改变了vuex store state中的数据,就会产生这个报错,而且 这个只会在strict: true 的时候产生.  配置strict: 1234567e">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-11-04T08:59:08.714Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Problems in working">
<meta name="twitter:description" content="Problems in working此章用于总结工作中遇到的问题. [Vuex]:  Don’t mutate vuex store state outside mutation handler 问题产生的原因:在mutations 之外改变了vuex store state中的数据,就会产生这个报错,而且 这个只会在strict: true 的时候产生.  配置strict: 1234567e">
  
    <link rel="alternate" href="/atom.xml" title="RICHARD" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RICHARD</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RICHARD BLOG</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Problems-in-working" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/02/Problems-in-working/" class="article-date">
  <time datetime="2019-11-02T05:14:36.000Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Problems in working
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Problems-in-working"><a href="#Problems-in-working" class="headerlink" title="Problems in working"></a>Problems in working</h1><p>此章用于总结工作中遇到的问题.</p>
<h2 id="Vuex-Don’t-mutate-vuex-store-state-outside-mutation-handler"><a href="#Vuex-Don’t-mutate-vuex-store-state-outside-mutation-handler" class="headerlink" title="[Vuex]:  Don’t mutate vuex store state outside mutation handler"></a>[Vuex]:  Don’t mutate vuex store state outside mutation handler</h2><ul>
<li><p>问题产生的原因:<br>在mutations 之外改变了vuex store state中的数据,就会产生这个报错,而且 这个只会在strict: true 的时候产生.</p>
</li>
<li><p>配置strict:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  strict: <span class="literal">true</span>,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    test: test</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>现象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      formModel: &#123;</span><br><span class="line">        <span class="string">'test'</span>: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeStoreValue() &#123;</span><br><span class="line">      <span class="keyword">this</span>.formModel[<span class="string">'test'</span>] = <span class="string">'hello'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.formModel[<span class="string">'test'</span>])</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.state.test.storeValue)</span><br><span class="line">    &#125;,</span><br><span class="line">    printVal() &#123;</span><br><span class="line">      <span class="comment">// 这种写法 改变this.formModel 也会引发 Vuex warning : Don't mutate vuex store state outside mutation handler</span></span><br><span class="line">      <span class="comment">// 实际上就是: arry变量 使用了 this.formModel 的引用 ,当arry 成为state后, this.formModel的值改变,arry也会跟着改变</span></span><br><span class="line">      <span class="comment">// 因此会引发上述的vuex warning,这种比较难发现,因此要注意.</span></span><br><span class="line">      <span class="keyword">let</span> arry = [<span class="keyword">this</span>.formModel]</span><br><span class="line">      <span class="comment">// 使用以下写法</span></span><br><span class="line">      <span class="comment">// let arrt = [Object.assign(&#123;&#125;, this.formModel)]</span></span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'test/setStoreValue'</span>, arry)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方法: </p>
</li>
</ul>
<ol>
<li><p>state中存的是基本数据类型 boolean, string, number 重新赋值给新的变量, 通过操作新的变量达到处理数据的目的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 this.$store.state.test.message = ''</span></span><br><span class="line"><span class="keyword">let</span> newVal = <span class="keyword">this</span>.$store.state.test.message</span><br></pre></td></tr></table></figure>
</li>
<li><p>state 中存的是引用数据类型, array, object (注:null 也是 object)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 this.$store.state.test.message = []</span></span><br><span class="line"><span class="comment">// 方法一: </span></span><br><span class="line"><span class="comment">// slice 方法: 会返回一个新的数组.一块新的内存空间,这样改变newArray时 不会改动this.$store.state.test.message</span></span><br><span class="line"><span class="keyword">let</span> newArray = <span class="keyword">this</span>.$store.state.test.message.slice()</span><br><span class="line"><span class="comment">// 方法二: </span></span><br><span class="line"><span class="comment">// Object.assign()方法 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span></span><br><span class="line"><span class="keyword">let</span> newArray = <span class="built_in">Object</span>.assign([], <span class="keyword">this</span>.$store.state.test.message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 this.$store.state.test.message = &#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.$store.state.test.message)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>总结:<br>在解决vuex store mutation的问题时,实际上就变成了对基本数据类型和引用数据类型的处理的问题.<br>基本数据类型string,number,boolean在赋值之后,会分配一块新的内存空间来存储值,因此改变新的变量和原来的变量相互不影响.<br>引用数据类型array,object,在赋值操作之后, 并不会分配一块新的内存空间,而是将旧的变量的引用(也可以叫内存地址)赋给新的变量,因此新旧两个变量改变时,会互相影响. 因此在编程时,要尤其注意,修改一个对象或数组后,要考虑是否会改变原来的值,原来的值在之后使用可能又会影响其他的值.所以我们要操作一个引用型的数据时要做一个副本的拷贝的工作,以保证原来的值不会以一种难以发现的方式被修改,以致于混乱。</p>
<h1 id="problems-in-work"><a href="#problems-in-work" class="headerlink" title="problems-in-work"></a>problems-in-work</h1><p>Be used to record problems in working</p>
<h1 id="vuetify"><a href="#vuetify" class="headerlink" title="vuetify"></a>vuetify</h1><p>Vuetify 设置v-flex 内容(图片文字)垂直居中， 使用 d-flex 和 align-center<br>ex: <v-flex d-flex align-center></v-flex></p>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>Your identification has been saved in /home/richard/.ssh/id_rsa.<br>Your public key has been saved in /home/richard/.ssh/id_rsa.pub.<br>password:123456</p>
<h1 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h1><h2 id="本地创建git仓库"><a href="#本地创建git仓库" class="headerlink" title="本地创建git仓库"></a>本地创建git仓库</h2><p>git init</p>
<h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:cokelovejoy/cokelovejoy.github.io.git<br>(创建 名为origin的远程仓库, 该远程仓库连接到github地址的代码库)<br>git push -u origin master (将本地的master分支推送到origin主机，同时指定origin为默认主机)</p>
<h2 id="拉取远程仓库代码到本地"><a href="#拉取远程仓库代码到本地" class="headerlink" title="拉取远程仓库代码到本地"></a>拉取远程仓库代码到本地</h2><p>git pull origin master</p>
<h2 id="创建本地分支并切换"><a href="#创建本地分支并切换" class="headerlink" title="创建本地分支并切换"></a>创建本地分支并切换</h2><p>git checkout -b dev<br>git checkout -b dev origin/dev </p>
<h2 id="拉取远程仓库代码"><a href="#拉取远程仓库代码" class="headerlink" title="拉取远程仓库代码"></a>拉取远程仓库代码</h2><p>git pull origin dev</p>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>git branch （查看当前分支）<br>git branch -r（查看远程分支）<br>git branch -a (查看所有分支)<br>git branch –set-upstream-to=origin/远程分支名 本地分支名 (git 将本地分支关联到远程分支)<br>git checkout dev （切换到已经存在的分支）<br>git checkout -b dev （在本地创建新分支，并切换到该分支）<br>git checkout -b dev origin/dev (基于远程origin/dev分支新建本地dev分支)</p>
<h2 id="拉取-提交操作"><a href="#拉取-提交操作" class="headerlink" title="拉取,提交操作"></a>拉取,提交操作</h2><p>git pull (将远程分支上的代码拉到本地)<br>git add -A<br>git commit -m’xxxx’<br>git push origin xxxbranch-name<br>git push -u origin master 命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。<br>git push –set-upstream origin dev-01(当远程没有该分支的时候，会在远程库里创建这个分支如dev-01,然后再推送文件，origin 是远程主机名)<br>git push origin dev-branch（origin表示远程主机名， dev-branch表示本地分支名）<br>git push origin（如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支）<br>git push（如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名）</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>git add file-name之后，如果取消add 使用git reset file-name即可<br>git commit -m ‘message’ 之后，如果要取消 commit<br>先使用git log 查看commit 历史记录<br>然后使用 git reset 404b1f29b3066ec19b07c3ddf76510d97c5643b1<br>（倒数第二次记录的commit哈希值），即可恢复到上一次commit。</p>
<h2 id="pull-request-merge-conflict"><a href="#pull-request-merge-conflict" class="headerlink" title="pull request merge conflict"></a>pull request merge conflict</h2><p>当pull request 为branch1 指向 branch2 时，发生冲突，需要解决冲突，将branch2 的代码 pull到brach1,在branch1上解决冲突，保留branch2上的代码。然后提交。<br>之后再在branch1上做修改，把原来的冲突代码写回来。branch2 的代码始终不能改变的。<br>step1： 拉取远程分支branch2的代码，然后合并到branch1，然后解决冲突。<br>git checkout branch1<br>git pull origin branch2<br>step2：提交改变，add，commit，push,然后 branch2 的代码 就会合并到branch1上。<br>git add -a<br>git commit -m’xxx’<br>git push origin HEAD   // HEAD为当前分支的简称</p>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>git log （查看commit提交记录）<br>git status （查看本地库文件的更改状态）<br>git diff （显示提交之间、提交和工作区之间等的差异）<br>git remote -v （显示对应的克隆地址）<br>git remote （列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库）<br>git remote show origin (查看某一个远程仓库的更多信息)</p>
<h2 id="merge用法"><a href="#merge用法" class="headerlink" title="merge用法"></a>merge用法</h2><p>一, 开发分支(dev)上的代码达到上线的标准,合并到master分支<br>git checkout dev<br>git pull<br>git checkout master<br>git merge dev<br>git push -u origin master</p>
<p>二,当master代码改动了,需要更新开发分支(dev)上的代码<br>git checkout master<br>git pull<br>git checkout dev<br>git merge master<br>git push -u origin dev</p>
<h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><p>git stash<br>git stash pop</p>
<h2 id="配置config"><a href="#配置config" class="headerlink" title="配置config"></a>配置config</h2><p>git config –global user.name ‘richard’<br>git config –global user.email ‘847035485@qq.com’<br>git config –list</p>
<p>工作笔记 ：</p>
<h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><p>全局安装@vue/cli之后显示没有 找不到vue命令。<br>解决方法： 将安装的全局包建立软连接： sudo ln -s /home/richard/npm-global/bin/vue /usr/local/bin/vue<br>建立成功会在/usr/local/bin/vue下生成vue文件。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数内的this,在定义的时候决定的.绑定定义时所在的作用域的this.<br>其他函数 的this ,是使用的时候所在的作用域的this.<br>箭头函数不能用于构造函数.</p>
<h1 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h1><p>rest参数, 把实参放入到数组中<br>…arr<br>function fn(…arr) {<br>    console.log(arr)<br>}<br>fn(1,2,3)<br>不用再使用arguments</p>
<h1 id="对象合并"><a href="#对象合并" class="headerlink" title="对象合并"></a>对象合并</h1><p>Object.assign(target, source)</p>
<h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><p>数组的扩展<br>let arr = [1,2,3]<br>let arr2 = […arr]<br>对象的扩展<br>let obj1 = {a:1}<br>let obj2 = {b:2}<br>let obj = {…obj1,…obj2}</p>
<h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><p>ES5方法<br>map() , filter(), reduce(), every(), some()</p>
<p>ES6方法<br>find(), findIndex()</p>
<p>//find 找到符合条件的第一个.<br>let arr = [1,2,3,4,5,6]<br>arr.find(function(item,index){<br>    return item &lt;3<br>})</p>
<p>indexOf()方法 返回字符串,或数组中某个值第一次出现的index,没有返回-1<br>let a= [1,2,3,4]<br>a.indexOf(4) //3</p>
<p>查找使用includes() 代替indexOf() 效率更高</p>
<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h1><p>Vue $nextTick():<br>主要用于数据改变之后需要操作DOM,DOM操作作为回调函数写入$nextTick()</p>
<h1 id="vuex-store"><a href="#vuex-store" class="headerlink" title="vuex store"></a>vuex store</h1><p>Vuex store中的数据在页面刷新后会消失,如果要让它不消失,需要使用插件将对store中的数据做持久化操作,在页面刷新之前保存到localStorage.</p>
<h1 id="Mouse-Event"><a href="#Mouse-Event" class="headerlink" title="Mouse Event"></a>Mouse Event</h1><p>Mouse Event 对象的属性clengtX和pageX和screenX和offsetX的区别:<br>clientX 设置或获取鼠标指针位置相对于浏览器内容窗口的 x 坐标，其中客户区域不包括窗口自身的控件和滚动条。</p>
<p>clientY 设置或获取鼠标指针位置相对于浏览器内容窗口的 y 坐标，其中客户区域不包括窗口自身的控件和滚动条。<br>(跟screenX相比就是将参照点改成了浏览器内容区域的左上角，该参照点会随之滚动条的移动而移动，也就是说，他计算left或top时直接忽略了滚动条的高和宽，它的参考点是浏览器可见区域的左上角，而不是页面本身的body左上角原点，计算数值和滚动条是否滚动没有关系，只是绝对的计算鼠标点距离浏览器内容区域的左上角的距离，忽略了滚动条的存在)</p>
<p>offsetX 设置或获取鼠标指针位置相对于触发事件的对象的 x 坐标。<br>offsetY 设置或获取鼠标指针位置相对于触发事件的对象的 y 坐标。</p>
<p>screenX 设置或获取获取鼠标指针位置相对于用户屏幕的 x 坐标。<br>screenY 设置或获取鼠标指针位置相对于用户屏幕的 y 坐标。</p>
<p>pageX：参照点是页面本身左上角的原点.已经把滚动条滚过的高或宽计算在内.</p>
<p>所以基本可以得出结论：<br>pageX &gt; clientX, pageY &gt; clientY<br>pageX = clientX + ScrollLeft(滚动条滚过的水平距离)<br>pageY = clientY + ScrollTop(滚动条滚过的垂直距离)</p>
<h1 id="contenteditable"><a href="#contenteditable" class="headerlink" title="contenteditable"></a>contenteditable</h1><p>HTML 全局属性contenteditable  是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。<br><label contenteditable="true">Example Label</label></p>
<h1 id="获取光标所在的位置"><a href="#获取光标所在的位置" class="headerlink" title="获取光标所在的位置"></a>获取光标所在的位置</h1><p>const selection = window.getSelection() ; //返回一个Selection对象,对象里面有一些属性可以用来取到光标所在的元素或者光标所在位置或者覆盖的文字</p>
<ul>
<li>selection对象<br>Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。要获取用于检查或修改的Selection对象，请调用 window.getSelection()。</li>
<li>range对象<br>文档中用户选择的区域(拖蓝). 获取当前选中的范围 let range = selection.getRangeAt(0)<br>属性: selection.rangeCount 返回当前选中区域的数量<br>方法: selection.getRangeAt(0), 返回选区开始的节点.<br>selection.delectionFromDocument(), 从页面中删除选区中的内容.</li>
</ul>
<h1 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h1><p>event.preventDefault().阻止事件的默认行为.</p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>有些符号在URL中是不能直接传递的，如果要在URL中传递这些特殊符号，那么就要使用他们的编码了。<br>编码的格式为：%加字符的ASCII码，即一个百分号%，后面跟对应字符的ASCII（16进制）码值。例如 空格的编码值是”%20”。<br>如果不使用转义字符，这些编码就会当URL中定义的特殊字符处理。<br>下表中列出了一些URL特殊符号及编码 十六进制值</p>
<p>1) + URL 中+号表示空格 %2B<br>2) 空格 URL中的空格可以用+号或者编码 %20<br>3) / 分隔目录和子目录 %2F<br>4) ? 分隔实际的 URL 和参数 %3F<br>5) % 指定特殊字符 %25<br>6) # 表示书签 %23<br>7) &amp; URL 中指定的参数间的分隔符 %26<br>8) = URL 中指定参数的值 %3D</p>
<h1 id="Vue-scoped-css"><a href="#Vue-scoped-css" class="headerlink" title="Vue scoped css"></a>Vue scoped css</h1><p>在style标签中使用 scoped以实现css模块化,原理是给标签打上 tag.<br>问题有时候会因为标签打上了,而找不到标签,导致设置class没有作用,因此使用scoped要仔细考虑.<br>(通过PostCSS来实现这种转换)<br><a href="https://vue-loader.vuejs.org/en/features/scoped-css.html3" target="_blank" rel="noopener">https://vue-loader.vuejs.org/en/features/scoped-css.html3</a> vue-loader的官方文档中也说了这个问题 所以使用 &gt;&gt;&gt; 符号可以做到，但是注意vue-loader的版本要高于12.2.0 这个功能是这个版本后才具有的.<br>scoped三条渲染规则：<br>　　1、给HTML的DOM节点加一个不重复data属性(形如：data-v-19fca230)来表示他的唯一性<br>　　2、在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-19fca230]）来私有化样式<br>　　3、如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性</p>
<h1 id="npm全局安装包的位置"><a href="#npm全局安装包的位置" class="headerlink" title="npm全局安装包的位置"></a>npm全局安装包的位置</h1><p>使用npm root -g 进行查询</p>
<h1 id="npm-更新版本到最新"><a href="#npm-更新版本到最新" class="headerlink" title="npm 更新版本到最新"></a>npm 更新版本到最新</h1><p>npm install npm@latest -g</p>
<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><p>输入命令sudo npm install n -g，来安装n这个工具，n可以切换node版本<br>输入命令sudo n stable，安装最新稳定版的nodejs<br>重启终端，查看node.js和npm版本,node –version,npm  –version</p>
<h1 id="Vue-forceUpdate"><a href="#Vue-forceUpdate" class="headerlink" title="Vue: $forceUpdate()"></a>Vue: $forceUpdate()</h1><p>对象深层的数据改变,Vue无法监听,用于强制更新数据</p>
<h1 id="Vue-refs"><a href="#Vue-refs" class="headerlink" title="Vue: $refs"></a>Vue: $refs</h1><p>$refs在template和computed属性中使用无效,它不是响应式的。</p>
<h1 id="Vue-native-事件修饰符"><a href="#Vue-native-事件修饰符" class="headerlink" title="Vue: native 事件修饰符"></a>Vue: native 事件修饰符</h1><p>在组件上使用 v-on 只会监听自定义事件 (组件用 $emit 触发的事件)。如果要监听根元素的原生事件，可以使用 .native 修饰符<br>.native事件修饰符只能修饰组件，不能使用到div原生标签上。</p>
<h1 id="vue中父组件通过props向子组件传异步值为空的问题"><a href="#vue中父组件通过props向子组件传异步值为空的问题" class="headerlink" title="vue中父组件通过props向子组件传异步值为空的问题"></a>vue中父组件通过props向子组件传异步值为空的问题</h1><p>因为父组件的值是通过axios请求获得，当父组件拿到处理后的值时，子组件钩子函数生命周期已经走完。因此通过props传递给子组件，在子组件的生命周期中无法访问到异步获取的值。但是在页面上是能渲染父组件传递的异步数据。</p>
<p>解决方案：通过v-if 判断值，当值有的时候再渲染子组件。<br>还可以通过Vuex。</p>
<h1 id="关于dialog-弹窗的几点思考"><a href="#关于dialog-弹窗的几点思考" class="headerlink" title="关于dialog 弹窗的几点思考"></a>关于dialog 弹窗的几点思考</h1><ol>
<li>dialog关闭 是否还需要 弹窗组件</li>
<li>由子组件通过emit事件触发父组件通过v-if 销毁整个组件。还是父组件通过$refs控制子组件中dialog的显隐，第3点解释了两种实现方式不同的原理。</li>
<li>v-if 的切换组件，会销毁组件内的数据，再打开组件时，组件的生命周期会重新走一次。</li>
</ol>
<h1 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h1><p>localStorage只能保存字符串，对于对象要用JSON.stringify和JSON.parse</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/02/Problems-in-working/" data-id="ckh44mzt3000a4sv2ajqpnk5r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/11/02/Create-my-vue/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Create my vue
        
      </div>
    </a>
  
  
    <a href="/2019/10/24/Vue介绍/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Vue介绍</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/How-to-use-hexo-create-a-blog/">How to use hexo create a blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/canvas-基础/">canvas 基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 20px;">CSS</a> <a href="/tags/DOM/" style="font-size: 10px;">DOM</a> <a href="/tags/How-to-use-hexo-create-a-blog/" style="font-size: 10px;">How to use hexo create a blog</a> <a href="/tags/canvas-基础/" style="font-size: 10px;">canvas 基础</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/09/DOM/">DOM</a>
          </li>
        
          <li>
            <a href="/2020/10/09/CSS总结/">CSS总结</a>
          </li>
        
          <li>
            <a href="/2020/10/09/canvas基础/">canvas</a>
          </li>
        
          <li>
            <a href="/2020/10/09/设计模式/">设计模式</a>
          </li>
        
          <li>
            <a href="/2020/10/09/重识CSS/">重识CSS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Richard.Zhao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>